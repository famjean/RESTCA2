#!/bin/R 
# Title : Stock of Functions
# Author : F.Jean
# Version : 0.0.1
# Creation Date: 2021-11-24
# Revision Dates: 

#>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

# 1 Creation of functions    -----------------------------
  # 1.1 Environnement and data manipulation functions
    # 1.1.1 Multiple joins on df 
    # 1.1.2 Bind rows in any case
    # 1.1.3 Bind cols in any case
    # 1.1.4 Save plot
    # 1.1.5 Compute spent time in months between two dates
    # 1.1.6 Compute spent time in years between two dates
    # 1.1.7 Convert date format to character
    # 1.1.8 Delete special character
    # 1.1.9 Function to perform standarzisation 
    # 1.1.10 Function to generate interactions terms 
    # 1.1.11 Function to generate formula
  # 1.2 Preliminary Analysis and Graphs functions
    # 1.2.1 Function to check data input quality
    # 1.2.2 Function to check data input quality graphically
    # 1.2.3 Function to check NA graphically
    # 1.2.4 Function to analyze NA
    # 1.2.5 Function to get outliers
    # 1.2.6 Function to plot outliers
    # 1.2.7 Function to study normality
    # 1.2.8 Function to plot normality study
    # 1.2.9 Function to perform univariate analysis
    # 1.2.10 Function to perform univariate analysis, full version
    # 1.2.11 Function to do descriptive stats on table incorporating multiples subgroups
    # 1.2.12 Function to perform univariate analysis plot
    # 1.2.13 Function to perform bivaraite analysis
    # 1.2.14 Function to perform univariate and bivaraite analysis
    # 1.2.15 Function to perform bivaraite plot
    # 1.2.16 Function to perform trivaraite plot
  # 1.3 Special graphics functions 
  # 1.4 Special statistics functions 
    # 1.4.1 Multiple regression Function
    # 1.4.2 Function to test difference with references 
    # 1.4.3 Bivariate analysis paired data
    # 1.4.4 Uni and BI variate analysis paired data
    # 1.4.5 Bivariate analysis paired data not on group
    # 1.4.6 Function to perform triivariate analysis non paired
    # 1.4.7 Function to perform interaction testing
  # 1.5 Other special functions
    # 1.5.1 rtime
    # 1.5.2 Function to perform multiple regressions cluster robust
    # 1.5.3 Function to perform bivariate analysis cluster robust
    # 1.5.4 Function to perform imputations, mean and median
    # 1.5.5 Function to perform forecasterros plot
  # 1.6 Text mining functions
    # 1.6.1 Function to prepare text for wordnetwork
    # 1.6.2 Function to perform wordnetwork
    # 1.6.3 Function to clean empty space
    # 1.6.4 Function to clean text
    # 1.6.5 Function to lemmatize corpus
    # 1.6.6 Function to perform tf.idf.rank
    # 1.6.7 Function to perform corpus description
    # 1.6.8 Function to palette blue

# 1 Creation of functions  -----------------------------
#~~~~~~~~~~~~~~~~~~~~~~~~~~
# 1.1 Environnement and data manipulation functions   -----------------------------
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 1.1.1 Multiple joins on df 
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

MultipleJoins <- function( ListOfDataFrames, by, FULL = TRUE  )
{
  ListOfDataFrames[[1]] -> tmp.table ;
  
  for ( a in 2:length( ListOfDataFrames ))
  {
    merge( tmp.table, 
           ListOfDataFrames[[a]], 
           by = by,
           all = FULL ) -> 
      tmp.table ;
  } ;
  
  return( tmp.table )
} ;

# 1.1.2 Bind rows in any case
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

rbind.force <- function( data, ..., keep.col = FALSE, empty = NA ) 
{
  # Unify data
  list( data, ... ) -> input ;
  
  # include list elements
  repeat 
  {
    if (  !any( unlist( lapply( input, class ) ) == "list" ) ) { break }  
    
    which( unlist( lapply( input, class ) ) == "list" )[1] -> a ;
    input[[a]] -> tmp ;
    input[[a]] <- NA ;
    c( input[1:a],  tmp, input[ (a + 1):length( input ) ] ) -> 
      input ;
  }
  
  input[ !is.na( input ) ] ->
    input ;
  
  # delete NULL data and transformt vector in data.frame
  for ( a in 1:length( input ) )
  {
    if ( is.null( dim( input[[a]] ) ) )
    {
      if ( is.null( input[[a]] ) )
      {
        input[[a]] <- NA ;
      } else
      {
        data.frame( matrix( input[[a]], nrow = 1 ),
                    stringsAsFactors = FALSE ) -> input[[a]] ; 
      }
    }
    
    if ( all( dim( input[[a]] ) == 0 ) )
    {
      input[[a]] <- NA ;
    }
  }
  
  input[ !is.na( input ) ] ->
    input ;
  
  # test data class
  if ( !all( unlist( lapply( input, is.data.frame ) ) |
             unlist( lapply( input, is.matrix ) ) |
             unlist( lapply( input, is.vector ) ) ) )
  { stop( "Some argument are not data.frame, neither vector" ) ;
    ; } ;
  
  # Set primer
  input[[1]] -> output ; 
  
  # job in case we keep columns 
  if ( keep.col & length( input ) >1 )
  {
    for ( a in 2:length( input ) )
    { 
      output -> x ;
      input[[a]] -> y ; 
      
      for (a in 1:dim(x)[2]) { x[,a] <- as.character(x[,a])}
      for (a in 1:dim(y)[2]) { y[,a] <- as.character(y[,a])}
      
      x.diff <- setdiff(colnames(x), colnames(y))
      y.diff <- setdiff(colnames(y), colnames(x))
      
      if( dim(x)[1] > 0 ) { x[, c(as.character(y.diff))] <- empty ; }
      if( dim(y)[1] > 0 ) { y[, c(as.character(x.diff))] <- empty ; }
      
      rbind(x, y) -> output ;
    } 
  }
  
  # job in case we do not keep columns
  if ( !keep.col & length( input ) >1 )
  {
    for ( a in 2:length( input ) )
    { 
      output -> x ;
      input[[a]] -> y ; 
      
      colnames(x) <- paste( "X",
                            1:dim( x )[2], 
                            sep = "" ) ;
      colnames(y) <- paste( "X",
                            1:dim( y )[2], 
                            sep = "" ) ;
      
      for (a in 1:dim(x)[2]) { x[,a] <- as.character(x[,a])}
      for (a in 1:dim(y)[2]) { y[,a] <- as.character(y[,a])}
      
      x.diff <- setdiff(colnames(x), colnames(y))
      y.diff <- setdiff(colnames(y), colnames(x))
      
      if( dim(x)[1] > 0 ) { x[, c(as.character(y.diff))] <- empty ; }
      if( dim(y)[1] > 0 ) { y[, c(as.character(x.diff))] <- empty ; }
      
      rbind(x, y) -> output ;
    } 
  }
  
  return( output ) ;
} 

# 1.1.3 Bind rows in any case
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

cbind.force <- function( data, ... , keep.row = FALSE, empty = NA ) 
{
  # Unify data
  list( data, ... ) -> input ;
  
  # include list elements
  repeat 
  {
    if (  !any( unlist( lapply( input, class ) ) == "list" ) ) { break }  
    
    which( unlist( lapply( input, class ) ) == "list" )[1] -> a ;
    input[[a]] -> tmp ;
    input[[a]] <- NA ;
    c( input[1:a],  tmp, input[ (a + 1):length( input ) ] ) -> 
      input ;
  }
  
  input[ !is.na( input ) ] ->
    input ;
  
  # delete NULL data and transform vector in data.frame
  for ( a in 1:length( input ) )
  {
    if ( is.null( dim( input[[a]] ) ) )
    {
      if ( is.null( input[[a]] ) )
      {
        input[[a]] <- NA ;
      } else
      {
        data.frame( input[[a]],
                    stringsAsFactors = FALSE ) -> input[[a]] ; 
        "vector" -> colnames(  input[[a]] ) ;
      }
    }
    
    if ( all( dim( input[[a]] ) == 0 ) )
    {
      input[[a]] <- NA ;
    }
  }
  
  input[ !is.na( input ) ] ->
    input ;
  
  # test data class
  if ( !all( unlist( lapply( input, is.data.frame ) ) |
             unlist( lapply( input, is.matrix ) ) |
             unlist( lapply( input, is.vector ) ) ) )
  { stop( "Some argument are not data.frame, neither vector" ) ;
    ; } ;
  
  # Set primer
  input[[1]] -> output ; 
  
  # job in case we keep columns 
  if ( keep.row & length( input ) > 1 )
  {
    for ( a in 2:length( input ) )
    { 
      output -> x ;
      input[[a]] -> y ; 
      
      for (a in 1:dim(x)[2]) { x[,a] <- as.character(x[,a])}
      for (a in 1:dim(y)[2]) { y[,a] <- as.character(y[,a])}
      
      x.diff <- setdiff(rownames(x), rownames(y))
      y.diff <- setdiff(rownames(y), rownames(x))
      
      if( dim(x)[2] > 0 ) { x[ c(as.character(y.diff)), ] <- empty ; }
      if( dim(y)[2] > 0 ) { y[ c(as.character(x.diff)), ] <- empty ; }
      
      cbind(x, y) -> output ;
    } 
  }
  
  # job in case we do not keep columns
  if ( !keep.row & length( input ) > 1 )
  {
    for ( a in 2:length( input ) )
    { 
      output -> x ;
      input[[a]] -> y ; 
      
      if ( dim( x )[1] > 0 ) 
      {
        rownames(x) <- paste( "X",
                              1:dim( x )[1], 
                              sep = "" ) ;
      }
      
      if ( dim( y )[1] > 0 ) 
      {
        rownames(y) <- paste( "X",
                              1:dim( y )[1], 
                              sep = "" ) ;
      }
      
      
      
      for (a in 1:dim(x)[2]) { x[,a] <- as.character(x[,a])}
      for (a in 1:dim(y)[2]) { y[,a] <- as.character(y[,a])}
      
      x.diff <- setdiff(rownames(x), rownames(y))
      y.diff <- setdiff(rownames(y), rownames(x))
      
      if( dim(x)[2] > 0 ) { x[ c(as.character(y.diff)), ] <- empty ; }
      if( dim(y)[2] > 0 ) { y[ c(as.character(x.diff)), ] <- empty ; }
      
      cbind(x, y) -> output ;
    } 
  }
  
  return( output ) ;
} ;

# 1.1.4 Save plot
#~~~~~~~~~~~~~~~~~~

Save.Plot <- function( Title, ExportFile, ext = "png" )
{
  paste( ExportFile, "/", Title, ".", ext, sep = "" ) -> tmp.name ;
  savePlot( filename = tmp.name , type= ext ) ;
  dev.off() ;
} ;

# 1.1.5 Compute spent time in months between two dates
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

SpentTime.InMonths <- function( From , To )
{ 
  if( !any(class( From ) == "POSIXlt" ) ) 
  { stop( "From is not of POSIXlt type" ) } 
  if( !any( class( To )[1] == "POSIXlt" ) ) 
  { stop( "To is not of POSIXlt type" ) } 
  
  To$year - From$year -> years ;
  
  years * 12 -> months ;
  
  unlist( lapply( 1:length( From ),
                  FUN = function(a, months){ 
                    if ( !is.na( From[a] ) & !is.na( To[a] ) )
                    {
                      if ( months[a] >= 1 |
                           ( months[a] == 0 & From[a]$mon <= To[a]$mon ) )
                      {
                        if ( To[a]$mday >= From[a]$mday )
                        {
                          months[a] - From[a]$mon + To[a]$mon -> tmp ;
                        } else 
                        {
                          months[a] - From[a]$mon + To[a]$mon - 1 -> tmp ;
                        }
                      }
                      
                      if ( months[a] < 0 )
                      {
                        if ( From[a]$mday >= To[a]$mday  )
                        {
                          months[a] + To[a]$mon - From[a]$mon  -> tmp ;
                        } else 
                        {
                          months[a] + To[a]$mon - From[a]$mon + 1 -> tmp ;
                        }
                      }
                      
                      if ( months[a] == 0 & From[a]$mon > To[a]$mon ) 
                      {
                        if ( From[a]$mday >= To[a]$mday  )
                        {
                          To[a]$mon - From[a]$mon  -> tmp ;
                        } else 
                        {
                          To[a]$mon - From[a]$mon + 1 -> tmp ;
                        }
                      }
                      
                    } else
                    {
                      months[a] -> tmp ;
                    }
                    
                    return( tmp)
                  },
                  months = months ) ) ->
    months ;
  
  return(months)
} 

# 1.1.6 Compute spent time in years between two dates
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

SpentTime.InYears <- function( From , To )
{
  if( !any(class( From ) == "POSIXlt" ) ) 
  { stop( "From is not of POSIXlt type" ) } 
  if( !any( class( To )[1] == "POSIXlt" ) ) 
  { stop( "To is not of POSIXlt type" ) } 
  
  To$year - From$year -> years ;
  
  unlist( lapply( 1:length( From ),
                  FUN = function(a, years){
                    if ( !is.na( From[a] ) & !is.na( To[a] ) )
                    {
                      if ( years[a] >= 0 )
                      {
                        if ( To[a]$mon < From[a]$mon )
                        {
                          years[a] - 1 -> tmp ;
                        } else 
                        {
                          if ( To[a]$mon == From[a]$mon & To[a]$mday < From[a]$mday )
                          {
                            years[a] - 1 -> tmp ;
                          } else
                          {
                            years[a] -> tmp ;
                          }
                        }
                      }
                      
                      if ( years[a] < 0 )
                      {
                        if ( To[a]$mon > From[a]$mon )
                        {
                          years[a] + 1 -> tmp ;
                        } else 
                        {
                          if ( To[a]$mon == From[a]$mon & To[a]$mday > From[a]$mday )
                          {
                            years[a] + 1 -> tmp ;
                          } else
                          {
                            years[a] -> tmp ;
                          }
                        }
                      }
                      
                    } else
                    {
                      years[a] -> tmp ;
                    }
                    
                    return(tmp)
                  },
                  years = years ) ) ->
    years ;
  
  return(years)
} ;

# 1.1.7 Convert date format to character
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

UnDate <- function( ListOfDataFrames ) 
{
  if ( class( ListOfDataFrames )[1] == "data.frame" ) 
  {
    list( ListOfDataFrames ) -> ListOfDataFrames ;  
    DataFrame <- TRUE ;
  } else { DataFrame <- FALSE } ;
  
  if ( !is.list( ListOfDataFrames ) )
  {
    if ( is.vector( ListOfDataFrames ) ) 
    {
      list( data.frame( ListOfDataFrames, stringsAsFactors = FALSE ) ) -> ListOfDataFrames ; 
      Vector <- TRUE ;
    } 
  } else { Vector <- FALSE } ;
  
  for ( a in 1:length( ListOfDataFrames ) )
  {
    for( b in 1: length( ListOfDataFrames[[a]][1,] ) )
    {
      if (  any( class( ListOfDataFrames[[a]][,b] ) == "POSIXlt" ) |
            any( class( ListOfDataFrames[[a]][,b] ) == "POSIXt" ) |
            any( class( ListOfDataFrames[[a]][,b] ) == "POSIXct" ) | 
            any( class( ListOfDataFrames[[a]][,b] ) == "Date" ) )
      {
        as.character( ListOfDataFrames[[a]][,b] ) -> ListOfDataFrames[[a]][,b] ;
        paste( colnames( ListOfDataFrames[[a]] )[b], "have been transformed in character type.") -> tmp.print ;
        print( tmp.print ) ;
      } ;
    } ;
  } ;
  
  if ( DataFrame ) { ListOfDataFrames[[1]] -> ListOfDataFrames ; } ;
  if ( Vector ) { ListOfDataFrames[[1]][,1] -> ListOfDataFrames ; } ;
  return( ListOfDataFrames)
} ;

# 1.1.8 Delete special character
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

UnSpecialCharacters.French <- function(VectorOfText) 
{
  for (a in 1:length(VectorOfText))
  {
    VectorOfText[a] <- gsub("é", "e", VectorOfText[a])
    VectorOfText[a] <- gsub("è", "e", VectorOfText[a])
    VectorOfText[a] <- gsub("ê", "e", VectorOfText[a])
    VectorOfText[a] <- gsub("à", "a", VectorOfText[a])
    VectorOfText[a] <- gsub("î", "i", VectorOfText[a])
    VectorOfText[a] <- gsub("â", "a", VectorOfText[a])
    VectorOfText[a] <- gsub("ô", "o", VectorOfText[a])
    VectorOfText[a] <- gsub("ç", "c", VectorOfText[a])
    VectorOfText[a] <- gsub("ï", "i", VectorOfText[a])
  } ;
  
  for (a in 1:length(VectorOfText))
  {
    VectorOfText[a] <- gsub("['`^~\"]", " ", VectorOfText[a])
    VectorOfText[a] <- iconv(VectorOfText[a], from = "latin1", to="ASCII//TRANSLIT//IGNORE")
    VectorOfText[a] <- gsub("['`^~\"]", "", VectorOfText[a])
  } ;
  return(VectorOfText)
}

# 1.1.9 Function to perform standarzisation 
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Standardization <- function( data )
{
  # Domestic functions
  download.packages <- function( PackagesNames, ... )
  {
    # Get a vector with packages names 
    packages1 <- c( PackagesNames, ... ) ;
    
    # Install packages
    for (a in 1:length( packages1 ) )
    {
      try( find.package( packages1[a]), silent = TRUE ) -> test ;
      
      if ( class( test ) == "try-error" )
      { print( packages1[a] ) ; 
        install.packages(  packages1[a] ) ;
      } 
    }
  } ;
  
  # activate packages
  download.packages( "dplyr", "magrittr" ) ;
  
  # Job
  if ( any( unlist( lapply( data, is.numeric ) ) ) )
  {
    data |>
      dplyr::select_if( is.numeric ) |>
      scale() |>
      (function(x) magrittr::set_colnames( x,
                    value = paste0( colnames(x),
                                    "_",
                                    "Stdz"
                    ) ) )() |>
      (function(x) data.frame( data, x ) )() ->
      data ;
  } else
  {
    print( "No columns to standardize" ) ;
  }

  return( data )
};

# 1.1.10 Function to generate interactions terms 
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Interactions.Generator <- function( terms, no_interactions_terms = "" )
{
  # check inputs 
  if ( !is.character(terms) ) { stop( "terms is not a string.") }
  if ( !is.character(no_interactions_terms) ) { stop( "no_interactions_terms is not a string.") }

  # make interactions 
  NULL -> output ;
  for (a in 1:length(terms) )
  {
    c( output, terms[a] ) ->
      output ;
    
    for (b in (a + 1):length(terms) )
    {
      if ( a != b & b <=  length(terms) )
      {
        c( output, 
           paste0( terms[a], ":", terms[b] ) 
        ) ->
          output ;
      }
    }
  }
  
  # add no interactions temrs 
  if ( no_interactions_terms != "" ) 
  {
    c( output, no_interactions_terms ) -> 
    output ;
  }
  
  return( output )
}

# 1.1.11 Function to generate formula
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Formula.Generator <- function( outcome, terms )
{
  # check inputs 
  if ( !is.character(outcome) ) { stop( "outcome is not a string.") }
  if ( !is.character(terms) ) { stop( "terms is not a string.") }
  
  # makre formula 
  paste0( terms[1:(length(terms) - 1)], " + ") -> tmp1 ;
  
  "" -> tmp2 ;
  for (a in 1:length(tmp1))
  {
    paste0( tmp2, tmp1[a]) ->
      tmp2 ;
  }
  
  paste0( outcome,
          " ~ ",
          tmp2,
          terms[length(terms)]
          ) ->
    output ;
  
 return( as.formula(output) ) 
}

# 1.2 Preliminary Analysis and Graphs functions   -----------------------------
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 1.2.1 Function to check data input quality
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

DataQuality.Analysis <- function( data )
{
  # Adaptation for applying function on vectors
  if ( class( data ) != "data.frame" ) 
  {
    tmp.name1 <- deparse( substitute( data ) ) ;
    data <- data.frame( data, stringsAsFactors = FALSE ) ;
    colnames( data ) <- tmp.name1 ;
  } ;
  
  # domestic functions
  #~~~~~~~~~~~~~~~~~~~
  StringContatener <- function( vector, separator )
  {   
    # exclude NA
    na.omit( vector ) -> vector ;
    
    # selection of length for loop
    if ( length( vector ) >= 2) 
    { 
      # stock fisrt element
      tmp.val1 <- vector[1] ;
      
      # loop to concatenate the nect elements
      for ( a in 2:length( vector ) ) 
      { 
        tmp.val1 <- paste( tmp.val1, vector[a], sep = separator ) ; 
      } ;
    } 
    else
    {
      tmp.val1 <- vector ;
    } ;
    
    return( tmp.val1 ) ;
  } ;
  
  #job
  #===
  # create stocker
  NULL -> tmp.result ;
  
  # loop for all columns in data.frame
  for (a in 1:dim( data )[2] )
  {
    # pre testing
    class( data[,a] ) -> tmp1 ;
    StringContatener( tmp1, " // " ) -> tmp.val1 ;
    
    if ( any( is.na( as.numeric( na.omit( as.character( data[,a] ) ) ) ) ) )
    { tmp.val2 <- TRUE } else { tmp.val2 <- FALSE } ;
    
    if ( all( summary( as.factor( as.character( data[,a] ) ), maxsum = length( data[,a] ) ) < 2 ) )
    { tmp.val3 <- FALSE } else { tmp.val3 <- TRUE } ;
    
    if ( tmp.val2 == FALSE )
    {
      head( sort( as.numeric( as.character( data[,a] ) ), 
                  decreasing = FALSE, na.last = TRUE ), 10 ) -> tmp2 ;
      StringContatener( tmp2, " // " ) -> tmp.val4 ;
      
      tail( sort( as.numeric( as.character( data[,a] ) ), 
                  decreasing = FALSE, na.last = FALSE ), 10 ) -> tmp3 ;
      StringContatener( tmp3, " // " ) -> tmp.val5 ;
    }
    else
    {
      head( sort( as.character( data[,a] ), 
                  decreasing = FALSE, na.last = TRUE ), 10 ) -> tmp2 ;
      StringContatener( tmp2, " // " ) -> tmp.val4 ;
      
      tail( sort( as.character( data[,a] ), 
                  decreasing = FALSE, na.last = FALSE ), 10 ) -> tmp3 ;
      StringContatener( tmp3, " // " ) -> tmp.val5 ;
    } ;
    
    tmp.val6 <- nlevels( factor( data[,a] ) ) ;    
    
    tmp.val7 <- StringContatener( names( head( sort( table( factor( data[,a] ) ), decreasing = TRUE ), 10 ) ), " // " )
    
    # row
    tmp.row1 <- c( colnames( data )[a],
                   tmp.val1,
                   tmp.val2,
                   tmp.val3,
                   tmp.val6,
                   length( as.character( data[,a] ) ),
                   sum( is.na( data[,a] ) ),
                   round( sum( is.na( data[,a] ) ) / length( as.character( data[,a] ) ) * 100, digits = 2 ),
                   tmp.val4,
                   tmp.val5,
                   tmp.val7
    ) ;
    rbind( tmp.result, tmp.row1 ) -> tmp.result ;
  } ;
  
  # Change class
  tmp.result <- as.data.frame( matrix( tmp.result, ncol = length( tmp.row1 ) ) ) ;
  
  # Rename colomns and rows
  colnames( tmp.result ) <- c( "Var", "Class", "Strings in variable ?", "Repeated modality ?", "Number of modality",
                               "N total", 
                               "N missing", "% missing", "First increasing Values",
                               "Last increasing Values", "Teen more frequent Values" ) ;
  rownames( tmp.result ) <- NULL ;
  
  return( tmp.result ) ;
} ;

# 1.2.2 Function to check data input quality graphically
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

DataView <- function( x, 
                      col.per.view = 10, 
                      n.subset = 15, 
                      Plot = FALSE,
                      ExportFile = getwd(), 
                      width = 1000, 
                      height = 1000,
                      fontsize = 10, 
                      iteration = FALSE,
                      n.iteration = 4,
                      ncores = NULL ) 
{
  # Input condition
  if ( !is.data.frame( x ) ) { stop( "x is not a data.frame" );   } ;
  if ( !is.numeric( col.per.view ) ) { stop( "col.per.view is not numeric" );    } ;
  if ( !is.numeric( n.subset ) ) { stop( "n.subset is not numeric" );    } ;
  if ( !is.logical( Plot ) ) { stop( "Plot is not TRUE or FALSE" );    } ;
  if ( !is.character( ExportFile ) ) { stop( "ExportFile is not a string" );   } ;
  if ( !is.numeric( width ) ) { stop( "width is not numeric" );    } ;
  if ( !is.numeric( height ) ) { stop( "height is not numeric" );    } ;
  if ( !is.numeric( fontsize ) ) { stop( "fontsize is not numeric" );    } ;
  if ( !is.logical( iteration ) ) { stop( "iteration is not TRUE or FALSE" );    } ;
  if ( !is.numeric( n.iteration ) ) { stop( "n.iteration is not numeric" );    } ;
  if ( !is.null(ncores) & !is.numeric(ncores) ) { stop( "ncores is not null nor numeric" ) }
  
  # Domestic functions
  download.packages <- function( PackagesNames, ... )
  {
    # Get a vector with packages names 
    packages1 <- c( PackagesNames, ... ) ;
    
    # Install packages
    for (a in 1:length( packages1 ) )
    {
      try( find.package( packages1[a]), silent = TRUE ) -> test ;
      
      if ( class( test ) == "try-error" )
      { print( packages1[a] ) ; 
        install.packages(  packages1[a] ) ;
      } 
    }
  } ;
  
  # activate packages
  download.packages( "dplyr", "tidyr", "grid", "gridExtra", "furrr" ) ;
  
  # parallel
  if ( !is.null( ncores ) ) { future::plan( "multisession",  workers = ncores ) }
    
  # job
  
  # cut tables in less than 50 columns
  if ( ncol( x ) > col.per.view )
  {
    ceiling( ncol( x ) / col.per.view ) -> nblocks 
    
    NULL -> list.of.df ;
    for ( a in 0:(nblocks - 2) )
    {
      x[, (1 + a * col.per.view):(1 + a * col.per.view + col.per.view - 1) ] |>
        list() |>
        ( function(x) c( list.of.df,
                          x ) )() ->
        list.of.df ;
    }
    x[, (1 + (nblocks - 1) * col.per.view):ncol(x) ] |>
      list() |>
      ( function(x) c( list.of.df,
                       x ) )() ->
      list.of.df ;
    
    
    # loop for graphing
    furrr::future_map( 1:length( list.of.df ), 
                function(a)
                {
                  list.of.df[[a]] -> df ;
                  
                  #  No iteration 
                  if ( !iteration )
                  {
                    if ( Plot )
                    {
                      df |>
                        dplyr::sample_n(  size = n.subset, replace = FALSE ) |> 
                        gridExtra::tableGrob( theme = gridExtra::ttheme_default( base_size = fontsize ) )  -> 
                        g1
                      
                      paste( ExportFile, "/DataView_part", a, ".png", sep = "" ) -> 
                        name ;
                      
                      png( filename = name, 
                           width = width, height = height ) ;
                      grid::grid.newpage() ; 
                      grid::grid.draw( g1 ) ;
                      dev.off() ;
                    }
                    
                    if ( !Plot )
                    {
                      df |>
                        dplyr::sample_n( size = n.subset, replace = FALSE ) |> 
                        View( as.character(a))
                    }
                  }
                  
                  #  Iteration 
                  if ( iteration )
                  {
                    lapply( 1:n.iteration,
                            function( b )
                            {
                              if ( Plot )
                              {
                                df |>
                                  dplyr::sample_n(  size = n.subset, replace = FALSE ) |> 
                                  gridExtra::tableGrob( theme = gridExtra::ttheme_default( base_size = fontsize ) )  -> 
                                  g1
                                
                                paste( ExportFile, "/DataView_part", a, "_iteration", b, ".png", sep = "" ) -> 
                                  name ;
                                
                                png( filename = name, 
                                     width = width, height = height ) ;
                                grid::grid.newpage() ; 
                                grid::grid.draw( g1 ) ;
                                dev.off() ; 
                              }
                              
                              if ( !Plot )
                              {
                                df |>
                                  dplyr::sample_n( size = n.subset, replace = FALSE ) |>
                                  View( paste(a,b) )
                              }
                            }
                    )
                    
                  }
                },
                .options = furrr::furrr_options(seed = TRUE)
    )
    
  } 
  
  if ( ncol( x ) <= col.per.view )
  {
    x -> df ;
    
    #  No iteration 
    if ( !iteration )
    {
      if ( Plot )
      {
        df |>
          dplyr::sample_n( size = n.subset, replace = FALSE ) |>
          gridExtra::tableGrob( theme = gridExtra::ttheme_default( base_size = fontsize ) )  -> 
          g1
        
        paste( ExportFile, "/DataView.png", sep = "" )  -> 
          name ;
        
        png( filename = name, 
             width = width, height = height ) ;
        grid::grid.newpage() ; 
        grid::grid.draw( g1 ) ;
        dev.off() ;
      }
      
      if ( !Plot )
      {
        df |>
          dplyr::sample_n( size = n.subset, replace = FALSE ) |>
          View( as.character(a))
      }
    }
    
    #  Iteration 
    if ( iteration )
    {
      lapply( 1:n.iteration,
              function(b)
              {
                if ( Plot )
                {
                  df |>
                    dplyr::sample_n( size = n.subset, replace = FALSE ) |> 
                    gridExtra::tableGrob( theme = gridExtra::ttheme_default( base_size = fontsize ) )  -> 
                    g1
                  
                  paste( ExportFile, "/DataView_", b, ".png", sep = "" ) -> 
                    name ;
                  
                  png( filename = name, 
                       width = width, height = height ) ;
                  grid::grid.newpage() ; 
                  grid::grid.draw( g1 ) ;
                  dev.off() ;
                }
                
                if ( !Plot )
                {
                  df |>
                    dplyr::sample_n( size = n.subset, replace = FALSE ) |>
                    View( paste(a,b))
                }
              }
      )
    }
  }
  
  # end parallel
  future::plan("sequential")
}

# 1.2.3 Function to check NA graphically
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Missingdata.Plot <- function( x, 
                              ExportFile, 
                              subset = FALSE, 
                              n = 200, 
                              iteration = FALSE,
                              n.iteration = 3 ) 
{
  # Input condition
  if ( !is.data.frame( x ) ) { stop( "x is not a data.frame" );   } ;
  if ( !is.character( ExportFile ) ) { stop( "ExportFile is not a string" );   } ;
  if ( !is.logical( subset ) ) { stop( "subset is not TRUE or FALSE" );    } ;
  if ( !is.numeric( n ) ) { stop( "n is not numeric" );    } ;
  if ( !is.logical( iteration ) ) { stop( "iteration is not TRUE or FALSE" );    } ;
  if ( !is.numeric( n.iteration ) ) { stop( "n.iteration is not numeric" );    } ;
  
  # Domestic functions
  download.packages <- function( PackagesNames, ... )
  {
    # Get a vector with packages names 
    packages1 <- c( PackagesNames, ... ) ;
    
    # Install packages
    for (a in 1:length( packages1 ) )
    {
      try( find.package( packages1[a]), silent = TRUE ) -> test ;
      
      if ( class( test ) == "try-error" )
      { print( packages1[a] ) ; 
        install.packages(  packages1[a] ) ;
      } 
    }
  } ;
  
  
  # activate packages
  download.packages( "ggplot2", "dplyr", "tidyr" ) ;
  
  require(ggplot2)
  
  # job
  
  # cut tables in less than 50 columns
  if ( ncol( x ) > 50 )
  {
    ceiling( ncol( x ) / 50 ) -> nblocks 
    
    NULL -> list.of.df ;
    for ( a in 0:(nblocks - 2) )
    {
      x[, (1 + a * 50):(1 + a * 50 + 49) ] |>
        list( ) |>
        (function(x) c( list.of.df,
           x ) )() ->
        list.of.df ;
    }
    x[, (1 + (nblocks - 1) * 50):ncol(x) ] |>
      list( ) |>
      (function(x) c( list.of.df,
                      x ) )() ->
      list.of.df ;
    
    
    # loop for graphing
    for ( a in 1:length( list.of.df ) )
    {
      list.of.df[[a]] -> df ;
      
      #  No iteration 
      if ( !iteration )
      {
        if ( !subset )
        {
          df |>
            is.na.data.frame() |>
            as.data.frame() |>
            (function(x) dplyr::mutate( x, row = 1:dim(x)[1] ) )() |>
            tidyr::gather( key = column,  Missing, -row ) |>
            dplyr::mutate( column = ordered( column, colnames(df) ) ) |>
            ggplot( ) +
            geom_tile( aes( x = column, y = row, fill = Missing ) ) +
            scale_y_reverse( breaks = rep( 1:dim(df)[1], 1 ), 
                             labels = rownames(df) ) +
            theme( axis.text.x = element_text( size = 8, angle = 90 ),
                   axis.text.y = element_text( size = 8 ) ) +
            labs( title = "Missing data matrix" )   -> 
            graph ;
          
          ggsave( paste( ExportFile, 
                         "/MissingDataMatrix", 
                         "_part",
                         a, 
                         ".png", 
                         sep = "" ),
                  graph ) ;
        } else 
        {
          df |>
            dplyr::sample_n( size = n, replace = FALSE ) -> 
            df ;
          
          df |>
            is.na.data.frame() |>
            as.data.frame() |>
            (function(x) dplyr::mutate( x, row = 1:dim(x)[1] ) )() |>
            tidyr::gather( key = column,  Missing, -row ) |>
            dplyr::mutate( column = ordered( column, colnames(df) ) ) |>
            ggplot( ) +
            geom_tile( aes( x = column, y = row, fill = Missing ) ) +
            scale_y_reverse( breaks = rep( 1:dim(df)[1], 1 ), 
                             labels = rownames(df) ) +
            theme( axis.text.x = element_text( size = 8, angle = 90 ),
                   axis.text.y = element_text( size = 8 ) ) +
            labs( title = "Missing data matrix", 
                  subtitle = paste( "Subset of", n, "lines" ) ) -> 
            graph ;
          
          ggsave( paste( ExportFile, 
                         "/MissingDataMatrix", 
                         "_part",
                         a, 
                         ".png", 
                         sep = "" ),
                  graph ) ;
        }
      }
      
      #  Iteration 
      if ( iteration )
      {
        if ( !subset )
        {
          df |>
            is.na.data.frame() |>
            as.data.frame() |>
            (function(x) dplyr::mutate( x, row = 1:dim(x)[1] ) )() |>
            tidyr::gather( key = column,  Missing, -row ) |>
            dplyr::mutate( column = ordered( column, colnames(df) ) ) |>
            ggplot(  ) +
            geom_tile( aes( x = column, y = row, fill = Missing ) ) +
            scale_y_reverse( breaks = rep( 1:dim(df)[1], 1 ), 
                             labels = rownames(df) ) +
            theme( axis.text.x = element_text( size = 8, angle = 90 ),
                   axis.text.y = element_text( size = 8 ) ) +
            labs( title = "Missing data matrix" )  -> 
            graph ;
          
          ggsave( paste( ExportFile, 
                         "/MissingDataMatrix", 
                         "_part",
                         a, 
                         ".png", 
                         sep = "" ),
                  graph ) ;
        } else 
        {
          for ( b in 1:n.iteration )
          {
            df |>
              dplyr::sample_n( size = n, replace = FALSE ) -> 
              df ;
            
            df |>
              is.na.data.frame() |>
              as.data.frame() |>
              (function(x) dplyr::mutate( x, row = 1:dim(x)[1] ) )() |>
              tidyr::gather( key = column,  Missing, -row ) |>
              dplyr::mutate( column = ordered( column, colnames(df) ) ) |>
              ggplot( ) +
              geom_tile( aes( x = column, y = row, fill = Missing ) ) +
              scale_y_reverse( breaks = rep( 1:dim(df)[1], 1 ), 
                               labels = rownames(df) ) +
              theme( axis.text.x = element_text( size = 8, angle = 90 ),
                     axis.text.y = element_text( size = 8 ) ) +
              labs( title = "Missing data matrix", 
                    subtitle = paste( "Subset of", n, "lines" ) ) ->
              graph ;
            
            ggsave( paste( ExportFile, 
                           "/MissingDataMatrix", 
                           "_part",
                           a,
                           "_subset",
                           b, 
                           ".png", 
                           sep = "" ),
                    graph ) ; 
          }
        }
      }
    }
  } 
  
  if ( ncol( x ) <= 50 )
  {
    x -> df ;
    
    #  No iteration 
    if ( !iteration )
    {
      if ( !subset )
      {
        df |>
          is.na.data.frame() |>
          as.data.frame() |> 
          (function(x) dplyr::mutate( x, row = 1:dim(x)[1] ) )() |>
          tidyr::gather( key = column,  Missing, -row ) |>
          dplyr::mutate( column = ordered( column, colnames(df) ) ) |>
          ggplot( ) +
          geom_tile( aes( x = column, y = row, fill = Missing ) ) +
          scale_y_reverse( breaks = rep( 1:dim(df)[1], 1 ), 
                           labels = rownames(df) ) +
          theme( axis.text.x = element_text( size = 8, angle = 90 ),
                 axis.text.y = element_text( size = 8 ) ) +
          labs( title = "Missing data matrix" )   -> 
          graph ;
        
        ggsave( paste( ExportFile, "/MissingDataMatrix.png", sep = "" ) )
      } else 
      {
        df |>
          dplyr::sample_n( size = n, replace = FALSE ) -> 
          df ;
        
        df |>
          is.na.data.frame() |>
          as.data.frame() |>
          (function(x) dplyr::mutate( x, row = 1:dim(x)[1] ) )() |>
          tidyr::gather( key = column,  Missing, -row ) |>
          dplyr::mutate( column = ordered( column, colnames(df) ) ) |>
          ggplot( ) +
          geom_tile( aes( x = column, y = row, fill = Missing ) ) +
          scale_y_reverse( breaks = rep( 1:dim(df)[1], 1 ), 
                           labels = rownames(df) ) +
          theme( axis.text.x = element_text( size = 8, angle = 90 ),
                 axis.text.y = element_text( size = 8 ) ) +
          labs( title = "Missing data matrix", 
                subtitle = paste( "Subset of", n, "lines" ) ) -> 
          graph ;
        
        ggsave( paste( ExportFile, "/MissingDataMatrix.png", sep = "" ) )
      }
    }
    
    #  Iteration 
    if ( iteration )
    {
      if ( !subset )
      {
        df |>
          is.na.data.frame() |>
          as.data.frame() |>
          (function(x) dplyr::mutate( x, row = 1:dim(x)[1] ) )() |>
          tidyr::gather( key = column,  Missing, -row ) |>
          dplyr::mutate( column = ordered( column, colnames(df) ) ) |>
          ggplot(  ) +
          geom_tile( aes( x = column, y = row, fill = Missing ) ) +
          scale_y_reverse( breaks = rep( 1:dim(df)[1], 1 ), 
                           labels = rownames(df) ) +
          theme( axis.text.x = element_text( size = 8, angle = 90 ),
                 axis.text.y = element_text( size = 8 ) ) +
          labs( title = "Missing data matrix" )  -> 
          graph ;
        
        ggsave( paste( ExportFile, "/MissingDataMatrix.png", sep = "" ) )
      } else 
      {
        for ( b in 1:n.iteration )
        {
          df |>
            dplyr::sample_n( size = n, replace = FALSE ) -> 
            df ;
          
          df |>
            is.na.data.frame() |>
            as.data.frame() |>
            (function(x) dplyr::mutate( x, row = 1:dim(x)[1] ) )() |>
            tidyr::gather( key = column,  Missing, -row ) |>
            dplyr::mutate( column = ordered( column, colnames(df) ) ) |>
            ggplot(  ) +
            geom_tile( aes( x = column, y = row, fill = Missing ) ) +
            scale_y_reverse( breaks = rep( 1:dim(df)[1], 1 ), 
                             labels = rownames(df) ) +
            theme( axis.text.x = element_text( size = 8, angle = 90 ),
                   axis.text.y = element_text( size = 8 ) ) +
            labs( title = "Missing data matrix", 
                  subtitle = paste( "Subset of", n, "lines" ) ) ->
            graph ;
          
          ggsave( paste( ExportFile, 
                         "/MissingDataMatrix", 
                         b, 
                         ".png", 
                         sep = "" ) ) ; 
        }
      }
    }
  }
}

# 1.2.4 Function to analyze NA
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Missingdata.Analysis <- function( x,
                                  Little.test = FALSE,
                                  nsim = 10000,
                                  ncores = NULL )
{
  # Input condition
  if ( !is.data.frame( x ) ) { stop( "x is not a data.frame" );   } ;
  if ( !is.double( nsim ) ) { stop( "nsim is not double" );    } ;
  if ( !is.null(ncores) & !is.numeric(ncores) ) { stop( "ncores is not null nor numeric" ) }
  
  # parallel
  if ( !is.null( ncores ) ) { future::plan( "multisession",  workers = ncores ) }
  
  # Domestic functions
  download.packages <- function( PackagesNames, ... )
  {
    # Get a vector with packages names 
    packages1 <- c( PackagesNames, ... ) ;
    
    # Install packages
    for (a in 1:length( packages1 ) )
    {
      try( find.package( packages1[a]), silent = TRUE ) -> test ;
      
      if ( class( test ) == "try-error" )
      { print( packages1[a] ) ; 
        install.packages(  packages1[a] ) ;
      } 
    }
  } ;
  
  p.round <- function( data, digits = 3 )
  {
    if (digits == 1)
    { "" -> tmp1 ; } else 
    { rep( "0", digits - 1 ) -> tmp1 ; }
    
    "0." -> tmp2 ;
    for( a in 1:length(tmp1) )
    {
      paste( tmp2, tmp1[a], sep = "" ) -> tmp2 ;
    }
    
    paste( tmp2, "1", sep = "" ) -> pval ;
    
    for ( a in 1:length(data) )
    {
      if ( !is.na( data[a] ) )
      {
        if ( data[a] >= as.numeric( pval ) )
        {
          round( data[a], digits = digits ) -> data[a] ;
        }
      }
    }
    
    data[ data < as.numeric( pval ) ] <- paste( "< ", pval, sep = "" ) ;
    
    return( data ) ;
  }
  
  rbind.force <- function( data, ..., keep.col = FALSE, empty = NA )
  {
    # Unify data
    list( data, ... ) -> input ;
    
    # include list elements
    repeat
    {
      if (  !any( unlist( lapply( input, class ) ) == "list" ) ) { break }
      
      which( unlist( lapply( input, class ) ) == "list" )[1] -> a ;
      input[[a]] -> tmp ;
      input[[a]] <- NA ;
      c( input[1:a],  tmp, input[ (a + 1):length( input ) ] ) ->
        input ;
    }
    
    input[ !is.na( input ) ] ->
      input ;
    
    # delete NULL data and transformt vector in data.frame
    for ( a in 1:length( input ) )
    {
      if ( is.null( dim( input[[a]] ) ) )
      {
        if ( is.null( input[[a]] ) )
        {
          input[[a]] <- NA ;
        } else
        {
          data.frame( matrix( input[[a]], nrow = 1 ),
                      stringsAsFactors = FALSE ) -> input[[a]] ;
        }
      }
      
      if ( all( dim( input[[a]] ) == 0 ) )
      {
        input[[a]] <- NA ;
      }
    }
    
    input[ !is.na( input ) ] ->
      input ;
    
    # test data class
    if ( !all( unlist( lapply( input, is.data.frame ) ) |
               unlist( lapply( input, is.matrix ) ) |
               unlist( lapply( input, is.vector ) ) ) )
    { stop( "Some argument are not data.frame, neither vector" ) ;
      ; } ;
    
    # Set primer
    input[[1]] -> output ;
    
    # job in case we keep columns
    if ( keep.col & length( input ) >1 )
    {
      for ( a in 2:length( input ) )
      {
        output -> x ;
        input[[a]] -> y ;
        
        for (a in 1:dim(x)[2]) { x[,a] <- as.character(x[,a])}
        for (a in 1:dim(y)[2]) { y[,a] <- as.character(y[,a])}
        
        x.diff <- setdiff(colnames(x), colnames(y))
        y.diff <- setdiff(colnames(y), colnames(x))
        
        if( dim(x)[1] > 0 ) { x[, c(as.character(y.diff))] <- empty ; }
        if( dim(y)[1] > 0 ) { y[, c(as.character(x.diff))] <- empty ; }
        
        rbind(x, y) -> output ;
      }
    }
    
    # job in case we do not keep columns
    if ( !keep.col & length( input ) >1 )
    {
      for ( a in 2:length( input ) )
      {
        output -> x ;
        input[[a]] -> y ;
        
        colnames(x) <- paste( "X",
                              1:dim( x )[2],
                              sep = "" ) ;
        colnames(y) <- paste( "X",
                              1:dim( y )[2],
                              sep = "" ) ;
        
        for (a in 1:dim(x)[2]) { x[,a] <- as.character(x[,a])}
        for (a in 1:dim(y)[2]) { y[,a] <- as.character(y[,a])}
        
        x.diff <- setdiff(colnames(x), colnames(y))
        y.diff <- setdiff(colnames(y), colnames(x))
        
        if( dim(x)[1] > 0 ) { x[, c(as.character(y.diff))] <- empty ; }
        if( dim(y)[1] > 0 ) { y[, c(as.character(x.diff))] <- empty ; }
        
        rbind(x, y) -> output ;
      }
    }
    
    return( output ) ;
  }
  
  # Little test
  mcar_test <- function(data)
  {
    
    # test data
    if ( ! is.data.frame(data)) (stop("data is not data.frame"))
    
    # norm::prelim.norm needs to work with a data.matrix
    data <- data.matrix(data)
    
    # Number of variables in data
    n_var <- ncol(data)
    
    # Number of rows
    n <- nrow(data)
    var_names <- colnames(data)
    
    # Calculate pattern of missingness for each row
    r <- 1 * is.na(data)
    mdp <- (r %*% (2^((1:n_var - 1)))) + 1
    
    # Add pattern as column to original data
    x_miss_pattern <- data.frame(cbind(data, mdp))
    colnames(x_miss_pattern) <- c(var_names, "miss_pattern")
    
    # Number of unique missing data patterns
    n_miss_pattern <- length(unique(x_miss_pattern$miss_pattern))
    
    # Recode miss_pattern variable to go from 1 through n_miss_pattern
    x_miss_pattern |>
      dplyr::mutate(miss_pattern = dplyr::dense_rank(.data$miss_pattern)) ->
      x_miss_pattern ;
    
    # Maximum likelihood estimation from {norm}
    # Adapted from Eric Stemmler
    # https://stats-bayes.com/post/2020/08/14/r-function-for-little-s-test-for-data-missing-completely-at-random/
    s <- norm::prelim.norm(data)
    ll <- norm::em.norm(s, showits = FALSE)
    fit <- norm::getparam.norm(s = s, theta = ll)
    grand_mean <- fit$mu
    grand_cov <- fit$sigma
    colnames(grand_cov) <- rownames(grand_cov) <- colnames(data)
    
    x_miss_pattern |>
      # For each of the types of missing patterns...
      dplyr::group_by(.data$miss_pattern) |>
      tidyr::nest() |>
      # kj terms for degrees of freedom
      dplyr::mutate(
        kj = purrr::map_dbl(.data$data,
                            ~colSums(as.matrix(1 * !is.na(colSums(.x)))))
      ) |>
      # Calculate column averages
      dplyr::mutate(
        mu = purrr::map(.data$data, ~colMeans(.x) - grand_mean),
        mu = purrr::map(.data$mu, ~.x[!is.na(.x)])
      ) |>
      # Binary 0/1 indicating if column should be kept
      dplyr::mutate(
        keep = purrr::map(.data$data, ~1 * !is.na(colSums(.x))),
        keep = purrr::map(.data$keep, ~.x[which(.x[1:n_var] != 0)])
      ) |>
      # Drop rows and columns from global covariance matrix so that the matrix
      # only contains rows and columns that exist in current missing pattern
      dplyr::mutate(
        sigma = purrr::map(.data$keep,
                           ~grand_cov[which(rownames(grand_cov) %in% names(.x)),
                                      which(colnames(grand_cov) %in% names(.x))])
      ) |>
      # Finally calculate Little's statistic using the number of rows in missing
      # pattern, average, and covariance
      dplyr::mutate(
        d2 = purrr::pmap_dbl(
          list(.data$data, .data$mu, .data$sigma, .data$kj),
          ~ifelse(..4 == 0,
                  0,  # If the pattern is all NA, use 0
                  nrow(..1) * (t(..2) %*% solve(..3) %*% ..2))
        )) |>
      dplyr::ungroup() ->
      little_calculations
    
    # Main calculations
    d2 <- sum(little_calculations$d2)  # Little's d2
    df <- sum(little_calculations$kj) - n_var  # Degrees of freedom
    p_value <- 1 - stats::pchisq(d2, df)  # p-value
    
    # Return everything as a glance-like tibble
    tibble::tibble(statistic = d2, df = df, p.value = p_value,
                   missing.patterns = n_miss_pattern)
  }
  
  # activate packages
  download.packages( "dplyr", "norm", "tibble" ) ;
  
  # job
  #====
  
  # NA analysis on columns
  is.na.data.frame( x ) |>
    apply(
      MARGIN = 2,
      FUN = function(x){ ifelse( sum(x) > 0, 1, 0 )} ) |>
    factor() ->
    col.1isNA ;
  
  is.na.data.frame( x ) |>
    apply( MARGIN = 2, FUN = sum ) ->
    col.nbNA ;
  
  ( col.nbNA / dim( x )[1] * 100 ) |>
    round( 
      digits = 1 ) ->
    col.percentNA ;
  
  data.frame( names = colnames(x),
              Nb = col.nbNA,
              Percent = col.percentNA
  ) |>
    dplyr::arrange( desc( Nb ) ) |>
    t() ->
    col.NA
  
  rbind.force( c( "Global", "columns names:", col.NA[ 1, ] ),
               c( "Global", "number of NA in columns:", col.NA[ 2, ]  ),
               c( "Global", "% of NA in columns:", col.NA[ 3, ]  ),
               empty = "" ) ->
    output ;
  
  # NA analysis on lines
  is.na.data.frame( x ) |>
    apply( 
      MARGIN = 1,
      FUN = function(x){ ifelse( sum(x) > 0, "NA present", "NA absent" )} ) |>
    factor() ->
    line.1isNA ;
  
  is.na.data.frame( x ) |>
    apply( MARGIN = 1, FUN = sum ) ->
    line.nbNA ;
  
  ( line.nbNA / ncol( x ) * 100 ) |>
    round( 
      digits = 1 ) ->
    line.percentNA ;
  
  data.frame( names = rownames(x),
              Nb = line.nbNA,
              Percent = line.percentNA
  ) |>
    dplyr::arrange( desc( Nb ) ) |>
    t() ->
    line.NA
  
  if ( ncol( line.NA ) > 20 ) { line.NA[,1:20] -> line.NA }
  
  rbind.force( output,
               c( " ============= ", " ============= ", " ============= " ),
               c( "Global", "lines names:", line.NA[1,] ),
               c( "Global", "number of NA in lines:", line.NA[2,] ),
               c( "Global", "% of NA in lines:", line.NA[3,] ),
               empty = ""  ) ->
    output ;
  
  # little's test for MCAR
  if (Little.test)
  {
    if ( ncol(dplyr::select_if(x, is.numeric)) < 50 & any( unlist( lapply( x, function(a){ is.numeric(a) | is.factor(a) } ) ) ) )
    {
      x |>
        dplyr::select_if( is.numeric) |>
        mcar_test() ->
        little ;
      
      rbind.force( output,
                   c( " ============= ", " ============= ", " ============= " ),
                   c( "little", "Little's MCAR test", "(Significant difference", "if is not MCAR)" ),
                   c( "little", "Chi-squared statistic", "Degree of freedom", "p-value" ),
                   as.character( c( "little",
                                    round( little[1], 2 ),
                                    little[2],
                                    round( little[3], digits = 3 )  ) ),
                   empty = ""  ) ->
        output ;
    } else
    {
      rbind.force( output,
                   c( " ============= ", " ============= ", " ============= " ),
                   c( "Little's MCAR test", "(Significant difference", "if is not MCAR)" ),
                   c( "Little's MCAR test", "not applicable if more", "than 50 columns", "or if data frame", "countains columns", "with other", "class than", "numeric" ),
                   empty = "" ) ->
        output ;
    }
  }
  
  # test between lines with NA and lines with no NA
  
  furrr::future_map( 1:ncol(x),
                     function(a)
                     {
                       #print(a) ;
                       
                       if ( is.factor(x[,a]) & nlevels(line.1isNA) == 2 )
                       {
                         chisq.test( x[,a], line.1isNA, simulate.p.value = TRUE, B = nsim ) ->
                           tmp.test ;
                         c( colnames(x)[a], p.round( tmp.test$p.value, 3) ) ->
                           tmp.output ; 
                       }
                       
                       if ( is.numeric(x[,a]) & nlevels(line.1isNA) == 2 )
                       {
                         wilcox.test( v1 ~ v2, data = cbind( v1 = x[,a], v2 = line.1isNA ) ) ->
                           tmp.test ;
                         c( colnames(x)[a], p.round( tmp.test$p.value, 3) ) ->
                           tmp.output ; 
                       }
                       
                       if ( !is.factor(x[,a]) & !is.numeric(x[,a]) )
                       {
                         c( colnames(x)[a], "-" )  ->
                           tmp.output ; 
                       }
                       
                       if ( (is.factor(x[,a]) | is.numeric(x[,a]) ) & nlevels(line.1isNA) != 2 )  
                       {
                         c( colnames(x)[a], "-" ) ->
                           tmp.output ; 
                       }
                       
                       return(tmp.output)
                     }, 
                     .options = furrr::furrr_options(seed = TRUE),
                     .progress = T 
  ) -> 
    tmp.output ;
  
  rbind.force( c( "Variable", "p value" ),
               tmp.output ) ->
    tmp.output ;
  
  cbind( "Complete vs Incomplete", tmp.output) ->
    tmp.output ;
  
  as.data.frame( tmp.output ) |>
    (function(x) rbind.force( output,
                              c( " ============= ", " ============= ", " ============= " ),
                              c( "Complete vs Incomplete", "Comparaison of lines with NA and lines without NA", "If significant, variable is not MCAR", "Wilcoxon rank sum test with continuity correction", "Pearson's Chi-squared test with simulated p-value" ),
                              x,
                              empty = ""  ) )() ->
    output ;
  
  # Comparaison between binarized columns in TRUE/FALSE for NA and other columns
  x |>
    is.na.data.frame() |>
    as.data.frame() |>
    lapply( factor ) |>
    dplyr::bind_cols()  |>
    data.frame() ->
    binarizedOnNA.x ;
  
  paste( colnames( binarizedOnNA.x ), "_1isNA", sep = "" ) ->
    colnames( binarizedOnNA.x ) ;
  
  furrr::future_map( 1:ncol(x),
                     function(a)
                     {
                       #print("a") ;
                     #print(a) ;
                       
                       colnames(x)[a] -> tmp.output.b ;
                       
                       for (b in 1:ncol(x) )
                       {
                         #   print("b") ;
                        #   print(b) ;
                         
                         na.omit( data.frame( v1 = x[,a], v2 = binarizedOnNA.x[,b] ) ) ->
                           df.tmp ; 
                         
                         if ( a != b & 
                              is.factor( df.tmp$v1 ) & 
                              nlevels( df.tmp$v1 ) > 1 & 
                              nlevels( df.tmp$v2 ) > 1 & 
                              all( table( df.tmp$v2 ) > 1 ) )
                         {
                           chisq.test( df.tmp$v1, df.tmp$v2, simulate.p.value = TRUE, B = nsim ) ->
                             tmp.test ;
                           c( tmp.output.b,
                              p.round( tmp.test$p.value, 3) ) ->
                             tmp.output.b ; 
                         }
                         
                         if ( a != b  &  
                              is.numeric( df.tmp$v1 ) & 
                              nlevels( df.tmp$v2 ) > 1 & 
                              all( table( df.tmp$v2 ) > 1 ) )
                         {
                           wilcox.test( v1 ~ v2, data = df.tmp ) ->
                             tmp.test ;
                           c( tmp.output.b,
                              p.round( tmp.test$p.value, 3) ) ->
                             tmp.output.b ; 
                         }
                         
                         if ( a == b )
                         {
                           c( tmp.output.b,
                              "-" ) ->
                             tmp.output.b ; 
                         }
                         
                         if (a != b & 
                             !is.factor( df.tmp$v1 ) & 
                             !is.numeric( df.tmp$v1 ) )
                         {
                           c( tmp.output.b,
                              "-" ) ->
                             tmp.output.b ; 
                         }
                         
                         if ( a != b & 
                              is.factor( df.tmp$v1 ) & 
                              nlevels( df.tmp$v2 ) == 1 )
                         {
                           c( tmp.output.b,
                              "-" ) ->
                             tmp.output.b ; 
                         }
                         
                         if ( a != b  &  
                              is.numeric( df.tmp$v1 ) & 
                              nlevels( df.tmp$v2 ) == 1 )
                         {
                           c( tmp.output.b,
                              "-" ) ->
                             tmp.output.b ; 
                         }
                         
                         if ( a != b & 
                              is.factor( df.tmp$v1 ) & 
                              nlevels( df.tmp$v2 ) > 1 &
                              any( table( df.tmp$v2 ) == 1 ) )
                         {
                           c( tmp.output.b,
                              "-" ) ->
                             tmp.output.b ; 
                         }
                         
                         if ( a != b  &  
                              is.numeric( df.tmp$v1 ) & 
                              nlevels( df.tmp$v2 ) > 1 &
                              any( table( df.tmp$v2 ) == 1 ) )
                         {
                           c( tmp.output.b,
                              "-" ) ->
                             tmp.output.b ; 
                         }
                         
                         if ( a != b & 
                              is.factor( df.tmp$v1 ) & 
                              nlevels( df.tmp$v1 ) <= 1 )
                         {
                           c( tmp.output.b,
                              "-" ) ->
                             tmp.output.b ; 
                         }
                         
                       } 
                       
                       return(tmp.output.b)
                     },
                     .options = furrr::furrr_options(seed = TRUE), .progress = T 
  ) |>
    rbind.force() ->
    tmp.output.a ;
  
  rbind.force(c( " ", paste0( "Binarized ", colnames(x) ) ),
              tmp.output.a) ->
    tmp.output.a ;
  
  
  as.data.frame(tmp.output.a) |>
    (function(x) rbind.force( output,
                              c( " ============= ", " ============= ", " ============= " ),
                              c( "Binarized on NA", "Comparaison between binarized columns in TRUE/FALSE for NA and other columns", "If significant, the variable is MAR.", "Wilcoxon rank sum test with continuity correction", "Pearson's Chi-squared test with simulated p-value" ),
                              x,
                              empty = "" ) )() ->
    output ;
  
  # end parallel
  future::plan("sequential")
  
  # Output
  c( paste( rep( "col", dim( output )[2]), 1:dim( output )[2], sep = "" ) ) ->
    colnames( output ) ;
  
  return( output )
}

# 1.2.5 Function to get outliers
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


is.outlier.all <- function(vector, na.rm = TRUE, threshold = 3, k = 1.5 ) 
{
  # SD outiliers
  ( vector - mean( vector, na.rm = na.rm ) ) / sd( vector, na.rm = na.rm ) ->
    Z.score ;
  
  abs(Z.score) > threshold * sd( vector, na.rm = na.rm ) -> 
    is.outlierSD.log ;
  
  # MAD outiliers
  if ( !is.na( mad( vector, na.rm = na.rm ) ) )
  {
    if ( mad( vector, na.rm = na.rm ) != 0 )
    {
      ( vector - median( vector, na.rm = na.rm ) ) / mad( vector, na.rm = na.rm ) ->
        Z.score ;
      abs( Z.score ) > threshold * mad( vector, na.rm = na.rm ) -> is.outlierMAD.log ;
    } else
    {
      as.logical( rep( FALSE, length( vector ) ) ) -> is.outlierMAD.log
    }
  } else
  {
    as.logical( rep( FALSE, length( vector ) ) ) -> is.outlierMAD.log
  }
  
  
  # Tukey's fence outliers
  quantile( vector, probs = c(0.25, 0.75), na.rm = na.rm  ) -> quartile.num ;
  
  IQR( vector, na.rm = na.rm ) -> iqr.num ;
  
  vector < ( quartile.num[1] - (k * iqr.num) ) | 
    vector > ( quartile.num[2] + (k * iqr.num) ) -> 
    is.outlierIQR.log ;
  
  # y values
  is.outlierIQR.log | is.outlierSD.log | is.outlierMAD.log -> is.outlier.log ;
  
  return( is.outlier.log ) ;
} 

is.outlier.Zclassic <- function( vector, threshold = 3, k = 1.5, na.rm = TRUE) 
{
  ( vector - mean( vector, na.rm = na.rm ) ) / sd( vector, na.rm = na.rm ) ->
    Z.score ;
  
  abs( Z.score ) > threshold * sd( vector, na.rm = na.rm ) -> is.outlier.log ;
  
  return( is.outlier.log )
} ;

is.outlier.Zmad <- function( vector, threshold = 3, k = 1.5,  na.rm = TRUE ) 
{
  na.omit( vector ) -> vector ;
  
  ( vector - median( vector, na.rm = na.rm ) ) / mad( vector, na.rm = na.rm ) ->
    Z.score ;
  abs( Z.score ) > threshold * mad( vector, na.rm = na.rm ) -> is.outlier.log ;
  
  return( is.outlier.log )
} ;

is.outlier.Tukey <- function( vector, k = 1.5,  threshold = 3, na.rm = TRUE) 
{
  na.omit( vector ) -> vector ;
  
  quantile( vector, probs = c( 0.25, 0.75 ), na.rm = na.rm ) ->
    quartile1 ;
  
  IQR( vector, na.rm = na.rm ) -> 
    iqr1 ;
  
  ( vector < quartile1[1] - k * iqr1  ) | ( vector > quartile1[2] + k * iqr1 ) -> 
    is.outlier.log ;
  
  return( is.outlier.log )
} ;

Outliers.Get <- function( data, 
                          method = is.outlier.all, 
                          threshold = 3,
                          k = 1.5,
                          na.omit = TRUE )
{
  # Domestic functions
  #~~~~~~~~~~~~~~~~~~~
  download.packages <- function( PackagesNames, ... )
  {
    # Get a vector with packages names 
    packages1 <- c( PackagesNames, ... ) ;
    
    # Install packages
    for (a in 1:length( packages1 ) )
    {
      try( find.package( packages1[a]), silent = TRUE ) -> test ;
      
      if ( class( test ) == "try-error" )
      { print( packages1[a] ) ; 
        install.packages(  packages1[a] ) ;
      } 
    }
  } ;
  
  # loading packages
  #~~~~~~~~~~~~~~~~~
  download.packages("dplyr") ;
  
  # Clean data
  if ( na.omit )
  {
    data |>
      na.omit() ->
      data ;
  }
  
  # if not numeric in df
  data |>
    as.data.frame() |>
    dplyr::select_if(is.numeric) ->
    data.numeric.df ;
  
  if ( all( dim( data.numeric.df )[1] == 0 ) )
  {
    "No numeric in data frame" -> output.df ;
    FALSE -> num.df ;
  } else
  {
    TRUE -> num.df ;
  }
  
  # Job
  #~~~~
  data.numeric.df |>
    apply(  MARGIN = 2, FUN = function(x)
    {
      x[ !is.na(x) ] -> x.narm ;
      
      method( x.narm, 
              na.rm = TRUE,                
              threshold = threshold,
              k = k ) -> x[ !is.na(x) ] ;
      
      FALSE -> x[ is.na(x) ] ;
      
      as.logical( x ) -> x ;
      
      return( x )
    } ) ->
    outliers.df ;
  
  outliers.df |>
    apply( MARGIN = 1, any )->
    outliers.log
  
  for ( a in 1:dim( data.numeric.df )[1] )
  {
    for ( b in 1:dim( data.numeric.df )[2] )
    {
      if ( !is.na( outliers.df[a,b] ) )
      {
        if ( outliers.df[a,b] )
        {
          data.numeric.df[a,b] <- paste( "OUTVALUE_", 
                                         data.numeric.df[a,b],
                                         sep = "" ) ;
        }
      }
    }
  } 
  
  if ( length( which( colnames(data) %in% colnames(data.numeric.df) ) ) > 0 )
  {
    data.numeric.df |>
      dplyr::filter(  outliers.log ) ->
      output.df ;
  } else
  {
    data.numeric.df |>
      dplyr::filter( outliers.log ) ->
      output.df ;
  }
  
  
  return(output.df) ;
} 

# 1.2.6 Function to plot outliers
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

# intern functions 

IQR.interval.min <- function( vector ) { quantile( vector, 0.25 ) - 1.5 * IQR( vector ) ; } ;

IQR.interval.max <- function( vector ) { quantile( vector, 0.75 ) + 1.5 * IQR( vector ) ;} ;

SD1.interval.min <- function( vector ) { mean( vector ) - 1 * sd( vector ) ;} ;

SD1.interval.max <- function( vector ) { mean( vector ) + 1 * sd( vector ) ;} ;

SD2.interval.min <- function( vector ) { mean( vector ) - 2 * sd( vector ) ;} ;

SD2.interval.max <- function( vector ) { mean( vector ) + 2 * sd( vector ) ;} ;

SD3.interval.min <- function( vector ) { mean( vector ) - 3 * sd( vector ) ;} ;

SD3.interval.max <- function( vector ) { mean( vector ) + 3 * sd( vector ) ;} ;

MAD1.interval.min <- function( vector ) { median( vector ) - 1 * mad( vector ) ;} ;

MAD1.interval.max <- function( vector ) { median( vector ) + 1 * mad( vector ) ;} ;

MAD2.interval.min <- function( vector ) {  median( vector ) - 2 * mad( vector ) ;} ;

MAD2.interval.max <- function( vector ) { median( vector ) + 2 * mad( vector ) ;} ;

MAD3.interval.min <- function( vector ) { median( vector ) - 3 * mad( vector ) ;} ;

MAD3.interval.max <- function( vector ) { median( vector ) + 3 * mad( vector ) ;} ;

Outliers.Plot <- function( x, ExportFile, na.rm = TRUE, ncores = parallel::detectCores() )
{
  # Input condition
  if ( !is.data.frame( x ) ) { stop( "x is not a data.frame" );   } ;
  if ( !is.logical( na.rm ) ) { stop( "na.rm is not TRUE or FALSE" );    } ;
  
  # Domestic functions
  active.packages <- function( PackagesNames, ... )
  {
    # Get a vector with packages names 
    packages1 <- c( PackagesNames, ... ) ;
    
    # Require or install and require packages
    for ( a in 1:length( packages1 ) )
    {
      if ( !require( packages1[a], character.only = TRUE  ) )
      { install.packages( packages1[a] ) ; require( packages1[a], character.only = TRUE ) } ;
    } ;
  } ;
  
  geom_mantaray <- function( mapping = NULL, 
                             data = NULL,
                             inherit.aes = TRUE,
                             ..., 
                             violin.param = list( draw_quantiles = c( 0.25, 0.5, 0.75 ), 
                                                  scale = "count" ), 
                             point.param = list(),
                             IQR.param = list( colour = "black", width = 0.2 ),
                             mean.param = list(shape = 18, size = 4, colour = "grey50",
                                               position = position_nudge( x = 0.12 )),
                             median.param = list(shape = 18, size = 4, colour = "darkgrey",
                                                 position = position_nudge( x = 0.24 )),
                             SD1.param = list( colour = "grey50",  width = 0.1,
                                               position = position_nudge( x = 0.12 ) ),
                             SD2.param = list( colour = "grey50",  width = 0.1,
                                               position = position_nudge( x = 0.12 ) ),
                             SD3.param = list( colour = "grey50",  width = 0.1,
                                               position = position_nudge( x = 0.12 ) ),
                             MAD1.param = list( colour = "darkgrey",  width = 0.1,
                                                position = position_nudge( x = 0.24 ) ),
                             MAD2.param = list( colour = "darkgrey",  width = 0.1,
                                                position = position_nudge( x = 0.24 ) ),
                             MAD3.param = list( colour = "darkgrey",  width = 0.1,
                                                position = position_nudge( x = 0.24 ) )
  )
  {
    # graph
    #~~~~~~
    # Parameters
    param <- list( data = data,
                   mapping = mapping,
                   inherit.aes = inherit.aes, 
                   ... ) ;
    
    violin.param <- modifyList( param, violin.param ) ;
    
    point.param <- modifyList( param, point.param ) ;
    
    IQR.param <- modifyList( param, IQR.param ) ;
    
    mean.param <- modifyList( param, mean.param ) ;
    
    median.param <- modifyList( param, median.param ) ;
    
    SD1.param <- modifyList( param, SD1.param ) ;
    
    SD2.param <- modifyList( param, SD2.param ) ;
    
    SD3.param <- modifyList( param, SD3.param ) ;
    
    MAD1.param <- modifyList( param, MAD1.param ) ;
    
    MAD2.param <- modifyList( param, MAD2.param ) ;
    
    MAD3.param <- modifyList( param, MAD3.param ) ;
    
    # Stats
    violin.gg <- do.call( "stat_ydensity", 
                          modifyList( list( geom = GeomViolin, 
                                            position = "dodge" ), 
                                      violin.param ) ) ;
    point.gg <- do.call( "stat_identity", 
                         modifyList( list( geom = GeomPoint, 
                                           position = "identity" ), 
                                     point.param ) ) ;
    
    IQR.gg <-  do.call( "stat_summary", 
                        modifyList( list( fun.ymin = "IQR.interval.min",
                                          fun.ymax = "IQR.interval.max",
                                          geom = GeomErrorbar, 
                                          position = "identity" ), 
                                    IQR.param ) ) ;
    
    mean.gg <-  do.call( "stat_summary", 
                         modifyList( list( fun.y = "mean",
                                           geom = GeomPoint ), 
                                     mean.param ) ) ;
    
    median.gg <-  do.call( "stat_summary", 
                           modifyList( list( fun.y = "median",
                                             geom = GeomPoint ), 
                                       median.param ) ) ;
    
    SD1.gg <-  do.call( "stat_summary", 
                        modifyList( list( fun.ymin = "SD1.interval.min",
                                          fun.ymax = "SD1.interval.max",
                                          geom = GeomErrorbar ), 
                                    SD1.param ) ) ;
    
    SD2.gg <-  do.call( "stat_summary", 
                        modifyList( list( fun.ymin = "SD2.interval.min",
                                          fun.ymax = "SD2.interval.max",
                                          geom = GeomErrorbar ), 
                                    SD2.param ) ) ;
    
    SD3.gg <-  do.call( "stat_summary", 
                        modifyList( list( fun.ymin = "SD3.interval.min",
                                          fun.ymax = "SD3.interval.max",
                                          geom = GeomErrorbar ), 
                                    SD3.param ) ) ;
    
    MAD1.gg <-  do.call( "stat_summary", 
                         modifyList( list( fun.ymin = "MAD1.interval.min",
                                           fun.ymax = "MAD1.interval.max",
                                           geom = GeomErrorbar ), 
                                     MAD2.param ) ) ;
    
    MAD2.gg <-  do.call( "stat_summary", 
                         modifyList( list( fun.ymin = "MAD2.interval.min",
                                           fun.ymax = "MAD2.interval.max",
                                           geom = GeomErrorbar ), 
                                     MAD2.param ) ) ;
    
    MAD3.gg <-  do.call( "stat_summary", 
                         modifyList( list( fun.ymin = "MAD3.interval.min",
                                           fun.ymax = "MAD3.interval.max",
                                           geom = GeomErrorbar ), 
                                     MAD3.param ) ) ;
    
    # Output
    #~~~~~~~
    return( list( violin.gg,
                  point.gg,
                  IQR.gg,
                  mean.gg,
                  median.gg,
                  SD1.gg,
                  SD2.gg,
                  SD3.gg,
                  MAD1.gg,
                  MAD2.gg,
                  MAD3.gg
    ) 
    ) ;
    
  } ;
  
  
  fun.a <- function( a, data, ExportFile )
  {
    # Clean data
    data[,a] -> var ;
    if ( na.rm )
    {
      na.omit( var ) -> var ;
    }
    
    if ( length( var ) > 5 )
    {
      # job
      var |>
        (function(x) data.frame( y = x ) )() |>
        ggplot(  ) +
        geom_mantaray( aes( x = 0, y = y) ) +
        labs( x = "" ) ->
        graph ;
      
      ggsave( paste( ExportFile, 
                     "/MantarayChart_", 
                     colnames(data)[a], 
                     ".png", 
                     sep = "" ), 
              plot = graph,
              height = 8,
              width = 7 )
    }
    
  }
  
  # activate packages
  active.packages( "ggplot2" ) ;
  
  
  # Job
  x |>
    dplyr::select_if(is.numeric) -> 
    x.num ;
  
  if ( all( dim( x.num )[2] == 0 ) )
  {
    print( "No numeric in data frame")
  } else
  {
    lapply( 1:dim(x.num)[2], 
                FUN = fun.a,
                data = x.num,
                ExportFile = ExportFile
                )
  }
  
}


# 1.2.7 Function to study normality
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Normality.Analysis <- function( data ) 
{
  # Adaptation for applying function on vectors
  #============================================
  if ( all( class( data ) != "data.frame" ) ) 
  {
    tmp.name1 <- deparse( substitute( data ) ) ;
    data <- data.frame( data, stringsAsFactors = FALSE ) ;
    colnames( data ) <- tmp.name1 ;
  } ;
  
  # domestic functions 
  #===================
  # function for active packages
  download.packages <- function( PackagesNames, ... )
  {
    # Get a vector with packages names 
    packages1 <- c( PackagesNames, ... ) ;
    
    # Install packages
    for (a in 1:length( packages1 ) )
    {
      try( find.package( packages1[a]), silent = TRUE ) -> test ;
      
      if ( class( test ) == "try-error" )
      { print( packages1[a] ) ; 
        install.packages(  packages1[a] ) ;
      } 
    }
  } ;
  
  # activate packages
  #==================
  download.packages( "moments", "nortest" ) ;
  
  # job
  #====
  # create stockers
  NULL -> tmp.result1 ;
  NULL -> tmp.result2 ;
  
  # loop for all columns in data.frame
  for (a in 1:dim( data )[2] )
  {
    tmp.row1 <- c( colnames( data )[a] ) ;
    
    # clean variable
    tmp1 <- na.omit( data[,a] ) ;
    tmp1 <- as.numeric( tmp1 ) ;
    
    # selection continious variables 
    if( ( any( class( data[,a] ) == "integer" ) | any( class( data[,a] ) == "numeric" ) ) & length( tmp1 ) >= 8 & nlevels( factor(tmp1) ) > 1 )
    {
      if ( length( tmp1 ) <= 5000 )
      {
        # pre computation
        shapiro.test( tmp1 ) -> shapiro1 ;
        nortest::ad.test( tmp1 ) -> anderson1 ;
        moments::jarque.test( tmp1 ) -> jarque1 ;
        if ( shapiro1$p.value > 0.05 & anderson1$p.value > 0.05 & jarque1$p.value > 0.05 )
        { tmp.result2 <- c( tmp.result2, TRUE ) ; nor1 <- TRUE } 
        else 
        { tmp.result2 <- c( tmp.result2, FALSE ) ; nor1 <- FALSE } ;
        
        # stock results
        tmp.row1 <- c( tmp.row1, 
                       TRUE, 
                       nor1,
                       round( shapiro1$statistic, digits = 2 ),
                       round( shapiro1$p.value, digits = 3 ),
                       round( anderson1$statistic, digits = 2 ),
                       round( anderson1$p.value, digits = 3 ),
                       round( jarque1$statistic, digits = 2 ),
                       round( jarque1$p.value, digits = 3 ),
                       round( moments::kurtosis( tmp1 ), digits = 3 ),
                       round( moments::skewness( tmp1 ), digits =  3 )
        ) ; 
        
        tmp.result1 <- rbind( tmp.result1, tmp.row1 ) ;
      } 
      else
      {
        # pre computation
        nortest::ad.test( tmp1 ) -> anderson1 ;
        moments::jarque.test( tmp1 ) -> jarque1 ;
        if ( anderson1$p.value > 0.05 & jarque1$p.value > 0.05 )
        { tmp.result2 <- c( tmp.result2, TRUE ) ; nor1 <- TRUE ; } 
        else 
        { tmp.result2 <- c( tmp.result2, FALSE ) ; nor1 <- FALSE ; } ;
        
        # stock results
        tmp.row1 <- c( tmp.row1, 
                       TRUE, 
                       nor1,
                       "Not applicable",
                       "Not applicable",
                       round( anderson1$statistic, digits = 2 ),
                       round( anderson1$p.value, digits = 3 ),
                       round( jarque1$statistic, digits = 2 ),
                       round( jarque1$p.value, digits = 3 ),
                       round( moments::kurtosis( tmp1 ), digits = 3 ),
                       round( moments::skewness( tmp1 ), digits =  3 )
        ) ; 
        
        tmp.result1 <- rbind( tmp.result1, tmp.row1 ) ;
      } ;
    }
    else
    {
      tmp.row1 <- c( tmp.row1, FALSE, 
                     "","", "", "", "", "", "", "", "" ) ;
      
      tmp.result1 <- rbind( tmp.result1, tmp.row1 ) ;
      
      tmp.result2 <- c( tmp.result2, FALSE ) ;
    } ;
  } ;
  
  # Change class
  tmp.result1 <- as.data.frame( matrix( tmp.result1, ncol = length( tmp.row1 ) ) ) ;
  
  # Rename colomns and rows
  colnames( tmp.result1 ) <- c( "Var", "Testing Relevant", "Normal",
                                "Shapiro-Wilk_W", "Shapiro-Wilk_p", 
                                "Anderson-Darling_A", "Anderson-Darling_p", 
                                "Jarque-Bera_JB", "Jarque-Bera_p", 
                                "Kurtosis", "Skeweness" ) ;
  
  tmp.result1$`Testing Relevant` <- as.logical( tmp.result1$`Testing Relevant` )
  tmp.result1$Normal <- as.logical( tmp.result1$Normal )
  
  rownames( tmp.result1 ) <- NULL ;
  
  names( tmp.result2 ) <- tmp.result1[,1] ;
  
  
  subset( tmp.result1, `Testing Relevant` ) -> tmp.result1 ;
  
  tmp.result1 <- tmp.result1[,-c(2)]
  return( tmp.result1 ) ;
} ;

# 1.2.8 Function to plot normality study
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Normality.Plot <- function( data, ExportFile )
{
  # Adaptation for applying function on vectors
  if ( class( data ) != "data.frame" ) 
  {
    tmp.name1 <- deparse( substitute( data ) ) ;
    data <- data.frame( data, stringsAsFactors = FALSE ) ;
    colnames( data ) <- tmp.name1 ;
  } ;
  
  # domestic functions 
  #===================
  # function for active packages
  download.packages <- function( PackagesNames, ... )
  {
    # Get a vector with packages names 
    packages1 <- c( PackagesNames, ... ) ;
    
    # Install packages
    for (a in 1:length( packages1 ) )
    {
      try( find.package( packages1[a]), silent = TRUE ) -> test ;
      
      if ( class( test ) == "try-error" )
      { print( packages1[a] ) ; 
        install.packages(  packages1[a] ) ;
      } 
    }
  } ;
  
  # activate packages
  #==================
  download.packages( "moments", "nortest" ) ;
  
  # job
  #====
  for (a in 1:dim( data )[2] ) 
  {
    if ( ( any( class( data[,a] ) == "integer" ) | any( class( data[,a] ) == "numeric" ) ) &
         length( na.omit( data[,a] ) ) > 1 )
    {
      na.omit( data[,a] ) -> vector ;
      
      # Segment window
      paste( ExportFile, "/", "Normality_", colnames( data )[a], ".png", sep = "" ) -> tmp.name ;
      png( tmp.name ) ;
      par( mfrow = c( 2, 2), oma = c( 0, 0, 2, 0) )
      
      # extracting tittle 
      name <- colnames( data )[a] ;
      
      # Clean missing value
      na.omit( vector ) -> vector ;
      as.numeric( vector ) -> vector ;
      
      # plot histogram
      hist( vector, main = "Histogram", xlab = "Variable", col = "blue" ) ;
      round( moments::kurtosis( vector ), digits = 2 ) -> tmp.val1 ;
      round( moments::skewness( vector ), digits = 2 ) -> tmp.val2 ;
      paste( "Kurtosis: ", tmp.val1, " ; ", "Skewness: ", tmp.val2, sep = "" ) -> tmp.name1 ;
      title( sub = tmp.name1 ) ;
      
      # plot density 
      plot( density( vector ), 
            main = "Density plot", xlab = "Variable", col = "blue" ) ;
      curve( dnorm( x, mean( vector ), sd( vector ) ), add = TRUE, col = "red", lwd = 2, lty = 2 ) ;
      abline( v = mean( vector ), col = "blue", lwd = 2, lty = 2) ;
      abs( range( vector )[2] - range( vector )[1] ) / 20 -> legend.distance1 ;
      abs( range( density( vector )$y )[2] - range( density( vector )$y )[1] ) / 20 -> legend.distance2 ;
      text( x = mean( vector ) + legend.distance1, y = legend.distance2, expression( mu ), col = "blue" ) ;
      legend( x = "topright", lty = c( 1, 2 ), col = c( "blue", "red" ), c( "Sample", "Normal" ), cex = 0.6 ) ;
      round( moments::jarque.test( vector )$p.value, digits = 3 ) -> tmp.val1 ;
      if ( tmp.val1 < 0.001 ) { tmp.val1 <- "< 0.001"} ;
      paste( "Jarque-Bera test p value: ", tmp.val1 ) -> tmp.name1 ;
      if ( tmp.val1 == "< 0.001" | tmp.val1 < 0.05 ) 
      { title( sub = tmp.name1, col.sub = "green", font.sub = 2 ) ; }
      else
      { title( sub = tmp.name1 ) ; } ;
      
      # plot ecdf 
      plot( ecdf( vector ), main = "Empirical cumulative distribution plot", xlab = "Variable", 
            ylab = "Density", col = "blue", ylim = c( -0.2, 1.2 ) )
      plot( add = TRUE, ecdf( rnorm( 10000, mean = mean( vector ), sd = sd( vector ) ) ), col = "red" ) ;
      abline( h = 0.5, lty = 2, lwd = 1, col = "grey80" )
      legend( x = "bottomright", lty = c( 1, 1 ),col = c( "blue", "red" ), c( "Sample", "Normal" ), cex = 0.6 ) ;
      if ( length( na.omit(vector) ) > 7 ) { 
        round( nortest::ad.test( vector )$p.value, digits = 3 ) -> tmp.val1 ;
        if ( tmp.val1 < 0.001 ) { tmp.val1 <- "< 0.001"} ;
      } else
      {
        "NC" -> tmp.val1 ;
      }
      paste( "Anderson-Darling test p value: ", tmp.val1, sep = "" ) -> tmp.name1 ;
      if ( tmp.val1 == "< 0.001" | tmp.val1 < 0.05 ) 
      { title( sub = tmp.name1, col.sub = "green", font.sub = 2 ) ; }
      else
      { title( sub = tmp.name1 ) ; } ;
      
      # plot qq 
      qqnorm( vector, col = "blue" ) ;
      qqline( vector, col = "red" ) ;
      legend( x = "bottomright", lty = c( 1 ),col = c( "red" ), c( "Henry's line" ), cex = 0.6 ) ;
      if ( length( vector ) > 5000 )
      {
        "Shapiro-Wilk test not performed (N > 5000)" -> tmp.name1 ;
        title( sub = tmp.name1 ) ;
      } else
      {
        round( shapiro.test( vector )$p.value, digits = 3 ) -> tmp.val1 ;
        if ( tmp.val1 < 0.001 ) { tmp.val1 <- "< 0.001"} ;
        paste( "Shapiro-Wilk test p value: ", tmp.val1, sep = "" ) -> tmp.name1 ;
        if ( tmp.val1 == "< 0.001" | tmp.val1 < 0.05 ) 
        { title( sub = tmp.name1, col.sub = "green", font.sub = 2 ) ; }
        else
        { title( sub = tmp.name1 ) ; } ;
      }
      
      # put title 
      tmp.name2 <- paste( "Noramlity Study of", name, sep = " " ) ;
      mtext( text =  tmp.name2, outer = TRUE, cex = 1.5 ) ;
      
      # save
      dev.off() ;
      rm( tmp.name ) ; 
    } ;
  } ;
  
} ;

# 1.2.9 Function to perform univariate analysis
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Univariate.Analysis <- function( data, 
                                 conf.level = 0.95, 
                                 binom.ci.method = "exact",
                                 boot.ci.method = "bca",
                                 nsim = 10000, 
                                 round = 2,
                                 seed = 123,
                                 ncores = NULL
                                 )
{
  # Adaptation for applying function on vectors
  if ( class( data ) != "data.frame" ) 
  {
    if ( is.vector( data ) )
    {
      tmp.name1 <- deparse( substitute( data ) ) ;
      data <- data.frame( data, stringsAsFactors = FALSE ) ;
      colnames( data ) <- tmp.name1 ;
    } else
    {
      stop( "data is not vector, not data.frame")
    }
  } ;
  if ( !is.numeric( conf.level ) ) { stop( "conf.level is not numeric" );    } ;
  if ( !is.character( binom.ci.method ) ) { stop( "binom.ci.method is not character" );    } ;
  if ( !is.character( boot.ci.method ) ) { stop( "boot.ci.method is not character" );    } ;
  if ( !is.double( nsim ) ) { stop( "nsim is not double" );    } ;
  if ( !is.double( round ) ) { stop( "round is not double" );    } ;
  if ( !is.double( seed ) ) { stop( "seed is not double" );    } ;
  if ( !is.null(ncores) & !is.numeric(ncores) ) { stop( "ncores is not null nor numeric" ) }
  
  # parallel
  if ( !is.null( ncores ) ) { future::plan( "multisession",  workers = ncores ) }
  
  # domestic functions 
  download.packages <- function( PackagesNames, ... )
  {
    # Get a vector with packages names 
    packages1 <- c( PackagesNames, ... ) ;
    
    # Install packages
    for (a in 1:length( packages1 ) )
    {
      try( find.package( packages1[a]), silent = TRUE ) -> test ;
      
      if ( class( test ) == "try-error" )
      { print( packages1[a] ) ; 
        install.packages(  packages1[a] ) ;
      } 
    }
  } ;
  
  rbind.force <- function( data, ..., keep.col = FALSE, empty = NA ) 
  {
    # Unify data
    list( data, ... ) -> input ;
    
    # include list elements
    repeat 
    {
      if (  !any( unlist( lapply( input, class ) ) == "list" ) ) { break }  
      
      which( unlist( lapply( input, class ) ) == "list" )[1] -> a ;
      input[[a]] -> tmp ;
      input[[a]] <- NA ;
      c( input[1:a],  tmp, input[ (a + 1):length( input ) ] ) -> 
        input ;
    }
    
    input[ !is.na( input ) ] ->
      input ;
    
    # delete NULL data and transformt vector in data.frame
    for ( a in 1:length( input ) )
    {
      if ( is.null( dim( input[[a]] ) ) )
      {
        if ( is.null( input[[a]] ) )
        {
          input[[a]] <- NA ;
        } else
        {
          data.frame( matrix( input[[a]], nrow = 1 ),
                      stringsAsFactors = FALSE ) -> input[[a]] ; 
        }
      }
      
      if ( all( dim( input[[a]] ) == 0 ) )
      {
        input[[a]] <- NA ;
      }
    }
    
    input[ !is.na( input ) ] ->
      input ;
    
    # test data class
    if ( !all( unlist( lapply( input, is.data.frame ) ) |
               unlist( lapply( input, is.matrix ) ) |
               unlist( lapply( input, is.vector ) ) ) )
    { stop( "Some argument are not data.frame, neither vector" ) ;
      ; } ;
    
    # Set primer
    input[[1]] -> output ; 
    
    # job in case we keep columns 
    if ( keep.col & length( input ) >1 )
    {
      for ( a in 2:length( input ) )
      { 
        output -> x ;
        input[[a]] -> y ; 
        
        for (a in 1:dim(x)[2]) { x[,a] <- as.character(x[,a])}
        for (a in 1:dim(y)[2]) { y[,a] <- as.character(y[,a])}
        
        x.diff <- setdiff(colnames(x), colnames(y))
        y.diff <- setdiff(colnames(y), colnames(x))
        
        if( dim(x)[1] > 0 ) { x[, c(as.character(y.diff))] <- empty ; }
        if( dim(y)[1] > 0 ) { y[, c(as.character(x.diff))] <- empty ; }
        
        rbind(x, y) -> output ;
      } 
    }
    
    # job in case we do not keep columns
    if ( !keep.col & length( input ) >1 )
    {
      for ( a in 2:length( input ) )
      { 
        output -> x ;
        input[[a]] -> y ; 
        
        colnames(x) <- paste( "X",
                              1:dim( x )[2], 
                              sep = "" ) ;
        colnames(y) <- paste( "X",
                              1:dim( y )[2], 
                              sep = "" ) ;
        
        for (a in 1:dim(x)[2]) { x[,a] <- as.character(x[,a])}
        for (a in 1:dim(y)[2]) { y[,a] <- as.character(y[,a])}
        
        x.diff <- setdiff(colnames(x), colnames(y))
        y.diff <- setdiff(colnames(y), colnames(x))
        
        if( dim(x)[1] > 0 ) { x[, c(as.character(y.diff))] <- empty ; }
        if( dim(y)[1] > 0 ) { y[, c(as.character(x.diff))] <- empty ; }
        
        rbind(x, y) -> output ;
      } 
    }
    
    return( output ) ;
  } 
  
  CImean.boot <- function( vector, level = conf.level, nsim = nsim, 
                           boot.ci.method = boot.ci.method )
  {
    # domestic functions 
    # function for bootstrap mean
    mean.boot <- function( x, a) 
    { 
      mean( x[a] ) -> m ;
      length(a) -> n ;
      (n-1) * var( x[a] ) / (n^2) -> v ;
      return( c( m, v ) )
    } 
    
    # job  
    boot::boot( vector, statistic = mean.boot, R = nsim ) -> tmp1 ;
    boot::boot.ci( tmp1, conf = level, type = boot.ci.method ) -> tmp2 ;
    
    tmp2[[4]][ (length( tmp2[[4]] ) - 1):length( tmp2[[4]] ) ] -> ci ;
    
    return( ci ) ;
  } ;
  
  fun.a <- function ( a, data, conf.level, binom.ci.method,
                      boot.ci.method, nsim, round, seed )
  {
    # omit na
    na.omit( data[,a] ) -> var ;
    
    # seed
    set.seed( seed ) ;
    
    # factor
    if ( any(class( var ) == "factor") & length( var ) > 0 )
    {
      # remake factor 
      factor( var ) -> var ;
      
      # stock var name
      c( "quali",
         colnames( data )[a], 
         "-",
         sum( is.na( data[,a] ) ),
         length( var ),
         rep( "-", 5 ) ) -> 
        output.a ;
      
      # for each levels
      fun.lvl <- function( b, var, conf.level, binom.ci.method, round )
      {
        # preparation
        levels( var )[b] -> tmp.level ;
        binom::binom.confint( length( var[ var == tmp.level ] ), 
                       length( var ), 
                       conf.level = conf.level, 
                       methods = binom.ci.method )[5:6] ->
          tmp.ci ;
        
        # job
        c( "quali",
           "-",
           tmp.level, 
           "-",
           "-",
           round( length( var[ var == tmp.level ] ) / length( var ) * 100, 
                  digits = round ), 
           round( tmp.ci[1,1] * 100, 
                  digits = round ), 
           round( tmp.ci[1,2] * 100, digits = round ),
           binom.ci.method,
           length( var[ var == tmp.level ] )
        ) ->
          output ;
        
        return( output ) ;
      }
      
      rbind.force( output.a,
                   lapply( 1:nlevels( var ),
                           fun.lvl,
                           var = var,
                           conf.level = conf.level, 
                           binom.ci.method = binom.ci.method,
                           round = round ),
                   empty = "" ) -> 
        output.a ;
    }
    
    # numeric 
    if ( ( any( class( var ) == "numeric" ) | 
           any( class( var ) == "integer" ) ) & 
         length( var ) > 0 & 
         nlevels( factor( as.character( var ) ) ) > 1 )
    {
      if ( length( var ) >= 1000 )
      {
        t.test( var, conf.level = conf.level )$conf.int -> cistudent1 ;
        ci1 <- cistudent1[1] ;
        ci2 <- cistudent1[2] ;
        type <- "Student" ;
      } else
      { 
        CImean.boot( var, level = conf.level, nsim = nsim, 
                     boot.ci.method = boot.ci.method ) -> ciboot1 ;
        ci1 <- ciboot1[1] ;
        ci2 <- ciboot1[2] ;
        type <- paste( "bootstrap", boot.ci.method, sep = "." ) ;
      }
      
      # job
      c( "quanti",
         colnames( data )[a], 
         "-",
         sum( is.na( data[,a] ) ), 
         length( var ), 
         round( mean( var ), 
                digits = round ), 
         round( ci1, 
                digits = round ), 
         round( ci2, 
                digits = round ),
         type,
         round( sd( var ), 
                digits = round ), 
         min( var ), 
         max( var )
      ) ->
        output.a ;
    }
    
    # Character var
    if ( any(class( var ) == "character") & 
         length( var ) > 0 )
    {
      c( "other",
         colnames( data )[a], 
         class( data[,a] )[1],
         sum( is.na( data[,a] ) ), 
         length( var ),
         nlevels( factor( var ) ), 
         min( var ), 
         max( var ) ) ->
        output.a ;
    } 
    
    # Date type var
    if ( ( any( class( var ) == "POSIXlt" ) |  
           any( class( var ) == "POSIXct" ) |
           any( class( var ) == "Date" ) ) & 
         length( var ) > 0 )
    {
      as.character( var ) -> var ;
      
      c( "other",
         colnames( data )[a], 
         class( data[,a] )[1],
         sum( is.na( data[,a] ) ), 
         length( var ),
         nlevels( factor( var ) ),
         min( var ),
         max( var ) ) ->
        output.a ;
    } 
    
    # Numeric var with only 1 possible value
    if ( ( any(class( var ) == "numeric") | 
           any(class( var ) == "integer") ) & 
         length( var ) > 0 & 
         nlevels( factor( as.character( var ) ) ) == 1 )
    {
      c(  "other",
          colnames( data )[a], 
          class( data[,a] )[1], 
          sum( is.na( data[,a] ) ), 
          length( var ),
          "only 1",  "value:", 
          max( var ) ) ->
        output.a ;
    } 
    
    # Var with 0 obs
    if (length( var ) == 0 )
    {
      c( "other",
         colnames( data )[a], 
         class( data[,a] )[1], 
         "has", "no", "observation", "", "" ) ->
        output.a ;
    } 
    
    # Class not supported
    if ( any(class( var ) != "factor") & 
         any(class( var ) != "numeric") & 
         any(class( var ) != "integer") &
         any(class( var ) != "character") & 
         any( class( var ) != "POSIXlt" ) &  
         any( class( var ) != "POSIXct" ) &
         any( class( var ) != "Date" ) & 
         length( var ) > 0 )
    {
      c( "other",
         colnames( data )[a],  
         class( data[,a] )[1],
         sum( is.na( data[,a] ) ), 
         length( var ), 
         "Class",
         "not",
         "supported" ) ->
        output.a ;
    } 
    
    
    return( output.a ) 
  } 
  
  # activate packages
  download.packages( "boot", "binom", "furrr" ) ;
  
  
  
  # job
  #====
  furrr::future_map(
    1:dim( data )[2],
    fun.a,
    data = data, seed = seed, nsim = nsim, boot.ci.method = boot.ci.method,
    conf.level = conf.level, round = round, binom.ci.method = binom.ci.method,
    .options = furrr::furrr_options( seed = seed ), .progress = T 
    ) |>
    rbind.force() ->
    output ;
  
  # Output
  #=======
  rbind.force( c( "quali", "Var", "Level", "N missing", "N valid", "%", 
                  "CI lb", "CI ub", "CI type", "Count"  ), 
               output[ output[,1] == "quali", ],
               c( "quanti", "Var", "-", "N missing", "N valid", "Mean", 
                  "CI lb", "CI ub", "CI type", "Sd", "Min", "Max"  ),
               output[ output[,1] == "quanti", ],
               c( "other", "Var", "Class", "N missing", "N valid", "N levels", 
                  "Min", "Max" ),
               output[ output[,1] == "other", ],
               empty = "" ) ->
    output ; 
  
  if ( dim(  output[ output[,1] == "quali", ] )[1] == 1 )
  { output[ output[,1] != "quali", ] -> output ; }
  
  if ( dim(  output[ output[,1] == "quanti", ] )[1] == 1 )
  { output[ output[,1] != "quanti", ] -> output ; }
  
  if ( dim(  output[ output[,1] == "other", ] )[1] == 1 )
  { output[ output[,1] != "other", ] -> output ; }
  
  c( "Class", "Var", "Level", "N missing", "N valid", "Mean/%", 
     "CI lb", "CI ub", "CI type", "Sd/n", "Min", "Max" ) -> 
    colnames( output ) ;
  
  # end parallel
  future::plan("sequential")
  
  return( output ) ;  
} ;

# 1.2.10 Function to perform univariate analysis, full version
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Univariate.Analysis.Full <- function( data, 
                                      conf.level = 0.95, 
                                      binom.ci.method = "exact",
                                      boot.ci.method = "bca",
                                      nsim = 2000, 
                                      round = 5,
                                      seed = 123,
                                      ncores = NULL
                                      )
{
  # Adaptation for applying function on vectors
  if ( class( data ) != "data.frame" ) 
  {
    if ( is.vector( data ) )
    {
      tmp.name1 <- deparse( substitute( data ) ) ;
      data <- data.frame( data, stringsAsFactors = FALSE ) ;
      colnames( data ) <- tmp.name1 ;
    } else
    {
      stop( "data is not vector, not data.frame")
    }
  } ;
  if ( !is.numeric( conf.level ) ) { stop( "conf.level is not numeric" );    } ;
  if ( !is.character( binom.ci.method ) ) { stop( "binom.ci.method is not character" );    } ;
  if ( !is.character( boot.ci.method ) ) { stop( "boot.ci.method is not character" );    } ;
  if ( !is.double( nsim ) ) { stop( "nsim is not double" );    } ;
  if ( !is.double( round ) ) { stop( "round is not double" );    } ;
  if ( !is.double( seed ) ) { stop( "seed is not double" );    } ;
  if ( !is.null(ncores) & !is.numeric(ncores) ) { stop( "ncores is not null nor numeric" ) }
  
  # parallel
  if ( !is.null( ncores ) ) { future::plan( "multisession",  workers = ncores ) }
  
  # domestic functions 
  download.packages <- function( PackagesNames, ... )
  {
    # Get a vector with packages names 
    packages1 <- c( PackagesNames, ... ) ;
    
    # Install packages
    for (a in 1:length( packages1 ) )
    {
      try( find.package( packages1[a]), silent = TRUE ) -> test ;
      
      if ( class( test ) == "try-error" )
      { print( packages1[a] ) ; 
        install.packages(  packages1[a] ) ;
      } 
    }
  } ;
  
  rbind.force <- function( data, ..., keep.col = FALSE, empty = NA ) 
  {
    # Unify data
    list( data, ... ) -> input ;
    
    # include list elements
    repeat 
    {
      if (  !any( unlist( lapply( input, class ) ) == "list" ) ) { break }  
      
      which( unlist( lapply( input, class ) ) == "list" )[1] -> a ;
      input[[a]] -> tmp ;
      input[[a]] <- NA ;
      c( input[1:a],  tmp, input[ (a + 1):length( input ) ] ) -> 
        input ;
    }
    
    input[ !is.na( input ) ] ->
      input ;
    
    # delete NULL data and transformt vector in data.frame
    for ( a in 1:length( input ) )
    {
      if ( is.null( dim( input[[a]] ) ) )
      {
        if ( is.null( input[[a]] ) )
        {
          input[[a]] <- NA ;
        } else
        {
          data.frame( matrix( input[[a]], nrow = 1 ),
                      stringsAsFactors = FALSE ) -> input[[a]] ; 
        }
      }
      
      if ( all( dim( input[[a]] ) == 0 ) )
      {
        input[[a]] <- NA ;
      }
    }
    
    input[ !is.na( input ) ] ->
      input ;
    
    # test data class
    if ( !all( unlist( lapply( input, is.data.frame ) ) |
               unlist( lapply( input, is.matrix ) ) |
               unlist( lapply( input, is.vector ) ) ) )
    { stop( "Some argument are not data.frame, neither vector" ) ;
      ; } ;
    
    # Set primer
    input[[1]] -> output ; 
    
    # job in case we keep columns 
    if ( keep.col & length( input ) >1 )
    {
      for ( a in 2:length( input ) )
      { 
        output -> x ;
        input[[a]] -> y ; 
        
        for (a in 1:dim(x)[2]) { x[,a] <- as.character(x[,a])}
        for (a in 1:dim(y)[2]) { y[,a] <- as.character(y[,a])}
        
        x.diff <- setdiff(colnames(x), colnames(y))
        y.diff <- setdiff(colnames(y), colnames(x))
        
        if( dim(x)[1] > 0 ) { x[, c(as.character(y.diff))] <- empty ; }
        if( dim(y)[1] > 0 ) { y[, c(as.character(x.diff))] <- empty ; }
        
        rbind(x, y) -> output ;
      } 
    }
    
    # job in case we do not keep columns
    if ( !keep.col & length( input ) >1 )
    {
      for ( a in 2:length( input ) )
      { 
        output -> x ;
        input[[a]] -> y ; 
        
        colnames(x) <- paste( "X",
                              1:dim( x )[2], 
                              sep = "" ) ;
        colnames(y) <- paste( "X",
                              1:dim( y )[2], 
                              sep = "" ) ;
        
        for (a in 1:dim(x)[2]) { x[,a] <- as.character(x[,a])}
        for (a in 1:dim(y)[2]) { y[,a] <- as.character(y[,a])}
        
        x.diff <- setdiff(colnames(x), colnames(y))
        y.diff <- setdiff(colnames(y), colnames(x))
        
        if( dim(x)[1] > 0 ) { x[, c(as.character(y.diff))] <- empty ; }
        if( dim(y)[1] > 0 ) { y[, c(as.character(x.diff))] <- empty ; }
        
        rbind(x, y) -> output ;
      } 
    }
    
    return( output ) ;
  } 
  
  CImean.boot <- function( vector, level = conf.level, nsim = nsim, 
                           boot.ci.method = boot.ci.method )
  {
    # domestic functions 
    # function for bootstrap mean
    mean.boot <- function( x, a) 
    { 
      mean( x[a] ) -> m ;
      length(a) -> n ;
      (n-1) * var( x[a] ) / (n^2) -> v ;
      return( c( m, v ) )
    } 
    
    # job  
    boot::boot( vector, statistic = mean.boot, R = nsim ) -> tmp1 ;
    boot::boot.ci( tmp1, conf = level, type = boot.ci.method ) -> tmp2 ;
    
    tmp2[[4]][ (length( tmp2[[4]] ) - 1):length( tmp2[[4]] ) ] -> ci ;
    
    return( ci ) ;
  } ;
  
  fun.a <- function ( a, data, conf.level, binom.ci.method,
                      boot.ci.method, nsim, round, seed )
  {
    # omit na
    na.omit( data[,a] ) -> var ;
    
    # seed
    set.seed( seed ) ;
    
    # factor
    if ( any(class( var ) == "factor") & length( var ) > 0 )
    {
      # remake factor 
      factor( var ) -> var ;
      
      # stock var name
      c( "quali",
         colnames( data )[a], 
         "-",
         sum( is.na( data[,a] ) ),
         length( var ),
         round( sum( is.na( data[,a] ) ) / length( data[,a] ) * 100, 
                digits = round ), 
         round( length( var ) / length( data[,a] ) * 100, 
                digits = round ),
         rep( "-", 4 ) ) -> 
        output.a ;
      
      # for each levels
      fun.lvl <- function( b, var, conf.level, binom.ci.method, round )
      {
        # preparation
        levels( var )[b] -> tmp.level ;
        binom::binom.confint( length( var[ var == tmp.level ] ), 
                       length( var ), 
                       conf.level = conf.level, 
                       methods = binom.ci.method )[5:6] ->
          tmp.ci ;
        
        # job
        c( "quali",
           "-",
           tmp.level, 
           rep( "-", 4 ),
           round( length( var[ var == tmp.level ] ) / length( var ) * 100, 
                  digits = round ), 
           round( tmp.ci[1,1] * 100, 
                  digits = round ), 
           round( tmp.ci[1,2] * 100, digits = round ),
           binom.ci.method,
           length( var[ var == tmp.level ] )
        ) ->
          output ;
        
        return( output ) ;
      }
      
      rbind.force( output.a,
                   lapply( 1:nlevels( var ),
                           fun.lvl,
                           var = var,
                           conf.level = conf.level, 
                           binom.ci.method = binom.ci.method,
                           round = round ),
                   empty = "" ) -> 
        output.a ;
    }
    
    # numeric 
    if ( ( any( class( var ) == "numeric" ) | 
           any( class( var ) == "integer" ) ) & 
         length( var ) > 0 & 
         nlevels( factor( as.character( var ) ) ) > 1 )
    {
      if ( length( var ) >= 1000 )
      {
        t.test( var, conf.level = conf.level )$conf.int -> cistudent1 ;
        ci1 <- cistudent1[1] ;
        ci2 <- cistudent1[2] ;
        type <- "Student" ;
      } else
      { 
        CImean.boot( var, level = conf.level, nsim = nsim, 
                     boot.ci.method = boot.ci.method ) -> ciboot1 ;
        ci1 <- ciboot1[1] ;
        ci2 <- ciboot1[2] ;
        type <- paste( "bootstrap", boot.ci.method, sep = "." ) ;
      }
      
      # job
      c( "quanti",
         colnames( data )[a], 
         "-",
         sum( is.na( data[,a] ) ), 
         length( var ),  
         round( sum( is.na( data[,a] ) ) / length( data[,a] ) * 100, 
                digits = round ), 
         round( length( var ) / length( data[,a] ) * 100, 
                digits = round ),
         round( mean( var ), 
                digits = round ), 
         round( ci1, 
                digits = round ), 
         round( ci2, 
                digits = round ), 
         type,
         round( sd( var ), 
                digits = round ), 
         min( var ), 
         max( var ),
         round( IQR( var ), digits = round ),
         median( var ), 
         round( mad( var ), 
                digits = round ), 
         round( mean( abs( var - mean( var ) ) ), 
                digits =  round ),
         round( sd( var ) / mean( var ), 
                digits = round ), 
         round( sd( var ) / ( sqrt( length( var ) ) ), 
                digits = round ),
         round( (sd( var ) / ( sqrt( length( var ) ) ) ) / mean( var ), 
                digits = round ), 
         length( names( table( var )[ max( table( var ) ) == table( var ) ] ) ),
         names( table( var )[ max( table( var ) ) == table( var ) ] )[1],
         round( quantile( var, probs = c( 0.25, 0.75, 0.15, 0.85,
                                          0.1, 0.9, 0.03, 0.97, 
                                          0.01, 0.99, 0.001, 0.999 ) ), 
                digits = round )
      ) ->
        output.a ;
    }
    
    # Character var
    if ( any(class( var ) == "character") & 
         length( var ) > 0 )
    {
      c( "other",
         colnames( data )[a], 
         class( data[,a] )[1],
         sum( is.na( data[,a] ) ), 
         length( var ),
         round( sum( is.na( data[,a] ) ) / length( data[,a] ) * 100, 
                digits = round ), 
         round( length( var ) / length( data[,a] ) * 100, 
                digits = round ),
         nlevels( factor( var ) ), 
         min( var ), 
         max( var ) ) ->
        output.a ;
    } 
    
    # Date type var
    if ( ( any( class( var ) == "POSIXlt" ) |  
           any( class( var ) == "POSIXct" ) |
           any( class( var ) == "Date" ) ) & 
         length( var ) > 0 )
    {
      as.character( var ) -> var ;
      
      c( "other",
         colnames( data )[a], 
         class( data[,a] )[1],
         sum( is.na( data[,a] ) ), 
         length( var ), 
         round( sum( is.na( data[,a] ) ) / length( data[,a] ) * 100, 
                digits = round ), 
         round( length( var ) / length( data[,a] ) * 100, 
                digits = round ),
         nlevels( factor( var ) ),
         min( var ),
         max( var ) ) ->
        output.a ;
    } 
    
    # Numeric var with only 1 possible value
    if ( ( any(class( var ) == "numeric") | 
           any(class( var ) == "integer") ) & 
         length( var ) > 0 & 
         nlevels( factor( as.character( var ) ) ) == 1 )
    {
      c(  "other",
          colnames( data )[a], 
          class( data[,a] )[1], 
          sum( is.na( data[,a] ) ), 
          length( var ),
          round( sum( is.na( data[,a] ) ) / length( data[,a] ) * 100, 
                 digits = round ), 
          round( length( var ) / length( data[,a] ) * 100, 
                 digits = round ),
          "only 1",  "value:", 
          max( var ) ) ->
        output.a ;
    } 
    
    # Var with 0 obs
    if (length( var ) == 0 )
    {
      c( "other",
         colnames( data )[a], 
         class( data[,a] )[1], 
         "has", "no", "observation", "", "" ) ->
        output.a ;
    } 
    
    # Class not supported
    if ( any(class( var ) != "factor") & 
         any(class( var ) != "numeric") & 
         any(class( var ) != "integer") &
         any(class( var ) != "character") & 
         any( class( var ) != "POSIXlt" ) &  
         any( class( var ) != "POSIXct" ) &
         any( class( var ) != "Date" ) & 
         length( var ) > 0 )
    {
      c( "other",
         colnames( data )[a],  
         class( data[,a] )[1],
         sum( is.na( data[,a] ) ), 
         length( var ), 
         round( sum( is.na( data[,a] ) ) / length( data[,a] ) * 100, 
                digits = round ), 
         round( length( var ) / length( data[,a] ) * 100, 
                digits = round ),
         "Class",
         "not",
         "supported" ) ->
        output.a ;
    } 
    
    return( output.a ) 
  } 
  
  # activate packages
  download.packages( "boot", "binom", "furrr" ) ;
  
  # job
  #====
  furrr::future_map( 1:dim( data )[2],
                     fun.a,
                    data = data,
                    conf.level = conf.level, 
                    binom.ci.method = binom.ci.method,
                    boot.ci.method = boot.ci.method, 
                    nsim = nsim, 
                    round = round, 
                    seed = seed,
                    .options = furrr::furrr_options( seed = seed ), .progress = T 
                    ) |>
    rbind.force() ->
    output ;
  
  # Output
  #=======
  rbind.force( c( "quali", "Var", "Level", "N missing", "N valid", 
                  "% missing", "% valid", "%", 
                  "CI lb", "CI ub", "CI type", "Count" ), 
               output[ output[,1] == "quali", ],
               c("quanti", "Var", "-", "N missing", "N valid", 
                 "% missing", "% valid", "Mean", 
                 "CI lb", "CI ub", "CI type", "Sd", "Min", "Max",
                 "InterQuartile Range", "Median", 
                 "Median absolute deviation", "Mean absolute deviation", 
                 "Relative standard deviation", "Standard error", 
                 "Relative standard error", 
                 "Number of Mode", "1st mode",
                 "1st quartile", "3d quartile", "15 c", "85 c",
                 "10 c", "90 c", "3 c", "97 c", "1 c", "99 c",
                 "0.1 c", "99.9 c" ),
               output[ output[,1] == "quanti", ],
               c( "other", "Var", "Class", "N missing", "N valid",
                  "% missing", "% valid", "N levels", 
                  "Min", "Max" ),
               output[ output[,1] == "other", ],
               empty = "" ) ->
    output ; 
  
  if ( dim(  output[ output[,1] == "quali", ] )[1] == 1 )
  { output[ output[,1] != "quali", ] -> output ; }
  
  if ( dim(  output[ output[,1] == "quanti", ] )[1] == 1 )
  { output[ output[,1] != "quanti", ] -> output ; }
  
  if ( dim(  output[ output[,1] == "other", ] )[1] == 1 )
  { output[ output[,1] != "other", ] -> output ; }
  
  
  c( "Class", "Var", "Level", "N missing", "N valid", "Mean/%", 
     "CI lb", "CI ub", "CI type", "Sd/n", "Min", "Max",
     "InterQuartile Range", "Median", 
     "Median absolute deviation", "Mean absolute deviation", 
     "Relative standard deviation", "Standard error", 
     "Relative standard error", 
     "Number of Mode", "1st mode",
     "1st quartile", "3d quartile", "15 c", "85 c",
     "10 c", "90 c", "3 c", "97 c", "1 c", "99 c",
     "0.1 c", "99.9 c") -> 
    colnames( output ) ;
  
  # end parallel
  future::plan("sequential")
  
  return( output ) ;  
} ;

# 1.2.11 Function to do descriptive stats on table incorporating multiples subgroups
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Univariate.Analysis.ByGroups  <- function( data, groups, recursive = FALSE,
                                           full = FALSE,
                                           conf.level = 0.95, 
                                           binom.ci.method = "exact",
                                           boot.ci.method = "bca",
                                           nsim = 10000, 
                                           round = 5,
                                           seed = 123,
                                           ncores = NULL
                                           )
{ 
  # Conditions for input
  if ( class( data ) != "data.frame" ) 
  {
    if ( is.vector( data ) )
    {
      tmp.name1 <- deparse( substitute( data ) ) ;
      data <- data.frame( data, stringsAsFactors = FALSE ) ;
      colnames( data ) <- tmp.name1 ;
    } else
    {
      stop( "data is not vector, not data.frame")
    }
  } ;
  if ( !is.character( groups ) ) { stop( "groups is not character" );    } ;
  if ( !is.logical( full ) ) { stop( "full is not logical" );    } ;
  if ( !is.logical( recursive ) ) { stop( "recursive is not logical" );    } ;
  if ( !is.numeric( conf.level ) ) { stop( "conf.level is not numeric" );    } ;
  if ( !is.character( binom.ci.method ) ) { stop( "binom.ci.method is not character" );    } ;
  if ( !is.character( boot.ci.method ) ) { stop( "boot.ci.method is not character" );    } ;
  if ( !is.double( nsim ) ) { stop( "nsim is not double" );    } ;
  if ( !is.double( round ) ) { stop( "round is not double" );    } ;
  if ( !is.double( seed ) ) { stop( "seed is not double" );    } ;
  if ( !is.null(ncores) & !is.numeric(ncores) ) { stop( "ncores is not null nor numeric" ) }
  
  # parallel
  if ( !is.null( ncores ) ) { future::plan( "multisession",  workers = ncores ) }  
  
  # function definition
  download.packages <- function( PackagesNames, ... )
  {
    # Get a vector with packages names 
    packages1 <- c( PackagesNames, ... ) ;
    
    # Install packages
    for (a in 1:length( packages1 ) )
    {
      try( find.package( packages1[a]), silent = TRUE ) -> test ;
      
      if ( class( test ) == "try-error" )
      { print( packages1[a] ) ; 
        install.packages(  packages1[a] ) ;
      } 
    }
  } ;
  
  rbind.force <- function( data, ..., keep.col = FALSE, empty = NA ) 
  {
    # Unify data
    list( data, ... ) -> input ;
    
    # include list elements
    repeat 
    {
      if (  !any( unlist( lapply( input, class ) ) == "list" ) ) { break }  
      
      which( unlist( lapply( input, class ) ) == "list" )[1] -> a ;
      input[[a]] -> tmp ;
      input[[a]] <- NA ;
      c( input[1:a],  tmp, input[ (a + 1):length( input ) ] ) -> 
        input ;
    }
    
    input[ !is.na( input ) ] ->
      input ;
    
    # delete NULL data and transformt vector in data.frame
    for ( a in 1:length( input ) )
    {
      if ( is.null( dim( input[[a]] ) ) )
      {
        if ( is.null( input[[a]] ) )
        {
          input[[a]] <- NA ;
        } else
        {
          data.frame( matrix( input[[a]], nrow = 1 ),
                      stringsAsFactors = FALSE ) -> input[[a]] ; 
        }
      }
      
      if ( all( dim( input[[a]] ) == 0 ) )
      {
        input[[a]] <- NA ;
      }
    }
    
    input[ !is.na( input ) ] ->
      input ;
    
    # test data class
    if ( !all( unlist( lapply( input, is.data.frame ) ) |
               unlist( lapply( input, is.matrix ) ) |
               unlist( lapply( input, is.vector ) ) ) )
    { stop( "Some argument are not data.frame, neither vector" ) ;
      ; } ;
    
    # Set primer
    input[[1]] -> output ; 
    
    # job in case we keep columns 
    if ( keep.col & length( input ) >1 )
    {
      for ( a in 2:length( input ) )
      { 
        output -> x ;
        input[[a]] -> y ; 
        
        for (a in 1:dim(x)[2]) { x[,a] <- as.character(x[,a])}
        for (a in 1:dim(y)[2]) { y[,a] <- as.character(y[,a])}
        
        x.diff <- setdiff(colnames(x), colnames(y))
        y.diff <- setdiff(colnames(y), colnames(x))
        
        if( dim(x)[1] > 0 ) { x[, c(as.character(y.diff))] <- empty ; }
        if( dim(y)[1] > 0 ) { y[, c(as.character(x.diff))] <- empty ; }
        
        rbind(x, y) -> output ;
      } 
    }
    
    # job in case we do not keep columns
    if ( !keep.col & length( input ) >1 )
    {
      for ( a in 2:length( input ) )
      { 
        output -> x ;
        input[[a]] -> y ; 
        
        colnames(x) <- paste( "X",
                              1:dim( x )[2], 
                              sep = "" ) ;
        colnames(y) <- paste( "X",
                              1:dim( y )[2], 
                              sep = "" ) ;
        
        for (a in 1:dim(x)[2]) { x[,a] <- as.character(x[,a])}
        for (a in 1:dim(y)[2]) { y[,a] <- as.character(y[,a])}
        
        x.diff <- setdiff(colnames(x), colnames(y))
        y.diff <- setdiff(colnames(y), colnames(x))
        
        if( dim(x)[1] > 0 ) { x[, c(as.character(y.diff))] <- empty ; }
        if( dim(y)[1] > 0 ) { y[, c(as.character(x.diff))] <- empty ; }
        
        rbind(x, y) -> output ;
      } 
    }
    
    return( output ) ;
  } 
  
  fun.recursive <- function( a,
                             tmp.list1,
                             groups,
                             full,
                             conf.level, 
                             binom.ci.method,
                             boot.ci.method,
                             nsim, 
                             round,
                             seed 
                             )
    
  {
    if ( full )
    {
      cbind( tmp.list1[[a]][ 1, 1:length( groups ) ], 
             Univariate.Analysis.Full( tmp.list1[[a]][,-c(1:length( groups ))], 
                                       conf.level = conf.level, 
                                       binom.ci.method = binom.ci.method,
                                       boot.ci.method = boot.ci.method,
                                       nsim = nsim, 
                                       round = round,
                                       seed = seed
                                       ) ) -> 
        output.recursive ;
    } else
    {
      cbind( tmp.list1[[a]][ 1, 1:length( groups ) ], 
             Univariate.Analysis( tmp.list1[[a]][,-c(1:length( groups ))], 
                                  conf.level = conf.level, 
                                  binom.ci.method = binom.ci.method,
                                  boot.ci.method = boot.ci.method,
                                  nsim = nsim, 
                                  round = round,
                                  seed = seed
                                  ) ) -> 
        output.recursive ;
    }
    
    return( output.recursive )
  }
  
  fun.norecursive <- function( a,
                               tmp.list1,
                               full,
                               conf.level, 
                               binom.ci.method,
                               boot.ci.method,
                               nsim, 
                               round,
                               seed
                               )
  {
    if ( full )
    {
      cbind( tmp.list1[[a]][ 1, 1 ], 
             Univariate.Analysis.Full( tmp.list1[[a]][,-1], 
                                       conf.level = conf.level, 
                                       binom.ci.method = binom.ci.method,
                                       boot.ci.method = boot.ci.method,
                                       nsim = nsim, 
                                       round = round,
                                       seed = seed
                                       ) ) -> 
        output.norecursive ;
    } else
    {
      cbind( tmp.list1[[a]][ 1, 1 ], 
             Univariate.Analysis( tmp.list1[[a]][,-1], 
                                  conf.level = conf.level, 
                                  binom.ci.method = binom.ci.method,
                                  boot.ci.method = boot.ci.method,
                                  nsim = nsim, 
                                  round = round,
                                  seed = seed
                                  ) ) -> 
        output.norecursive ;
    }
    
    return( output.norecursive )
  }
  
  # Load packages
  download.packages( "furrr" ) ;
  
  # prepare group
  tmp.list1 <- list( data ) ;
  
  if ( recursive )
  {
    for ( a in 1:length(groups) )
    {
      factor( data[,groups[a]] ) -> fact.grp ;
      tmp.list2 <- list( NULL ) ;
      
      for ( b in 1:nlevels(fact.grp) )
      {
        for ( c in 1:length(tmp.list1) )
        {
          tmp.list1[[c]][tmp.list1[[c]][,groups[a]] == levels(fact.grp)[b],] -> tmp.tab1 ;
          if ( dim(tmp.tab1)[1] != 0 )
          {
            cbind( group = levels(fact.grp)[b], tmp.tab1 ) -> tmp.tab1 ;
            colnames( tmp.tab1 )[1] <- paste( groups[a], ".levels", sep = "" ) ;
            c( tmp.list2, list( tmp.tab1 ) ) -> tmp.list2 ;
          } ;
        } ;
      } ;
      tmp.list2[-1] -> tmp.list1 ;
    } ;
  } ;
  
  if ( !recursive )
  {
    tmp.list2 <- list( NULL ) ;
    for ( a in 1:length(groups) )
    {
      factor( data[,groups[a]] ) -> fact.grp ;
      
      for ( b in 1:nlevels(fact.grp) )
      {
        for ( c in 1:length(tmp.list1) )
        {
          tmp.list1[[c]][tmp.list1[[c]][,groups[a]] == levels(fact.grp)[b],] -> tmp.tab1 ;
          if ( dim(tmp.tab1)[1] != 0 )
          {
            cbind( group = paste( groups[a], ".", levels(fact.grp)[b], sep = "" ), tmp.tab1 ) -> tmp.tab1 ;
            c( tmp.list2, list( tmp.tab1 ) ) -> tmp.list2 ;
          } ;
        } ;
      } ;
    } ;
    tmp.list2[-1] -> tmp.list1 ;
  } ;
  
  
  # loop for description
  if ( recursive )
  {
    furrr::future_map(
      1:length( tmp.list1 ),
      fun.recursive,
      tmp.list1 = tmp.list1,
      groups = groups,
      full = full,
      conf.level = conf.level, 
      binom.ci.method = binom.ci.method,
      boot.ci.method = boot.ci.method,
      nsim = nsim, 
      round = round,
      seed = seed,
      .options = furrr::furrr_options( seed = seed ), .progress = T 
    ) |>
      rbind.force() ->
      output ;
    
    colnames( output )[1:length(groups)] <- colnames(tmp.list1[[a]])[1:length(groups)] ;
  } ;
  
  if ( !recursive )
  {
    furrr::future_map(
      1:length( tmp.list1 ),
      fun.recursive,
      tmp.list1 = tmp.list1,
      groups = groups,
      full = full,
      conf.level = conf.level, 
      binom.ci.method = binom.ci.method,
      boot.ci.method = boot.ci.method,
      nsim = nsim, 
      round = round,
      seed = seed,
      .options = furrr::furrr_options( seed = seed ), .progress = T 
    ) |>
      rbind.force() ->
      output ;
    
    colnames( output )[1] <- "group" ;
  } ;
  
  # end parallel
  future::plan("sequential")
  
  return( output ) ;
} ; 

# 1.2.12 Function to perform univariate analysis plot
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Univariate.Plot <- function( data, ExportFile )
{
  # Adaptation for applying function on vectors
  if ( class( data ) != "data.frame" ) 
  {
    tmp.name1 <- deparse( substitute( data ) ) ;
    data <- data.frame( data, stringsAsFactors = FALSE ) ;
    colnames( data ) <- tmp.name1 ;
  } ;
  
  # job
  for (a in 1:dim( data )[2] ) 
  {
    data[,a] |> na.omit() -> tmp1 ; 
    
    if ( length(tmp1) != 0 )
    {
      if ( any( class( data[,a] ) == "factor" ) )
      {
        paste( ExportFile, "/", "BarChart_", colnames( data )[a], ".png", sep = "" ) -> tmp.name ;
        png( tmp.name ) ;
        plot( tmp1, main = colnames( data )[a], ylab = "count" ) ;
        dev.off() ;
        rm( tmp.name ) ;
        
        if ( nlevels( factor( tmp1 ) ) <= 12 )
        {
          paste( ExportFile, "/", "DensityBarChart_", colnames( data )[a], ".png", sep = "" ) -> tmp.name ;
          png( tmp.name ) ;
          (table( tmp1 ) / length( tmp1 )) + 0.02 -> y.coord ; 
          round( table( tmp1 ) / length( tmp1 ) * 100, digits = 1 ) -> perc ; 
          barplot( table( tmp1 ) / length( tmp1 ), args.legend = list( bty = "n" ), main = colnames( data )[a],
                   ylab = "Percentages", ylim = c( 0, (max(perc) / 100 + 0.1 ) ) ) -> x.coord ; 
          paste( perc, "%" ) -> perc ; text( x.coord, y.coord,  perc, cex = 1 ) ;
          dev.off() ;
          rm( tmp.name ) ;
        } 
        else
        {
          paste( ExportFile, "/", "DensityBarChart_", colnames( data )[a], ".png", sep = "" ) -> tmp.name ;
          png( tmp.name ) ;
          barplot( table( tmp1 ) / length( tmp1 ), args.legend = list( bty = "n" ), main = colnames( data )[a],
                   ylab = "Percentages" )  ;
          dev.off() ;
          rm( tmp.name ) ;
        } ;
        
        paste( ExportFile, "/", "PieChart_", colnames( data )[a], ".png", sep = "" ) -> tmp.name ;
        png( tmp.name ) ;
        table( tmp1 ) -> tmp.tab1 ; tmp.tab1 / length( tmp1 ) * 100 -> perc ; 
        round(perc, digits = 1) -> perc ;
        tmp.labels1 <- levels( tmp1 ) ; paste( tmp.labels1, " ", perc, " %", sep = "" ) ->  tmp.labels1 ;
        pie( tmp.tab1, main = colnames( data )[a], col = gray.colors( length( levels(tmp1) ) ), 
             labels = tmp.labels1 ) ;
        dev.off() ;
        rm( tmp.name ) ;
      } ; 
      
      if ( any( class( data[,a] ) == "integer" | class( data[,a] ) == "numeric" ) )
      {
        if ( length( levels( factor( tmp1 ) ) ) <= 15 )
        {
          paste( ExportFile, "/", "BarChart_", colnames( data )[a], ".png", sep = "" ) -> tmp.name ;
          png( tmp.name ) ;
          plot( table(tmp1), main = colnames( data )[a], ylab = "Number" ) ;
          dev.off() ;
          rm( tmp.name ) ;
        }
        else 
        {
          paste( ExportFile, "/", "Histogram_", colnames( data )[a], ".png", sep = "" ) -> tmp.name ;
          png( tmp.name ) ;
          hist( tmp1, main = colnames( data )[a], xlab = "" ) ;
          dev.off() ;
          rm( tmp.name ) ;
        } ;
        paste( ExportFile, "/", "BoxPlot_", colnames( data )[a], ".png", sep = "" ) -> tmp.name ;
        png( tmp.name ) ;
        boxplot( tmp1, main = colnames( data )[a] ) ;
        dev.off() ;
        rm( tmp.name ) ;
      } ;
    } ;
  } ;  
} ;

# 1.2.13 Function to perform bivaraite analysis
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Bivariate.Analysis <- function( x, y, 
                                by = NULL, 
                                by.x = by, by.y = by, 
                                na.rm = TRUE,
                                conf.level = 0.95,
                                Welch.correct = TRUE,
                                Yates.correct = TRUE,
                                Williams.correct = FALSE,
                                Continuity.correct = TRUE,
                                Permutations = TRUE,
                                nsim = 10000,
                                seed = 12345,
                                pvalue.round = 3,
                                round = 2,
                                remove.x.y = TRUE,
                                ncores = NULL )
{
  # Input condition
  if ( !is.data.frame( x ) ) { stop( "x is not a data.frame" );   } ;
  if ( !is.data.frame( y ) ) { stop( "y is not a data.frame" );   } ;
  if ( !is.character( by ) ) { stop( "by is not a string" );   } ;
  if ( !is.character( by.x ) ) { stop( "by.x is not a string" );    } ;
  if ( !is.character( by.y ) ) { stop( "by.y is not a string" );    } ;
  if ( !is.logical( na.rm ) ) { stop( "na.rm is not TRUE or FALSE" );    } ;
  if ( !is.numeric( conf.level ) ) { stop( "conf.level is not numeric" );    } ;
  if ( !is.logical( Welch.correct ) ) { stop( "Welch.correct is not TRUE or FALSE" );    } ;
  if ( !is.logical( Yates.correct ) ) { stop( "Yates.correct is not TRUE or FALSE" );    } ;
  if ( !is.logical( Williams.correct ) ) { stop( "Williams.correct is not TRUE or FALSE" );    } ;
  if ( !is.logical( Continuity.correct ) ) { stop( "Continuity.correct is not TRUE or FALSE" );    } ;
  if ( !is.logical( Permutations ) ) { stop( "Permutations is not TRUE or FALSE" );    } ;
  if ( !is.numeric( nsim ) ) { stop( "nsim is not numeric" ) } 
  else { if ( nsim != round( nsim ) ) { stop( "nsim is not integer" ) } }
  if ( !is.numeric( seed ) ) { stop( "nsim is not numeric" ) } 
  else { if ( seed != round( seed ) ) { stop( "seed is not integer" ) } }
  if ( !( is.numeric( pvalue.round ) | 
          is.null( pvalue.round ) ) ) { stop( "pvalue.round is neither numeric, neither NULL" );    } ;
  if ( !( is.numeric( round ) | 
          is.null( round ) ) ) { stop( "round is neither numeric, neither NULL" );    } ;
  if ( !is.logical( remove.x.y ) ) { stop( "remove.x.y is not TRUE or FALSE" );    } ;
  if ( !is.null(ncores) & !is.numeric(ncores) ) { stop( "ncores is not null nor numeric" ) }
  
  # parallel
  if ( !is.null( ncores ) ) { future::plan( "multisession",  workers = ncores ) }
  
  
  # Domestic functions
  download.packages <- function( PackagesNames, ... )
  {
    # Get a vector with packages names 
    packages1 <- c( PackagesNames, ... ) ;
    
    # Install packages
    for (a in 1:length( packages1 ) )
    {
      try( find.package( packages1[a]), silent = TRUE ) -> test ;
      
      if ( class( test ) == "try-error" )
      { print( packages1[a] ) ; 
        install.packages(  packages1[a] ) ;
      } 
    }
  } ;
  
  rbind.force <- function( data, ..., keep.col = FALSE, empty = NA ) 
  {
    # Unify data
    list( data, ... ) -> input ;
    
    # include list elements
    repeat 
    {
      if (  !any( unlist( lapply( input, class ) ) == "list" ) ) { break }  
      
      which( unlist( lapply( input, class ) ) == "list" )[1] -> a ;
      input[[a]] -> tmp ;
      input[[a]] <- NA ;
      c( input[1:a],  tmp, input[ (a + 1):length( input ) ] ) -> 
        input ;
    }
    
    input[ !is.na( input ) ] ->
      input ;
    
    # delete NULL data and transformt vector in data.frame
    for ( a in 1:length( input ) )
    {
      if ( is.null( dim( input[[a]] ) ) )
      {
        if ( is.null( input[[a]] ) )
        {
          input[[a]] <- NA ;
        } else
        {
          data.frame( matrix( input[[a]], nrow = 1 ),
                      stringsAsFactors = FALSE ) -> input[[a]] ; 
        }
      }
      
      if ( all( dim( input[[a]] ) == 0 ) )
      {
        input[[a]] <- NA ;
      }
    }
    
    input[ !is.na( input ) ] ->
      input ;
    
    # test data class
    if ( !all( unlist( lapply( input, is.data.frame ) ) |
               unlist( lapply( input, is.matrix ) ) |
               unlist( lapply( input, is.vector ) ) ) )
    { stop( "Some argument are not data.frame, neither vector" ) ;
      ; } ;
    
    # Set primer
    input[[1]] -> output ; 
    
    # job in case we keep columns 
    if ( keep.col & length( input ) >1 )
    {
      for ( a in 2:length( input ) )
      { 
        output -> x ;
        input[[a]] -> y ; 
        
        for (a in 1:dim(x)[2]) { x[,a] <- as.character(x[,a])}
        for (a in 1:dim(y)[2]) { y[,a] <- as.character(y[,a])}
        
        x.diff <- setdiff(colnames(x), colnames(y))
        y.diff <- setdiff(colnames(y), colnames(x))
        
        if( dim(x)[1] > 0 ) { x[, c(as.character(y.diff))] <- empty ; }
        if( dim(y)[1] > 0 ) { y[, c(as.character(x.diff))] <- empty ; }
        
        rbind(x, y) -> output ;
      } 
    }
    
    # job in case we do not keep columns
    if ( !keep.col & length( input ) >1 )
    {
      for ( a in 2:length( input ) )
      { 
        output -> x ;
        input[[a]] -> y ; 
        
        colnames(x) <- paste( "X",
                              1:dim( x )[2], 
                              sep = "" ) ;
        colnames(y) <- paste( "X",
                              1:dim( y )[2], 
                              sep = "" ) ;
        
        for (a in 1:dim(x)[2]) { x[,a] <- as.character(x[,a])}
        for (a in 1:dim(y)[2]) { y[,a] <- as.character(y[,a])}
        
        x.diff <- setdiff(colnames(x), colnames(y))
        y.diff <- setdiff(colnames(y), colnames(x))
        
        if( dim(x)[1] > 0 ) { x[, c(as.character(y.diff))] <- empty ; }
        if( dim(y)[1] > 0 ) { y[, c(as.character(x.diff))] <- empty ; }
        
        rbind(x, y) -> output ;
      } 
    }
    
    return( output ) ;
  } 
  
  p.round <- function( data, digits = 3 )
  {
    if (digits == 1)
    { "" -> tmp1 ; } else 
    { rep( "0", digits - 1 ) -> tmp1 ; }
    
    "0." -> tmp2 ;
    for( a in 1:length(tmp1) )
    {
      paste( tmp2, tmp1[a], sep = "" ) -> tmp2 ;
    }
    
    paste( tmp2, "1", sep = "" ) -> pval ;
    
    for ( a in 1:length(data) )
    {
      if ( !is.na( data[a] ) )
      {
        if ( data[a] >= as.numeric( pval ) )
        {
          round( data[a], digits = digits ) -> data[a] ;
        }
      }
    }
    
    data[ data < as.numeric( pval ) ] <- paste( "< ", pval, sep = "" ) ;
    
    return( data ) ;
  }
  
  CramersV <- function( x, y, na.rm = TRUE )
  {
    if ( na.rm ) 
    {
      na.omit( data.frame( x, y ) ) -> df ;
      df$x -> x ;
      df$y -> y ;  
    }
    
    ftable( x, y ) -> cont.table ;
    
    chisq.test( cont.table )$statistic -> X2 ;
    
    ( X2 / ( length( x ) * ( min( nrow( cont.table ), ncol( cont.table ) ) - 1 ) ) 
    ) -> V2 ;
    
    sqrt( V2 ) -> V
    "Cramer's V"-> names( V ) ;
    
    return( V )   
  } 
  
  eta.squared <- function( x, y )
  {
    if ( !is.factor( x ) ) { stop( "x is not factor" );   } ;
    if ( !is.numeric( y ) ) { stop( "y is not numeric" );   } ;
    
    means <- tapply( y, INDEX = x, FUN = mean ) ;
    samples <- tapply( y, INDEX = x, FUN = length ) ;
    varinter <- sum( samples * ( means - mean( y ) )^2 ) / length( y ) ;
    vartot <- var( y ) ;
    
    return( varinter / vartot ) ;
  };
  
  r.pb <- function( x, y )
  {
    if ( !is.factor( x ) ) { stop( "x is not factor" );   } ;
    if ( !is.numeric( y ) ) { stop( "y is not numeric" );   } ;
    
    sd <- sqrt( sum( (y - mean(y) )^2 ) / (length(y) - 1) ) ;
    means <- tapply( y, INDEX = x, FUN = mean ) ;
    lengths <- tapply( y, INDEX = x, FUN = length ) ;
    
    ( (means[2] - means[1]) / sd ) * sqrt( (lengths[1] * lengths[2]) / 
                                             (length(y) * (length(y) - 1)) )
  }
  
  CohenD <- function( x, y )
  {
    if ( !is.factor( x ) ) { stop( "x is not factor" );   } ;
    if ( !is.numeric( y ) ) { stop( "y is not numeric" );   } ;
    
    SCEs <- tapply( y, INDEX = x, FUN = function(a){sum( (a - mean(a) )^2 ) / (length(a) - 1) } ) ;
    lengths <- tapply( y, INDEX = x, FUN = length ) ;
    
    means <- tapply( y, INDEX = x, FUN = mean ) ;
    
    s <- sqrt( ( (lengths[1] - 1) * SCEs[1] + (lengths[2] - 1) * SCEs[2] ) / 
                 (lengths[1] + lengths[2] - 2) ) ;
    
    (means[2] - means[1]) / s
  }
  
  HedgeGstar <- function( x, y )
  {
    if ( !is.factor( x ) ) { stop( "x is not factor" );   } ;
    if ( !is.numeric( y ) ) { stop( "y is not numeric" );   } ;
    
    SCEs <- tapply( y, INDEX = x, FUN = function(a){sum( (a - mean(a) )^2 ) / (length(a) - 1) } ) ;
    lengths <- tapply( y, INDEX = x, FUN = length ) ;
    means <- tapply( y, INDEX = x, FUN = mean ) ;
    
    s <- sqrt( ( (lengths[1] - 1) * SCEs[1] + (lengths[2] - 1) * SCEs[2] ) / 
                 (lengths[1] + lengths[2] - 2) ) ;
    
    (means[2] - means[1]) / s -> g
    
    (1 - (3 / (4 * (lengths[1] + lengths[2]) - 9) ) ) * g 
  }
  
  CliffDelta <- function( x, y )
  {
    if ( !is.numeric( x ) ) { stop( "x is not numeric" );   } ;
    if ( !is.numeric( y ) ) { stop( "y is not numeric" );   } ;
    
    wilcox.test( x, y )$statistic -> W ;
    
    2 * W / ( length(x) * length(y) ) - 1 
  }
  
  RankBiserialCor <- function( x, y )
  {
    if ( !is.numeric( x ) ) { stop( "x is not numeric" );   } ;
    if ( !is.numeric( y ) ) { stop( "y is not numeric" );   } ;
    
    wilcox.test( x, y )$statistic -> W ;
    
    1 - 2 * W / ( length(x) * length(y) )
  }
  
  oneway.test2 <- function(formula, data, subset, 
                           na.action, var.equal = FALSE)
  {
    if (missing(formula) || (length(formula) != 3L)) 
      stop("'formula' missing or incorrect")
    dp <- as.character.default(formula)
    if (length(dp) != 3L) 
      stop("a two-sided formula is required")
    DNAME <- paste(dp[[2L]], "and", dp[[3L]])
    m <- match.call(expand.dots = FALSE)
    if (is.matrix(eval(m$data, parent.frame()))) 
      m$data <- as.data.frame(data)
    m$var.equal <- NULL
    m[[1L]] <- quote(stats::model.frame)
    mf <- eval(m, parent.frame())
    response <- attr(attr(mf, "terms"), "response")
    y <- mf[[response]]
    if (length(mf[-response]) > 1L) 
      g <- factor(do.call("interaction", mf[-response]))
    else g <- factor(mf[[-response]])
    k <- nlevels(g)
    if (k < 2L) 
      stop("not enough groups")
    n.i <- tapply(y, g, length)
    if (any(n.i < 2)) 
      stop("not enough observations")
    m.i <- tapply(y, g, mean)
    v.i <- tapply(y, g, var)
    w.i <- n.i/v.i
    sum.w.i <- sum(w.i)
    tmp <- sum((1 - w.i/sum.w.i)^2/(n.i - 1))/(k^2 - 1)
    METHOD <- "One-way analysis of means"
    if (var.equal) {
      n <- sum(n.i)
      STATISTIC <- ((sum(n.i * (m.i - mean(y))^2)/(k - 1))/(sum((n.i - 
                                                                   1) * v.i)/(n - k)))
      PARAMETER <- c(k - 1, n - k)
      PVAL <- pf(STATISTIC, k - 1, n - k, lower.tail = FALSE)
    }
    else {
      m <- sum(w.i * m.i)/sum.w.i
      STATISTIC <- sum(w.i * (m.i - m)^2)/((k - 1) * (1 + 2 * 
                                                        (k - 2) * tmp))
      PARAMETER <- c(k - 1, 1/(3 * tmp))
      PVAL <- pf(STATISTIC, k - 1, 1/(3 * tmp), lower.tail = FALSE)
      METHOD <- paste(METHOD, "(not assuming equal variances)")
    }
    names(STATISTIC) <- "F"
    names(PARAMETER) <- c("num df", "denom df")
    RVAL <- list(statistic = STATISTIC, parameter = PARAMETER, 
                 p.value = PVAL, method = METHOD, data.name = DNAME)
    class(RVAL) <- "htest"
    RVAL
  }
  
  Risks.Analysis <- function( x, y, name.x = "", name.y = "",
                              na.rm = TRUE, conf.level = 0.95, 
                              pvalue.round = pvalue.round, round = round )
  {
    # Input condition
    if ( !is.factor( x ) ) { stop( "x is not a factor" );   } ;
    if ( !is.factor( y ) ) { stop( "y is not a factor" );   } ;
    if ( !is.character( name.x ) ) { stop( "name.x is not a factor" );   } ;
    if ( !is.character( name.y ) ) { stop( "name.y is not a factor" );   } ;
    if ( !is.logical( na.rm ) ) { stop( "na.rm is not TRUE or FALSE" );    } ;
    if ( !is.numeric( conf.level ) ) { stop( "conf.level is not numeric" );    } ;
    if ( !( is.numeric( pvalue.round ) | 
            is.null( pvalue.round ) ) ) { stop( "pvalue.round is neither numeric, neither NULL" );    } ;
    if ( !( is.numeric( round ) | 
            is.null( round ) ) ) { stop( "round is neither numeric, neither NULL" );    } ;
    
    # Domestic functions 
    p.round <- function( data, digits = 3 )
    {
      if (digits == 1)
      { "" -> tmp1 ; } else 
      { rep( "0", digits - 1 ) -> tmp1 ; }
      
      "0." -> tmp2 ;
      for( a in 1:length(tmp1) )
      {
        paste( tmp2, tmp1[a], sep = "" ) -> tmp2 ;
      }
      
      paste( tmp2, "1", sep = "" ) -> pval ;
      
      for ( a in 1:length(data) )
      {
        if ( !is.na( data[a] ) )
        {
          if ( data[a] >= as.numeric( pval ) )
          {
            round( data[a], digits = digits ) -> data[a] ;
          }
        }
      }
      
      data[ data < as.numeric( pval ) ] <- paste( "< ", pval, sep = "" ) ;
      
      return( data ) ;
    }
    
    # load packages
    download.packages("pwr")
    
    # Names
    if ( name.x == "" ) { name.x <- deparse( substitute( x ) ) ; }
    if ( name.y == "" ) { name.y <- deparse( substitute( y ) ) ; }
    
    # NA
    if ( na.rm ) 
    {
      na.omit( data.frame( x, y ) ) -> df ;
      df$x -> x ;
      df$y -> y ;
    } 
    
    # Format
    factor( x ) -> x ;
    factor( y ) -> y ;
    if ( nlevels( x ) != 2 ) { stop( "x has not 2 levels" );   } ;
    if ( nlevels( y ) != 2 ) { stop( "y has not 2 levels" );   } ;
    
    # Prepare matrix
    as.matrix( ftable( x, y ) ) -> mat1 ; 
    
    colnames( mat1 ) -> colnames1 ;
    
    rownames( mat1 ) -> rownames1 ;
    
    # Test
    fisher.test( x, y, simulate.p.value = FALSE )$p.value -> p.value ;
    
    # Job
    # line 1
    paste( name.x, rownames1[1], sep = ":" ) -> risk.name ;
    paste( name.y, colnames1[1], sep = ":" ) -> group1 ;
    mat1[1,1] / (mat1[1,1] + mat1[2,1]) -> risk1 ;
    mat1[1,1] / mat1[2,1] -> odds1 ;
    paste( name.y, colnames1[2], sep = ":" ) -> group2 ;
    mat1[1,2] / (mat1[1,2] + mat1[2,2]) -> risk2 ;
    mat1[1,2] / mat1[2,2] -> odds2 ;
    risk1 / risk2 -> RR ;
    sqrt( (1/mat1[1,1] + 1/mat1[1,2]) - (1/(mat1[1,1] + mat1[2,1]) + 1/(mat1[1,2] + mat1[2,2]) ) ) -> log.RR.SE
    exp( log( RR ) - qnorm( (1 - conf.level) / 2, lower.tail = F ) * log.RR.SE ) -> RR.CI2.5 ;
    exp( log( RR ) + qnorm( (1 - conf.level) / 2, lower.tail = F ) * log.RR.SE ) -> RR.CI97.5 ;
    odds1 / odds2 -> OR ;
    sqrt( 1/mat1[1,1] + 1/mat1[1,2] + 1/mat1[2,1] + 1/mat1[2,2] ) -> log.OR.SE ;
    exp( log( OR ) - qnorm( (1 - conf.level) / 2, lower.tail = F ) * log.OR.SE ) -> OR.CI2.5 ;
    exp( log( OR ) + qnorm( (1 - conf.level) / 2, lower.tail = F ) * log.OR.SE ) -> OR.CI97.5 ;
    risk1 - risk2 -> ARR ;
    ARR / risk2 -> RRR ;
    1 / ARR -> NNT ;
    (RR -1) / RR -> ARP ;
    1 - RR -> PF ; 
    pwr::ES.h( risk1, risk2 ) -> cohenh
    
    c( risk.name, 
       group1, risk1, odds1,
       group2, risk2, odds2,
       RR, RR.CI2.5, RR.CI97.5, 
       paste0( "Based on normal approximation of log( RR ), ",
               "confidence level of: ",
               conf.level),
       log.RR.SE, 
       OR, OR.CI2.5, OR.CI97.5,
       paste0( "Based on normal approximation of log( OR ), ",
               "confidence level of: ",
               conf.level),
       log.OR.SE,
       p.value,
       cohenh,
       ARR, RRR, NNT, ARP, PF
    ) -> 
      line1 ;
    
    # line 2
    paste( name.x, rownames1[1], sep = ":" ) -> risk.name ;
    paste( name.y, colnames1[1], sep = ":" ) -> group2 ;
    mat1[1,1] / (mat1[1,1] + mat1[2,1]) -> risk2 ;
    mat1[1,1] / mat1[2,1] -> odds2 ;
    paste( name.y, colnames1[2], sep = ":" ) -> group1 ;
    mat1[1,2] / (mat1[1,2] + mat1[2,2]) -> risk1 ;
    mat1[1,2] / mat1[2,2] -> odds1 ;
    risk1 / risk2 -> RR ;
    sqrt( (1/mat1[1,1] + 1/mat1[1,2]) - (1/(mat1[1,1] + mat1[2,1]) + 1/(mat1[1,2] + mat1[2,2]) ) ) -> log.RR.SE
    exp( log( RR ) - qnorm( (1 - conf.level) / 2, lower.tail = F ) * log.RR.SE ) -> RR.CI2.5 ;
    exp( log( RR ) + qnorm( (1 - conf.level) / 2, lower.tail = F ) * log.RR.SE ) -> RR.CI97.5 ;
    odds1 / odds2 -> OR ;
    sqrt( 1/mat1[1,1] + 1/mat1[1,2] + 1/mat1[2,1] + 1/mat1[2,2] ) -> log.OR.SE ;
    exp( log( OR ) - qnorm( (1 - conf.level) / 2, lower.tail = F ) * log.OR.SE ) -> OR.CI2.5 ;
    exp( log( OR ) + qnorm( (1 - conf.level) / 2, lower.tail = F ) * log.OR.SE ) -> OR.CI97.5 ;
    risk1 - risk2 -> ARR ;
    ARR / risk2 -> RRR ;
    1 / ARR -> NNT ;
    (RR -1) / RR -> ARP ;
    1 - RR -> PF ; 
    pwr::ES.h( risk1, risk2 ) -> cohenh
    
    c( risk.name, 
       group1, risk1, odds1,
       group2, risk2, odds2,
       RR, RR.CI2.5, RR.CI97.5, 
       paste0( "Based on normal approximation of log( RR ), ",
               "confidence level of: ",
               conf.level),
       log.RR.SE, 
       OR, OR.CI2.5, OR.CI97.5,
       paste0( "Based on normal approximation of log( OR ), ",
               "confidence level of: ",
               conf.level),
       log.OR.SE,
       p.value,
       cohenh,
       ARR, RRR, NNT, ARP, PF
    ) -> 
      line2 ;
    
    # line 3
    paste( name.x, rownames1[2], sep = ":" ) -> risk.name ;
    paste( name.y, colnames1[1], sep = ":" ) -> group1 ;
    mat1[2,1] / (mat1[1,1] + mat1[2,1]) -> risk1 ;
    mat1[2,1] / mat1[1,1] -> odds1 ;
    paste( name.y, colnames1[2], sep = ":" ) -> group2 ;
    mat1[2,2] / (mat1[1,2] + mat1[2,2]) -> risk2 ;
    mat1[2,2] / mat1[1,2] -> odds2 ;
    risk1 / risk2 -> RR ;
    sqrt( (1/mat1[2,1] + 1/mat1[2,2]) - (1/(mat1[1,1] + mat1[2,1]) + 1/(mat1[1,2] + mat1[2,2]) ) ) -> log.RR.SE
    exp( log( RR ) - qnorm( (1 - conf.level) / 2, lower.tail = F ) * log.RR.SE ) -> RR.CI2.5 ;
    exp( log( RR ) + qnorm( (1 - conf.level) / 2, lower.tail = F ) * log.RR.SE ) -> RR.CI97.5 ;
    odds1 / odds2 -> OR ;
    sqrt( 1/mat1[1,1] + 1/mat1[1,2] + 1/mat1[2,1] + 1/mat1[2,2] ) -> log.OR.SE ;
    exp( log( OR ) - qnorm( (1 - conf.level) / 2, lower.tail = F ) * log.OR.SE ) -> OR.CI2.5 ;
    exp( log( OR ) + qnorm( (1 - conf.level) / 2, lower.tail = F ) * log.OR.SE ) -> OR.CI97.5 ;
    risk1 - risk2 -> ARR ;
    ARR / risk2 -> RRR ;
    1 / ARR -> NNT ;
    (RR -1) / RR -> ARP ;
    1 - RR -> PF ; 
    pwr::ES.h( risk1, risk2 ) -> cohenh
    
    c( risk.name, 
       group1, risk1, odds1,
       group2, risk2, odds2,
       RR, RR.CI2.5, RR.CI97.5, 
       paste0( "Based on normal approximation of log( RR ), ",
               "confidence level of: ",
               conf.level),
       log.RR.SE, 
       OR, OR.CI2.5, OR.CI97.5,
       paste0( "Based on normal approximation of log( OR ), ",
               "confidence level of: ",
               conf.level),
       log.OR.SE,
       p.value,
       cohenh,
       ARR, RRR, NNT, ARP, PF
    ) -> 
      line3 ;
    
    # line 4
    paste( name.x, rownames1[2], sep = ":" ) -> risk.name ;
    paste( name.y, colnames1[1], sep = ":" ) -> group2 ;
    mat1[2,1] / (mat1[1,1] + mat1[2,1]) -> risk2 ;
    mat1[2,1] / mat1[1,1] -> odds2 ;
    paste( name.y, colnames1[2], sep = ":" ) -> group1 ;
    mat1[2,2] / (mat1[1,2] + mat1[2,2]) -> risk1 ;
    mat1[2,2] / mat1[1,2] -> odds1 ;
    risk1 / risk2 -> RR ;
    sqrt( (1/mat1[2,1] + 1/mat1[2,2]) - (1/(mat1[1,1] + mat1[2,1]) + 1/(mat1[1,2] + mat1[2,2]) ) ) -> log.RR.SE
    exp( log( RR ) - qnorm( (1 - conf.level) / 2, lower.tail = F ) * log.RR.SE ) -> RR.CI2.5 ;
    exp( log( RR ) + qnorm( (1 - conf.level) / 2, lower.tail = F ) * log.RR.SE ) -> RR.CI97.5 ;
    odds1 / odds2 -> OR ;
    sqrt( 1/mat1[1,1] + 1/mat1[1,2] + 1/mat1[2,1] + 1/mat1[2,2] ) -> log.OR.SE ;
    exp( log( OR ) - qnorm( (1 - conf.level) / 2, lower.tail = F ) * log.OR.SE ) -> OR.CI2.5 ;
    exp( log( OR ) + qnorm( (1 - conf.level) / 2, lower.tail = F ) * log.OR.SE ) -> OR.CI97.5 ;
    risk1 - risk2 -> ARR ;
    ARR / risk2 -> RRR ;
    1 / ARR -> NNT ;
    (RR -1) / RR -> ARP ;
    1 - RR -> PF ; 
    pwr::ES.h( risk1, risk2 ) -> cohenh
    
    c( risk.name, 
       group1, risk1, odds1,
       group2, risk2, odds2,
       RR, RR.CI2.5, RR.CI97.5, 
       paste0( "Based on normal approximation of log( RR ), ",
               "confidence level of: ",
               conf.level),
       log.RR.SE, 
       OR, OR.CI2.5, OR.CI97.5,
       paste0( "Based on normal approximation of log( OR ), ",
               "confidence level of: ",
               conf.level),
       log.OR.SE,
       p.value,
       cohenh,
       ARR, RRR, NNT, ARP, PF
    ) -> 
      line4 ;
    
    # line 5
    paste( name.y, colnames1[1], sep = ":" ) -> risk.name ;
    paste( name.x, rownames1[1], sep = ":" ) -> group1 ;
    mat1[1,1] / (mat1[1,1] + mat1[1,2]) -> risk1 ;
    mat1[1,1] / mat1[1,2] -> odds1 ;
    paste( name.x, rownames1[2], sep = ":" ) -> group2 ;
    mat1[2,1] / (mat1[2,1] + mat1[2,2]) -> risk2 ;
    mat1[2,1] / mat1[2,2] -> odds2 ;
    risk1 / risk2 -> RR ;
    sqrt( (1/mat1[1,1] + 1/mat1[2,1]) - (1/(mat1[1,1] + mat1[1,2]) + 1/(mat1[2,1] + mat1[2,2]) ) ) -> log.RR.SE
    exp( log( RR ) - qnorm( (1 - conf.level) / 2, lower.tail = F ) * log.RR.SE ) -> RR.CI2.5 ;
    exp( log( RR ) + qnorm( (1 - conf.level) / 2, lower.tail = F ) * log.RR.SE ) -> RR.CI97.5 ;
    odds1 / odds2 -> OR ;
    sqrt( 1/mat1[1,1] + 1/mat1[1,2] + 1/mat1[2,1] + 1/mat1[2,2] ) -> log.OR.SE ;
    exp( log( OR ) - qnorm( (1 - conf.level) / 2, lower.tail = F ) * log.OR.SE ) -> OR.CI2.5 ;
    exp( log( OR ) + qnorm( (1 - conf.level) / 2, lower.tail = F ) * log.OR.SE ) -> OR.CI97.5 ;
    risk1 - risk2 -> ARR ;
    ARR / risk2 -> RRR ;
    1 / ARR -> NNT ;
    (RR -1) / RR -> ARP ;
    1 - RR -> PF ; 
    pwr::ES.h( risk1, risk2 ) -> cohenh
    
    c( risk.name, 
       group1, risk1, odds1,
       group2, risk2, odds2,
       RR, RR.CI2.5, RR.CI97.5, 
       paste0( "Based on normal approximation of log( RR ), ",
               "confidence level of: ",
               conf.level),
       log.RR.SE, 
       OR, OR.CI2.5, OR.CI97.5,
       paste0( "Based on normal approximation of log( OR ), ",
               "confidence level of: ",
               conf.level),
       log.OR.SE,
       p.value,
       cohenh,
       ARR, RRR, NNT, ARP, PF
    ) -> 
      line5 ;
    
    # line 6
    paste( name.y, colnames1[1], sep = ":" ) -> risk.name ;
    paste( name.x, rownames1[1], sep = ":" ) -> group2 ;
    mat1[1,1] / (mat1[1,1] + mat1[1,2]) -> risk2 ;
    mat1[1,1] / mat1[1,2] -> odds2 ;
    paste( name.x, rownames1[2], sep = ":" ) -> group1 ;
    mat1[2,1] / (mat1[2,1] + mat1[2,2]) -> risk1 ;
    mat1[2,1] / mat1[2,2] -> odds1 ;
    risk1 / risk2 -> RR ;
    sqrt( (1/mat1[1,1] + 1/mat1[2,1]) - (1/(mat1[1,1] + mat1[1,2]) + 1/(mat1[2,1] + mat1[2,2]) ) ) -> log.RR.SE
    exp( log( RR ) - qnorm( (1 - conf.level) / 2, lower.tail = F ) * log.RR.SE ) -> RR.CI2.5 ;
    exp( log( RR ) + qnorm( (1 - conf.level) / 2, lower.tail = F ) * log.RR.SE ) -> RR.CI97.5 ;
    odds1 / odds2 -> OR ;
    sqrt( 1/mat1[1,1] + 1/mat1[1,2] + 1/mat1[2,1] + 1/mat1[2,2] ) -> log.OR.SE ;
    exp( log( OR ) - qnorm( (1 - conf.level) / 2, lower.tail = F ) * log.OR.SE ) -> OR.CI2.5 ;
    exp( log( OR ) + qnorm( (1 - conf.level) / 2, lower.tail = F ) * log.OR.SE ) -> OR.CI97.5 ;
    risk1 - risk2 -> ARR ;
    ARR / risk2 -> RRR ;
    1 / ARR -> NNT ;
    (RR -1) / RR -> ARP ;
    1 - RR -> PF ; 
    pwr::ES.h( risk1, risk2 ) -> cohenh
    
    c( risk.name, 
       group1, risk1, odds1,
       group2, risk2, odds2,
       RR, RR.CI2.5, RR.CI97.5, 
       paste0( "Based on normal approximation of log( RR ), ",
               "confidence level of: ",
               conf.level),
       log.RR.SE, 
       OR, OR.CI2.5, OR.CI97.5,
       paste0( "Based on normal approximation of log( OR ), ",
               "confidence level of: ",
               conf.level),
       log.OR.SE,
       p.value,
       cohenh,
       ARR, RRR, NNT, ARP, PF
    ) -> 
      line6 ;
    
    # line 7
    paste( name.y, colnames1[2], sep = ":" ) -> risk.name ;
    paste( name.x, rownames1[1], sep = ":" ) -> group1 ;
    mat1[1,2] / (mat1[1,1] + mat1[1,2]) -> risk1 ;
    mat1[1,2] / mat1[1,1] -> odds1 ;
    paste( name.x, rownames1[2], sep = ":" ) -> group2 ;
    mat1[2,2] / (mat1[2,1] + mat1[2,2]) -> risk2 ;
    mat1[2,2] / mat1[2,1] -> odds2 ;
    risk1 / risk2 -> RR ;
    sqrt( (1/mat1[1,2] + 1/mat1[2,2]) - (1/(mat1[1,1] + mat1[1,2]) + 1/(mat1[2,1] + mat1[2,2]) ) ) -> log.RR.SE
    exp( log( RR ) - qnorm( (1 - conf.level) / 2, lower.tail = F ) * log.RR.SE ) -> RR.CI2.5 ;
    exp( log( RR ) + qnorm( (1 - conf.level) / 2, lower.tail = F ) * log.RR.SE ) -> RR.CI97.5 ;
    odds1 / odds2 -> OR ;
    sqrt( 1/mat1[1,1] + 1/mat1[1,2] + 1/mat1[2,1] + 1/mat1[2,2] ) -> log.OR.SE ;
    exp( log( OR ) - qnorm( (1 - conf.level) / 2, lower.tail = F ) * log.OR.SE ) -> OR.CI2.5 ;
    exp( log( OR ) + qnorm( (1 - conf.level) / 2, lower.tail = F ) * log.OR.SE ) -> OR.CI97.5 ;
    risk1 - risk2 -> ARR ;
    ARR / risk2 -> RRR ;
    1 / ARR -> NNT ;
    (RR -1) / RR -> ARP ;
    1 - RR -> PF ; 
    pwr::ES.h( risk1, risk2 ) -> cohenh
    
    c( risk.name, 
       group1, risk1, odds1,
       group2, risk2, odds2,
       RR, RR.CI2.5, RR.CI97.5, 
       paste0( "Based on normal approximation of log( RR ), ",
               "confidence level of: ",
               conf.level),
       log.RR.SE, 
       OR, OR.CI2.5, OR.CI97.5,
       paste0( "Based on normal approximation of log( OR ), ",
               "confidence level of: ",
               conf.level),
       log.OR.SE,
       p.value,
       cohenh,
       ARR, RRR, NNT, ARP, PF
    ) -> 
      line7 ;
    
    # line 8
    paste( name.y, colnames1[2], sep = ":" ) -> risk.name ;
    paste( name.x, rownames1[1], sep = ":" ) -> group2 ;
    mat1[1,2] / (mat1[1,1] + mat1[1,2]) -> risk2 ;
    mat1[1,2] / mat1[1,1] -> odds2 ;
    paste( name.x, rownames1[2], sep = ":" ) -> group1 ;
    mat1[2,2] / (mat1[2,1] + mat1[2,2]) -> risk1 ;
    mat1[2,2] / mat1[2,1] -> odds1 ;
    risk1 / risk2 -> RR ;
    sqrt( (1/mat1[1,2] + 1/mat1[2,2]) - (1/(mat1[1,1] + mat1[1,2]) + 1/(mat1[2,1] + mat1[2,2]) ) ) -> log.RR.SE
    exp( log( RR ) - qnorm( (1 - conf.level) / 2, lower.tail = F ) * log.RR.SE ) -> RR.CI2.5 ;
    exp( log( RR ) + qnorm( (1 - conf.level) / 2, lower.tail = F ) * log.RR.SE ) -> RR.CI97.5 ;
    odds1 / odds2 -> OR ;
    sqrt( 1/mat1[1,1] + 1/mat1[1,2] + 1/mat1[2,1] + 1/mat1[2,2] ) -> log.OR.SE ;
    exp( log( OR ) - qnorm( (1 - conf.level) / 2, lower.tail = F ) * log.OR.SE ) -> OR.CI2.5 ;
    exp( log( OR ) + qnorm( (1 - conf.level) / 2, lower.tail = F ) * log.OR.SE ) -> OR.CI97.5 ;
    risk1 - risk2 -> ARR ;
    ARR / risk2 -> RRR ;
    1 / ARR -> NNT ;
    (RR -1) / RR -> ARP ;
    1 - RR -> PF ; 
    pwr::ES.h( risk1, risk2 ) -> cohenh
    
    c( risk.name, 
       group1, risk1, odds1,
       group2, risk2, odds2,
       RR, RR.CI2.5, RR.CI97.5, 
       paste0( "Based on normal approximation of log( RR ), ",
               "confidence level of: ",
               conf.level),
       log.RR.SE, 
       OR, OR.CI2.5, OR.CI97.5,
       paste0( "Based on normal approximation of log( OR ), ",
               "confidence level of: ",
               conf.level),
       log.OR.SE,
       p.value,
       cohenh,
       ARR, RRR, NNT, ARP, PF
    ) -> 
      line8 ;
    
    # fusion
    data.frame( rbind( line1, line2, line3, line4, line5, line6, line7, line8 ) ) ->
      output ;
    
    c( "Risk of", 
       "In group 1", "Risk1", "Odds1", 
       "In group 2", "Risk2", "Odds2", 
       "Relative Risk", "RR CI lb", "RR CI ub", "CI method", "log(RR)'s SE", 
       "Odds Ratio", "OR CI lb", "OR CI ub", "CI method", "log(OR)'s SE",
       "Fisher's exact test p-value",
       "Cohen's h",
       "Absolute risk reduction/increase (attribuable risk)",
       "Relative risk reduction/increase", 
       "Number needed to treat/harm", 
       "Attribuable risk percent",
       "Preventive fraction" ) -> 
      colnames( output ) ;
    
    NULL -> rownames( output ) ;
    
    # Round 
    if( !is.null( round ) )
    {
      for ( a in c( "Risk1", "Odds1", 
                    "Risk2", "Odds2", 
                    "Relative Risk", "RR CI lb", "RR CI ub", "log(RR)'s SE", 
                    "Odds Ratio", "OR CI lb", "OR CI ub", "log(OR)'s SE",
                    "Cohen's h",
                    "Absolute risk reduction/increase (attribuable risk)",
                    "Relative risk reduction/increase", 
                    "Number needed to treat/harm", 
                    "Attribuable risk percent",
                    "Preventive fraction") )
      {
        round( as.numeric( as.character( output[, a ] ) ), digits = round ) ->
          output[, a ] ; 
      }
    }
    
    if( !is.null( pvalue.round ) )
    {
      round( as.numeric( as.character( output[, "Fisher's exact test p-value" ] ) ), 
             digits = pvalue.round ) ->
        output[, "Fisher's exact test p-value" ] ; 
    }
    
    # Output
    return( output )
  }
  
  fun.a <- function( a )
  {
    rbind.force( lapply( (dim(x)[2] + 1):dim(df)[2],
                         FUN = fun.b,
                         a = a ),
                 empty = "" ) -> 
      output.a
    
    return( output.a )
  }
  
  fun.b <- function( b, a )
  {
    print(a) ; print(b)
    
    # fusion of var
    df[, c( a, b ) ]  -> df.2var ;
    
    # clean NA
    if ( na.rm )
    {
      na.omit( df.2var ) -> df.2var ;
      
      if ( is.factor( df.2var[,1] ) ) { factor( df.2var[,1] ) -> df.2var[,1] ; }
      if ( is.factor( df.2var[,2] ) ) { factor( df.2var[,2] ) -> df.2var[,2] ; }
    }
    
    # primer
    NULL -> output.b
    
    # Two factors
    if ( is.factor( df.2var[,1] ) &
         is.factor( df.2var[,2] ) )
    {
      if ( nlevels( df.2var[,1] ) > 1 &
           nlevels( df.2var[,2] ) > 1 &
           all( table( df.2var[,1], df.2var[,2] ) > 2 ) )
      {
        # compute
        table( df.2var[,1], df.2var[,2] ) -> ctable1 
        prop.table( ctable1 ) -> ptable1 
        
        if (  nlevels(  df.2var[,1] ) > 2 |
              nlevels(  df.2var[,2] ) > 2 )
        {
          FALSE -> chisq.correct 
          chisq.test( df.2var[,1], df.2var[,2], correct = chisq.correct ) -> 
            chisq ;
          "none" -> gtest.correct
          DescTools::GTest( df.2var[,1], df.2var[,2], correct = gtest.correct ) -> gtest
          list( method = "Fisher not possible", p.value = NA ) -> fisher ;
        } else
        {
          Yates.correct -> chisq.correct 
          chisq.test( df.2var[,1], df.2var[,2], correct = chisq.correct ) -> 
            chisq ;
          if ( Yates.correct | Williams.correct ) 
          { 
            if ( Yates.correct) { "yates" -> gtest.correct }
            if ( Williams.correct) { "williams" -> gtest.correct }
          } else { "none" -> gtest.correct }
          DescTools::GTest( df.2var[,1], df.2var[,2], 
                            correct = gtest.correct ) -> gtest
          fisher.test( df.2var[,1], df.2var[,2], 
                       simulate.p.value = FALSE, B = nsim 
          ) -> fisher ;
        }
        
        if (Permutations)
        {
          coin::chisq_test( table( df.2var[,1], df.2var[,2] ), 
                            distribution = 
                              coin::approximate( nresample = nsim )
          ) ->
            chisq_test_perm ; 
          
          list( p.value = coin::pvalue(chisq_test_perm)[1], 
                method = paste0( "Approximative (Monte Carlo) Pearson Chi-Squared Test with ", nsim, " resamples" ),
                statistic = coin::statistic(chisq_test_perm)
          )  -> chisq.mc
        } else
        {
          list( p.value = NA, 
                method = "Permutation test not computed",
                statistic = NA
          )  -> chisq.mc
        }
        
        CramersV( df.2var[,1], df.2var[,2], na.rm = FALSE ) -> V ;
        pwr::ES.w2( ptable1 ) -> omega ;
        
        if (  min( chisq$expected ) >= 5 )
        {
          chisq$method -> method 
          chisq$p.value -> p.value 
        }
        
        if (  min( chisq$expected ) < 5 )
        {
          chisq.mc$method -> method ;
          chisq.mc$p.value -> p.value ; 
        }
        
        if (  min( chisq$expected ) >= 3 &
              Yates.correct & 
              nlevels(  df.2var[,1] ) == 2 &
              nlevels(  df.2var[,2] ) == 2 )
        {
          chisq$method -> method ;
          chisq$p.value -> p.value ; 
        }
        
        if (  min( chisq$expected ) < 5 &
              !Yates.correct & 
              nlevels(  df.2var[,1] ) == 2 &
              nlevels(  df.2var[,2] ) == 2 )
        {
          fisher$method -> method ;
          fisher$p.value -> p.value ; 
        }
        
        if (  min( chisq$expected ) < 3 &
              Yates.correct & 
              nlevels(  df.2var[,1] ) == 2 &
              nlevels(  df.2var[,2] ) == 2 )
        {
          fisher$method -> method ;
          fisher$p.value -> p.value ; 
        }
        
        # fusion
        c( "factor",
           colnames( df )[a], 
           colnames( df )[b], 
           length( df.2var[,1] ),
           length( df[,a] ) - length( df.2var[,1] ),
           p.value,
           method,
           min( chisq$expected ),
           chisq$method,
           chisq.correct,
           chisq$statistic,
           chisq$parameter,
           chisq$p.value,
           gtest$method,
           gtest.correct,
           gtest$statistic,
           gtest$parameter,
           gtest$p.value,
           fisher$method,
           fisher$p.value,
           chisq.mc$method,
           chisq.mc$statistic,
           chisq.mc$p.value,
           V,
           omega
        ) -> 
          output.b ;
        
        c( "factor", 
           "var1", "var2", 
           "N", "Missing",
           "p-value", "Method",
           "Minimal expected number",
           "Chi-squared method",
           "Yates correction",
           "Chi-squared statistic",
           "Chi-squared degree of freedom",
           "Chi-squared p-value",
           "G-test method",
           "G-test correction",
           "G statistic",
           "G-test degree of freedom",
           "G-test p-value",
           "Fisher method",
           "Fisher p-value",
           "Monte Carlo Chi-squared method",
           "Monte Carlo Chi-squared statistic",
           "Monte Carlo Chi-squared p-value",
           "Cramer's V",
           "Cohen's omega"
        ) -> 
          names( output.b ) ;
        
        # Round 
        if( !is.null( round ) )
        {
          for ( round.a in c( "Minimal expected number",
                              "Chi-squared statistic",
                              "Chi-squared degree of freedom",
                              "G statistic",
                              "G-test degree of freedom",
                              "Monte Carlo Chi-squared statistic",
                              "Cramer's V",
                              "Cohen's omega"
          ) )
          {
            round( as.numeric( as.character( output.b[ round.a ] ) ), 
                   digits = round ) ->
              output.b[ round.a ] ; 
          }
        }
        
        if( !is.null( pvalue.round ) )
        {
          for ( round.a in c( "p-value", 
                              "Chi-squared p-value",
                              "G-test p-value",
                              "Fisher p-value",
                              "Monte Carlo Chi-squared p-value"
          ) )
          {
            p.round( as.numeric( output.b[ which( names( output.b ) == 
                                                    round.a ) ] ),
                     digits = pvalue.round ) ->
              output.b[ which( names( output.b ) == round.a ) ] ; 
          }
        }
        
      }
      
    }
    
    # Two factors of two levels
    if ( is.factor( df.2var[,1] ) &
         is.factor( df.2var[,2] ) )
    {
      
      if (  nlevels( df.2var[,1] ) == 2 &
            nlevels( df.2var[,2] ) == 2 &
            all( table( df.2var[,1], df.2var[,2] ) > 2 )
      )
      {
        # compute
        Risks.Analysis( df.2var[,1], df.2var[,2], 
                        conf.level = conf.level,
                        name.x = colnames( df )[a], name.y = colnames( df )[b], 
                        round = round, pvalue.round = pvalue.round ) -> 
          RR.OR1 ;
        
        # fusion
        cbind( "OR-RR",
               colnames( df )[a], 
               colnames( df )[b], 
               length( df.2var[,1] ),
               length( df[,a] ) - length( df.2var[,1] ),
               RR.OR1
        ) -> 
          output.rr ;
        
        c( "OR-RR", "var1", "var2", "N", "Missing",
           "Risk of", 
           "In group 1", "Risk1", "Odds1", 
           "In group 2", "Risk2", "Odds2", 
           "Relative Risk", "RR CI lb", "RR CI ub", "CI method", "log(RR)'s SE", 
           "Odds Ratio", "OR CI lb", "OR CI ub", "CI method", "log(OR)'s SE",
           "Fisher's exact test p-value",
           "Cohen's h",
           "Absolute risk reduction/increase (attribuable risk)",
           "Relative risk reduction/increase", 
           "Number needed to treat/harm", 
           "Attribuable risk percent",
           "Preventive fraction" 
        ) -> 
          names( output.rr ) ;
        
        rbind.force( output.b, output.rr, empty = "" ) ->
          output.b ;
      }
      
    }
    
    # Two numerics
    if ( is.numeric( df.2var[,1] ) &
         is.numeric( df.2var[,2] ) )
    {
      if ( !all( na.omit( df.2var[,1] == df.2var[,2] ) ) &
           nlevels( factor( df.2var[,1] ) ) > 3 &
           nlevels( factor( df.2var[,2] ) ) > 3  & 
           length( df.2var[,1] ) > 7 )
      {
        # compute
        if ( length( df.2var[,1] ) < 5000 ) 
        { shapiro.test( df.2var[,1] ) -> shapiro1 ; }  else
        { list( "p.value" = NA ) -> shapiro1 ; }
        if ( length( df.2var[,1] ) < 5000 ) 
        { shapiro.test( df.2var[,2] ) -> shapiro2 ; }  else
        { list( "p.value" = NA ) -> shapiro2 ; }
        nortest::ad.test( df.2var[,1] ) -> anderson1 ;
        nortest::ad.test( df.2var[,2] ) -> anderson2 ;
        moments::jarque.test( df.2var[,1] ) -> jarque1 ;
        moments::jarque.test( df.2var[,2] ) -> jarque2 ;
        if ( any( na.omit( c( shapiro1$p.value, anderson1$p.value, jarque1$p.value,
                              shapiro2$p.value, anderson2$p.value, 
                              jarque2$p.value ) ) < 0.05 ) ) 
        { FALSE -> normal ; } else { TRUE -> normal } 
        
        cor.test( df.2var[,1], df.2var[,2], method = "pearson" ) -> pearson ;
        cor.test( df.2var[,1], df.2var[,2], method = "spearman",
                  continuity = Continuity.correct ) -> spearman ;
        cor.test( df.2var[,1], df.2var[,2], method = "kendall",
                  continuity = Continuity.correct ) -> kendall ;
        
        if (Permutations)
        {
          coin::spearman_test( df.2var[,1] ~ df.2var[,2] , 
                               distribution = 
                                 coin::approximate( nresample = nsim )
          ) ->
            spearman_test_perm ; 
          
          list( p.value = coin::pvalue(spearman_test_perm)[1], 
                method = paste0( "Approximative (Monte Carlo) Spearman Correlation Test with ", nsim, " resamples" ),
                statistic = coin::statistic(spearman_test_perm)
          )  -> pearson.mc
        } else
        {
          list( p.value = NA, 
                method = "Permutation test not computed",
                statistic = NA
          )  -> pearson.mc
        }
        
        RankBiserialCor( df.2var[,1], df.2var[,2] ) -> rbc ;
        CliffDelta( df.2var[,1], df.2var[,2] ) -> cliff ;
        
        if (normal)
        {
          pearson$p.value -> p.value ;
          pearson$method -> method ; 
        } else
        {
          spearman$p.value -> p.value ;
          spearman$method -> method ;  
        }
        
        # fusion
        c( "numeric",
           colnames( df )[a], 
           colnames( df )[b],   
           length( df.2var[,1] ),
           length( df[,a] ) - length( df.2var[,1] ),
           p.value,
           method,
           normal,
           pearson$method,
           pearson$statistic,
           pearson$parameter,
           pearson$p.value,
           spearman$method,
           Continuity.correct,
           spearman$statistic,
           spearman$p.value,
           kendall$method,
           Continuity.correct,
           kendall$statistic,
           kendall$p.value,
           pearson.mc$method,
           nsim,
           pearson.mc$statistic,
           pearson.mc$p.value,
           pearson$estimate^2,
           pearson$estimate,
           spearman$estimate,
           kendall$estimate,
           rbc,
           cliff,
           shapiro1$p.value,
           anderson1$p.value,
           jarque1$p.value,
           shapiro2$p.value,
           anderson2$p.value,
           jarque2$p.value
        ) -> 
          output.b ;
        
        c( "Class", "var1", "var2", "N", "Missing",
           "p-value", "Method",
           "var1 & var2 normal",
           "Pearson method",
           "Pearson T ratio",
           "Pearson degree of freedom",
           "Pearson p-value",
           "Spearman method",
           "Continuity correction",
           "Spearman S statistic",
           "Spearman p-value",
           "Kendall method",
           "Continuity correction",
           "Kendall Z statistic",
           "Kendall p-value",
           "Monte Carlo Spearman method",
           "Number of permutation",
           "Permutation statistic",
           "Permutation p-value",
           "R-squared coefficient of determinationt",
           "Pearson r correlation coefficient",
           "Spearman rho correlation coefficient",
           "Kendall tau correlation coefficient",
           "Rank biserial correlation coefficient",
           "Cliff's delta",
           "var1 Shapiro p-value",
           "var1 Anderson-Darling p-value",
           "var1 Jarque-Bera p-value",
           "var2 Shapiro p-value",
           "var2 Anderson-Darling p-value",
           "var2 Jarque-Bera p-value"
        ) -> names( output.b ) ;
        
        # Round 
        if( !is.null( round ) )
        {
          for ( round.a in c( "Pearson T ratio",
                              "Pearson degree of freedom",
                              "Spearman S statistic",
                              "Kendall Z statistic",
                              "Number of permutation",
                              "Permutation statistic",
                              "R-squared coefficient of determinationt",
                              "Pearson r correlation coefficient",
                              "Spearman rho correlation coefficient",
                              "Kendall tau correlation coefficient",
                              "Rank biserial correlation coefficient",
                              "Cliff's delta"
          ) )
          {
            round( as.numeric( as.character( output.b[ round.a ] ) ), 
                   digits = round ) ->
              output.b[ round.a ] ; 
          }
        }
        
        if( !is.null( pvalue.round ) )
        {
          for ( round.a in c( "p-value",
                              "Pearson p-value",
                              "Spearman p-value",
                              "Kendall p-value",
                              "Permutation p-value",
                              "var1 Shapiro p-value",
                              "var1 Anderson-Darling p-value",
                              "var1 Jarque-Bera p-value",
                              "var2 Shapiro p-value",
                              "var2 Anderson-Darling p-value",
                              "var2 Jarque-Bera p-value"
          ) )
          {
            p.round( as.numeric( output.b[ which( names( output.b ) == 
                                                    round.a ) ] ),
                     digits = pvalue.round ) ->
              output.b[ which( names( output.b ) == round.a ) ] ; 
          }
        }
      }
      
    }
    
    # One factor and one numeric, first way
    if ( is.factor( df.2var[,1] ) &
         is.numeric( df.2var[,2] )  )
    {
      if ( all( table( df.2var[,1] ) > 4 ) & 
           nlevels( df.2var[,1] ) > 1 &
           nlevels( factor( df.2var[,2] ) ) > 3  )
      {
        # compute
        lm(  df.2var[,2] ~ df.2var[,1] )$residuals -> residuals1
        if ( length( residuals1 ) < 5000 ) 
        { shapiro.test( residuals1 ) -> shapiro ; }  else
        { list( "p.value" = NA ) -> shapiro ; }
        nortest::ad.test( residuals1) -> anderson ;
        moments::jarque.test( residuals1 ) -> jarque ;
        if ( any( c( shapiro$p.value, anderson$p.value, jarque$p.value ) < 0.05 ) ) 
        { FALSE -> normal ; } else { TRUE -> normal } 
        
        bartlett.test( df.2var[,2] ~ df.2var[,1] ) -> bartlett ;
        fligner.test( df.2var[,2] ~ df.2var[,1] ) -> fligner ;
        if ( any( c( bartlett$p.value, fligner$p.value ) < 0.05 ) ) 
        { FALSE -> homoscedastik ; } else { TRUE -> homoscedastik } 
        
        oneway.test2( df.2var[,2] ~ df.2var[,1], var.equal = !Welch.correct ) -> 
          ow.anova ;
        kruskal.test( df.2var[,2] ~ df.2var[,1] ) -> kruskal ;
        
        if (Permutations)
        {
          coin::oneway_test( df.2var[,2] ~ df.2var[,1] , 
                             distribution = 
                               coin::approximate( nresample = nsim )
          ) ->
            oneway_test_perm ; 
          
          list( p.value = coin::pvalue(oneway_test_perm)[1], 
                method = paste0( "Approximative (Monte Carlo) K-Sample Fisher-Pitman Permutation Test with ", nsim, " resamples" ),
                statistic = coin::statistic(oneway_test_perm)
          )  -> ow.anova.mc
        } else
        {
          list( p.value = NA, 
                method = "Permutation test not computed",
                statistic = NA
          )  -> ow.anova.mc
        }
        
        eta.squared( df.2var[,1], df.2var[,2] ) -> eta2 ;
        summary( lm( df.2var[,2] ~ df.2var[,1] ) )$r.squared -> r2 ;
        r2 / (1 - r2) -> f2 ;
        
        if ( nlevels( df.2var[,1] ) == 2 &
             !all( na.omit( 
               df.2var[ df.2var[,1] == levels( df.2var[,1] )[1], 2] ) == 
               df.2var[ df.2var[,1] == levels( df.2var[,1] )[2], 2] 
             ) &
             nlevels( factor( 
               df.2var[ df.2var[,1] == levels( df.2var[,1] )[1], 2] 
             ) ) > 3 &
             nlevels( factor( 
               df.2var[ df.2var[,1] == levels( df.2var[,1] )[2], 2]
             ) ) > 3 )  
        {
          if ( length(  df.2var[ df.2var[,1] == levels( df.2var[,1] )[1], 2] ) < 
               5000 ) 
          { shapiro.test( df.2var[ df.2var[,1] == levels( df.2var[,1] )[1], 2] 
          ) -> shapiro1 ; }  else
          { list( "p.value" = NA ) -> shapiro1 ; }
          if ( length( df.2var[ df.2var[,1] == levels( df.2var[,1] )[2], 2] ) < 
               5000 ) 
          { shapiro.test(df.2var[ df.2var[,1] == levels( df.2var[,1] )[2], 2] ) -> shapiro2 ; }  else
          { list( "p.value" = NA ) -> shapiro2 ; }
          if ( length(  df.2var[ df.2var[,1] == levels( df.2var[,1] )[1], 2] ) > 
               7 ) 
          { nortest::ad.test(  df.2var[ df.2var[,1] == levels( df.2var[,1] )[1], 2]
          ) -> anderson1 ; } else 
          { list( "p.value" = NA ) -> anderson1 ; }
          if ( length( df.2var[ df.2var[,1] == levels( df.2var[,1] )[2], 2] ) > 
               7 ) 
          { nortest::ad.test( df.2var[ df.2var[,1] == levels( df.2var[,1] )[2], 2] 
          ) -> anderson2 ; } else 
          { list( "p.value" = NA ) -> anderson2 ; }
          moments::jarque.test(  df.2var[ df.2var[,1] == levels( df.2var[,1] )[1], 2] 
          ) -> jarque1 ;
          moments::jarque.test( df.2var[ df.2var[,1] == levels( df.2var[,1] )[2], 2]
          ) -> jarque2 ;
          if ( any( na.omit( c( shapiro1$p.value, anderson1$p.value, 
                                jarque1$p.value,
                                shapiro2$p.value, anderson2$p.value, 
                                jarque2$p.value ) ) < 0.05 ) ) 
          { FALSE -> normal ; } else { TRUE -> normal } 
          
          var.test(  df.2var[,2] ~ df.2var[,1] ) -> var1
          ansari.test( df.2var[,2] ~ df.2var[,1]  ) -> ansari1
          if ( any( c( bartlett$p.value, fligner$p.value,
                       var1$p.value, ansari1$p.value ) < 0.05 ) ) 
          { FALSE -> homoscedastik ; } else { TRUE -> homoscedastik } 
          
          t.test( df.2var[,2] ~ df.2var[,1], var.equal = !Welch.correct ) -> 
            student ;
          wilcox.test( df.2var[,2] ~ df.2var[,1], 
                       correct = Continuity.correct ) -> wilcoxon ;
          mood.test(  df.2var[,2] ~ df.2var[,1] ) -> mood
          
          
          if (Permutations)
          {
            coin::wilcox_test(df.2var[,2] ~ df.2var[,1], 
                              distribution = 
                                coin::approximate( nresample = nsim )
            ) ->
              wilcox_test_perm ; 
            
            list( p.value = coin::pvalue(wilcox_test_perm)[1], 
                  method = paste0( "Approximative (Monte Carlo) Wilcoxon-Mann-Whitney Test with ", nsim, " resamples" ),
                  statistic = coin::statistic(wilcox_test_perm)
            )  -> student.mc
          } else
          {
            list( p.value = NA, 
                  method = "Permutation test not computed",
                  statistic = NA
            )  -> student.mc
          }
          
          
          paste( levels( df.2var[,1] )[1], "->", levels( df.2var[,1] )[2]
          ) -> direction;
          r.pb( df.2var[,1], df.2var[,2] ) -> rpb ;
          CohenD( df.2var[,1], df.2var[,2] ) -> cohend ;
          HedgeGstar( df.2var[,1], df.2var[,2] ) -> hedgegstar ;
          RankBiserialCor( df.2var[ df.2var[,1] == levels( df.2var[,1] )[1], 2], 
                           df.2var[ df.2var[,1] == levels( df.2var[,1] )[2], 2] ) -> 
            rbc ;
          CliffDelta( df.2var[ df.2var[,1] == levels( df.2var[,1] )[1], 2], 
                      df.2var[ df.2var[,1] == levels( df.2var[,1] )[2], 2] ) -> cliff ;
          
          
          if ( ( normal & homoscedastik ) | 
               (normal & !homoscedastik & Welch.correct ) ) 
          {
            student$p.value -> p.final ; 
            student$method -> method.final
          }
          if ( !normal | ( !homoscedastik & !Welch.correct )  ) 
          {
            wilcoxon$p.value -> p.final ; 
            wilcoxon$method -> method.final
          }
        } else
        {
          list( "p.value" = NA ) -> shapiro1 ; 
          list( "p.value" = NA ) -> shapiro2 ; 
          list( "p.value" = NA ) -> anderson1 ; 
          list( "p.value" = NA ) -> anderson2 ; 
          list( "p.value" = NA ) -> jarque1 ; 
          list( "p.value" = NA ) -> jarque2 ; 
          list( "p.value" = NA ) -> jarque1 ; 
          list( "p.value" = NA ) -> jarque2 ; 
          list( "p.value" = NA ) -> var1 ; 
          list( "p.value" = NA ) -> ansari1 ; 
          
          list(
            method = "Test not possible beacause: more than two levels or all values equal in two groups or less than four different possible values in one of groups",
            statistic = NA,
            parameter = NA,
            p.value = NA
          ) -> student ;
          list(
            method = "Test not possible",
            statistic = NA,
            p.value = NA
          ) -> wilcoxon ;
          list(
            method = "Test not possible",
            statistic = NA,
            p.value = NA
          ) -> mood ;
          list( p.value = NA, 
                method = "Permutation test not computed",
                statistic = NA
          )  -> student.mc
          
          "" -> direction;
          NA -> rpb ;
          NA -> cohend ;
          NA -> hedgegstar ;
          NA -> rbc ;
          NA -> cliff ;
          
          if ( ( normal & homoscedastik ) | 
               (normal & !homoscedastik & Welch.correct ) ) 
          {
            ow.anova$p.value -> p.final ; 
            ow.anova$method -> method.final
          }
          if ( !normal | ( !homoscedastik & !Welch.correct )  ) 
          {
            kruskal$p.value -> p.final ; 
            kruskal$method -> method.final
          }
        }
        
        # fusion
        c( "mix",
           colnames( df )[a], 
           colnames( df )[b], 
           length( df.2var[,1] ),
           length( df[,a] ) - length( df.2var[,1] ),
           p.final,
           method.final,
           normal,
           homoscedastik,
           ow.anova$method,
           Welch.correct,
           ow.anova$statistic,
           ow.anova$parameter[1],
           ow.anova$parameter[2],
           ow.anova$p.value,
           kruskal$method,
           kruskal$statistic,
           kruskal$parameter,
           kruskal$p.value,
           ow.anova.mc$method,
           nsim,
           ow.anova.mc$statistic,
           ow.anova.mc$p.value,
           student$method,
           Welch.correct,
           student$statistic,
           student$parameter,
           student$p.value,
           wilcoxon$method,
           Continuity.correct,
           wilcoxon$statistic,
           wilcoxon$p.value,
           mood$method,
           mood$statistic,
           mood$p.value,
           student.mc$method,
           nsim,
           student.mc$statistic,
           student.mc$p.value,
           eta2,
           f2,
           direction,
           rpb,
           cohend,
           hedgegstar,
           rbc,
           cliff,
           shapiro$p.value, 
           anderson$p.value,
           jarque$p.value,
           bartlett$p.value,
           fligner$p.value,
           shapiro1$p.value,
           anderson1$p.value,
           jarque1$p.value,
           shapiro2$p.value,
           anderson2$p.value,
           jarque2$p.value,
           var1$p.value,
           ansari1$p.value
        ) -> 
          output.b ;
        
        c( "Class", "var1", "var2", "N", "Missing",
           "p-value", "Method",
           "Normality",
           "Homoscedasticity",
           "Anova method",
           "Welch correction",
           "Anova F statistic",
           "Anova degree of freedom numerator",
           "Anova degree of freedom denominator",
           "Anova p-value",
           "Kruskal-Wallis method",
           "Kruskal-Wallis chi-squared statictic",
           "Kruskal-Wallis degree of freedom",
           "Kruskal-Wallis p-value",
           "Monte Carlo Fisher-Pitman method",
           "Number of permutation",
           "Permutation Fisher-Pitman statistic",
           "Permutation Fisher-Pitman p-value",
           "Student method",
           "Welch correction",
           "Student T ratio",
           "Student degree of freedom",
           "Student p-value",
           "Wilcoxon method",
           "Continuity correction",
           "Wilcoxon W statistic",
           "Wilcoxon p-value",
           "Mood method",
           "Mood Z statistic",
           "Mood p-value",
           "Monte Carlo Wilcoxon-Mann-Whitney method",
           "Number of permutation",
           "Permutation Wilcoxon-Mann-Whitney statistic",
           "Permutation Wilcoxon-Mann-Whitney p-value",
           "Eta-squared correlation ratio",
           "Cohen's f-squared",
           "Direction for size effects",
           "Point biserial correlation coefficient r.pb",
           "Cohen's d",
           "Hedge's g*",
           "Rank biserial correlation",
           "Cliff's delta",
           "Anova residuals Shapiro p-value",
           "Anova residuals Anderson-Darling p-value",
           "Anova residuals Jarque-Bera p-value",
           "Bartlett p-value",
           "Fligner-Killeen p-value",
           "group1 Shapiro p-value",
           "group1 Anderson-Darling p-value",
           "group1 Jarque-Bera p-value",
           "group2 Shapiro p-value",
           "group2 Anderson-Darling p-value",
           "group2 Jarque-Bera p-value",
           "F-test for variances p-value",
           "Ansara-Bradley p-value"
        ) -> names( output.b ) ;
        
        # Round 
        if( !is.null( round ) )
        {
          for ( round.a in c( "Anova F statistic",
                              "Anova degree of freedom numerator",
                              "Anova degree of freedom denominator",
                              "Kruskal-Wallis chi-squared statictic",
                              "Kruskal-Wallis degree of freedom",
                              "Permutation Fisher-Pitman statistic",
                              "Student T ratio",
                              "Student degree of freedom",
                              "Wilcoxon W statistic",
                              "Mood Z statistic",
                              "Permutation Wilcoxon-Mann-Whitney statistic",
                              "Eta-squared correlation ratio",
                              "Cohen's f-squared",
                              "Point biserial correlation coefficient r.pb",
                              "Cohen's d",
                              "Hedge's g*",
                              "Rank biserial correlation",
                              "Cliff's delta"  ) )
          {
            round( as.numeric( as.character( output.b[ round.a ] ) ), 
                   digits = round ) ->
              output.b[ round.a ] ; 
          }
        }
        
        if( !is.null( pvalue.round ) )
        {
          for ( round.a in c( "p-value", 
                              "Anova p-value",
                              "Kruskal-Wallis p-value",
                              "Permutation Fisher-Pitman p-value",
                              "Student p-value",
                              "Wilcoxon p-value",
                              "Mood p-value",
                              "Permutation Wilcoxon-Mann-Whitney p-value",
                              "Anova residuals Shapiro p-value",
                              "Anova residuals Anderson-Darling p-value",
                              "Anova residuals Jarque-Bera p-value",
                              "Bartlett p-value",
                              "Fligner-Killeen p-value",
                              "group1 Shapiro p-value",
                              "group1 Anderson-Darling p-value",
                              "group1 Jarque-Bera p-value",
                              "group2 Shapiro p-value",
                              "group2 Anderson-Darling p-value",
                              "group2 Jarque-Bera p-value",
                              "F-test for variances p-value",
                              "Ansara-Bradley p-value" ) )
          {
            p.round( as.numeric( output.b[ which( names( output.b ) == 
                                                    round.a ) ] ),
                     digits = pvalue.round ) ->
              output.b[ which( names( output.b ) == round.a ) ] ; 
          }
        }
        
      }
      
    }
    
    # One factor and one numeric, second way
    if ( is.numeric(  df.2var[,1] ) &
         is.factor( df.2var[,2] ) )
    {
      if (
        all( table( df.2var[,2] ) > 4 & 
             nlevels( df.2var[,2] ) > 1 &
             nlevels( factor( df.2var[,1] ) ) > 3 )
      )
      {
        # compute
        lm(  df.2var[,1] ~ df.2var[,2] )$residuals -> residuals1
        if ( length( residuals1 ) < 5000 ) 
        { shapiro.test( residuals1 ) -> shapiro ; }  else
        { list( "p.value" = NA ) -> shapiro ; }
        nortest::ad.test( residuals1) -> anderson ;
        moments::jarque.test( residuals1 ) -> jarque ;
        if ( any( c( shapiro$p.value, anderson$p.value, jarque$p.value ) < 0.05 ) ) 
        { FALSE -> normal ; } else { TRUE -> normal } 
        
        bartlett.test( df.2var[,1] ~ df.2var[,2] ) -> bartlett ;
        fligner.test( df.2var[,1] ~ df.2var[,2] ) -> fligner ;
        if ( any( c( bartlett$p.value, fligner$p.value ) < 0.05 ) ) 
        { FALSE -> homoscedastik ; } else { TRUE -> homoscedastik } 
        
        oneway.test2( df.2var[,1] ~ df.2var[,2], var.equal = !Welch.correct ) -> 
          ow.anova ;
        kruskal.test( df.2var[,1] ~ df.2var[,2] ) -> kruskal ;
        
        if (Permutations)
        {
          coin::oneway_test( df.2var[,1] ~ df.2var[,2] , 
                             distribution = 
                               coin::approximate( nresample = nsim )
          ) ->
            oneway_test_perm ; 
          
          list( p.value = coin::pvalue(oneway_test_perm)[1], 
                method = paste0( "Approximative (Monte Carlo) K-Sample Fisher-Pitman Permutation Test with ", nsim, " resamples" ),
                statistic = coin::statistic(oneway_test_perm)
          )  -> ow.anova.mc
        } else
        {
          list( p.value = NA, 
                method = "Permutation test not computed",
                statistic = NA
          )  -> ow.anova.mc
        }
        
        eta.squared( df.2var[,2], df.2var[,1] ) -> eta2 ;
        summary( lm( df.2var[,1] ~ df.2var[,2] ) )$r.squared -> r2 ;
        r2 / (1 - r2) -> f2 ;
        
        if ( nlevels( df.2var[,2] ) == 2 &
             !all( na.omit( 
               df.2var[ df.2var[,2] == levels( df.2var[,2] )[1], 1] ) == 
               df.2var[ df.2var[,2] == levels( df.2var[,2] )[2], 1] 
             ) &
             nlevels( factor( 
               df.2var[ df.2var[,2] == levels( df.2var[,2] )[1], 1] 
             ) ) > 3 &
             nlevels( factor( 
               df.2var[ df.2var[,2] == levels( df.2var[,2] )[2], 1]
             ) ) > 3 ) 
        {
          if ( length(  df.2var[ df.2var[,2] == levels( df.2var[,2] )[1], 1] ) < 
               5000 ) 
          { shapiro.test( df.2var[ df.2var[,2] == levels( df.2var[,2] )[1], 1] 
          ) -> shapiro1 ; }  else
          { list( "p.value" = NA ) -> shapiro1 ; }
          if ( length( df.2var[ df.2var[,2] == levels( df.2var[,2] )[2], 1] ) < 
               5000 ) 
          { shapiro.test(df.2var[ df.2var[,2] == levels( df.2var[,2] )[2], 1] ) -> shapiro2 ; }  else
          { list( "p.value" = NA ) -> shapiro2 ; }
          if ( length(  df.2var[ df.2var[,2] == levels( df.2var[,2] )[1], 1] ) > 
               7 ) 
          { nortest::ad.test(  df.2var[ df.2var[,2] == levels( df.2var[,2] )[1], 1]
          ) -> anderson1 ; } else 
          { list( "p.value" = NA ) -> anderson1 ; }
          if ( length( df.2var[ df.2var[,2] == levels( df.2var[,2] )[2], 1] ) > 
               7 ) 
          { nortest::ad.test( df.2var[ df.2var[,2] == levels( df.2var[,2] )[2], 1] 
          ) -> anderson2 ; } else 
          { list( "p.value" = NA ) -> anderson2 ; }
          moments::jarque.test(  df.2var[ df.2var[,2] == levels( df.2var[,2] )[1], 1] 
          ) -> jarque1 ;
          moments::jarque.test( df.2var[ df.2var[,2] == levels( df.2var[,2] )[2], 1]
          ) -> jarque2 ;
          if ( any( na.omit( c( shapiro1$p.value, anderson1$p.value, 
                                jarque1$p.value,
                                shapiro2$p.value, anderson2$p.value, 
                                jarque2$p.value ) ) < 0.05 ) ) 
          { FALSE -> normal ; } else { TRUE -> normal } 
          
          var.test(  df.2var[,1] ~ df.2var[,2] ) -> var1
          ansari.test( df.2var[,1] ~ df.2var[,2]  ) -> ansari1
          if ( any( c( bartlett$p.value, fligner$p.value,
                       var1$p.value, ansari1$p.value ) < 0.05 ) ) 
          { FALSE -> homoscedastik ; } else { TRUE -> homoscedastik } 
          
          t.test( df.2var[,1] ~ df.2var[,2], var.equal = !Welch.correct ) -> 
            student ;
          wilcox.test( df.2var[,1] ~ df.2var[,2], 
                       correct = Continuity.correct ) -> wilcoxon ;
          mood.test(  df.2var[,1] ~ df.2var[,2] ) -> mood
          if (Permutations)
          {
            coin::wilcox_test(df.2var[,1] ~ df.2var[,2], 
                              distribution = 
                                coin::approximate( nresample = nsim )
            ) ->
              wilcox_test_perm ; 
            
            list( p.value = coin::pvalue(wilcox_test_perm)[1], 
                  method = paste0( "Approximative (Monte Carlo) Wilcoxon-Mann-Whitney Test with ", nsim, " resamples" ),
                  statistic = coin::statistic(wilcox_test_perm)
            )  -> student.mc
          } else
          {
            list( p.value = NA, 
                  method = "Permutation test not computed",
                  statistic = NA
            )  -> student.mc
          }
          
          paste( levels( df.2var[,2] )[1], "->", levels( df.2var[,2] )[2]
          ) -> direction;
          r.pb( df.2var[,2], df.2var[,1] ) -> rpb ;
          CohenD( df.2var[,2], df.2var[,1] ) -> cohend ;
          HedgeGstar( df.2var[,2], df.2var[,1] ) -> hedgegstar ;
          RankBiserialCor( df.2var[ df.2var[,2] == levels( df.2var[,2] )[1], 1], 
                           df.2var[ df.2var[,2] == levels( df.2var[,2] )[2], 1] ) -> 
            rbc ;
          CliffDelta( df.2var[ df.2var[,2] == levels( df.2var[,2] )[1], 1], 
                      df.2var[ df.2var[,2] == levels( df.2var[,2] )[2], 1] ) -> cliff ;
          
          if ( ( normal & homoscedastik ) | 
               (normal & !homoscedastik & Welch.correct ) ) 
          {
            student$p.value -> p.final ; 
            student$method -> method.final
          }
          if ( !normal | ( !homoscedastik & !Welch.correct )  ) 
          {
            wilcoxon$p.value -> p.final ; 
            wilcoxon$method -> method.final
          }
        } else
        {
          list( "p.value" = NA ) -> shapiro1 ; 
          list( "p.value" = NA ) -> shapiro2 ; 
          list( "p.value" = NA ) -> anderson1 ; 
          list( "p.value" = NA ) -> anderson2 ; 
          list( "p.value" = NA ) -> jarque1 ; 
          list( "p.value" = NA ) -> jarque2 ; 
          list( "p.value" = NA ) -> jarque1 ; 
          list( "p.value" = NA ) -> jarque2 ; 
          list( "p.value" = NA ) -> var1 ; 
          list( "p.value" = NA ) -> ansari1 ; 
          
          list(
            method = "Test not possible",
            statistic = NA,
            parameter = NA,
            p.value = NA
          ) -> student ;
          list(
            method = "Test not possible",
            statistic = NA,
            p.value = NA
          ) -> wilcoxon ;
          list(
            method = "Test not possible",
            statistic = NA,
            p.value = NA
          ) -> mood ;
          list( p.value = NA, 
                method = "Permutation test not computed",
                statistic = NA
          )  -> student.mc
          
          "" -> direction;
          NA -> rpb ;
          NA -> cohend ;
          NA -> hedgegstar ;
          NA -> rbc ;
          NA -> cliff ;
          
          if ( ( normal & homoscedastik ) | 
               (normal & !homoscedastik & Welch.correct ) ) 
          {
            ow.anova$p.value -> p.final ; 
            ow.anova$method -> method.final
          }
          if ( !normal | ( !homoscedastik & !Welch.correct )  ) 
          {
            kruskal$p.value -> p.final ; 
            kruskal$method -> method.final
          }
        }
        
        # fusion
        c( "mix",
           colnames( df )[a], 
           colnames( df )[b], 
           length( df.2var[,1] ),
           length( df[,a] ) - length( df.2var[,1] ),
           p.final,
           method.final,
           normal,
           homoscedastik,
           ow.anova$method,
           Welch.correct,
           ow.anova$statistic,
           ow.anova$parameter[1],
           ow.anova$parameter[2],
           ow.anova$p.value,
           kruskal$method,
           kruskal$statistic,
           kruskal$parameter,
           kruskal$p.value,
           ow.anova.mc$method,
           nsim,
           ow.anova.mc$statistic,
           ow.anova.mc$p.value,
           student$method,
           Welch.correct,
           student$statistic,
           student$parameter,
           student$p.value,
           wilcoxon$method,
           Continuity.correct,
           wilcoxon$statistic,
           wilcoxon$p.value,
           mood$method,
           mood$statistic,
           mood$p.value,
           student.mc$method,
           nsim,
           student.mc$statistic,
           student.mc$p.value,
           eta2,
           f2,
           direction,
           rpb,
           cohend,
           hedgegstar,
           rbc,
           cliff,
           shapiro$p.value, 
           anderson$p.value,
           jarque$p.value,
           bartlett$p.value,
           fligner$p.value,
           shapiro1$p.value,
           anderson1$p.value,
           jarque1$p.value,
           shapiro2$p.value,
           anderson2$p.value,
           jarque2$p.value,
           var1$p.value,
           ansari1$p.value
        ) -> 
          output.b ;
        
        c( "Class", "var1", "var2", "N", "Missing",
           "p-value", "Method",
           "Normality",
           "Homoscedasticity",
           "Anova method",
           "Welch correction",
           "Anova F statistic",
           "Anova degree of freedom numerator",
           "Anova degree of freedom denominator",
           "Anova p-value",
           "Kruskal-Wallis method",
           "Kruskal-Wallis chi-squared statictic",
           "Kruskal-Wallis degree of freedom",
           "Kruskal-Wallis p-value",
           "Monte Carlo Fisher-Pitman method",
           "Number of permutation",
           "Permutation Fisher-Pitman statistic",
           "Permutation Fisher-Pitman p-value",
           "Student method",
           "Welch correction",
           "Student T ratio",
           "Student degree of freedom",
           "Student p-value",
           "Wilcoxon method",
           "Continuity correction",
           "Wilcoxon W statistic",
           "Wilcoxon p-value",
           "Mood method",
           "Mood Z statistic",
           "Mood p-value",
           "Monte Carlo Wilcoxon-Mann-Whitney method",
           "Number of permutation",
           "Permutation Wilcoxon-Mann-Whitney statistic",
           "Permutation Wilcoxon-Mann-Whitney p-value",
           "Eta-squared correlation ratio",
           "Cohen's f-squared",
           "Direction for size effects",
           "Point biserial correlation coefficient r.pb",
           "Cohen's d",
           "Hedge's g*",
           "Rank biserial correlation",
           "Cliff's delta",
           "Anova residuals Shapiro p-value",
           "Anova residuals Anderson-Darling p-value",
           "Anova residuals Jarque-Bera p-value",
           "Bartlett p-value",
           "Fligner-Killeen p-value",
           "group1 Shapiro p-value",
           "group1 Anderson-Darling p-value",
           "group1 Jarque-Bera p-value",
           "group2 Shapiro p-value",
           "group2 Anderson-Darling p-value",
           "group2 Jarque-Bera p-value",
           "F-test for variances p-value",
           "Ansara-Bradley p-value"
        ) -> names( output.b ) ;
        
        # Round 
        if( !is.null( round ) )
        {
          for ( round.a in c( "Anova F statistic",
                              "Anova degree of freedom numerator",
                              "Anova degree of freedom denominator",
                              "Kruskal-Wallis chi-squared statictic",
                              "Kruskal-Wallis degree of freedom",
                              "Permutation Fisher-Pitman statistic",
                              "Student T ratio",
                              "Student degree of freedom",
                              "Wilcoxon W statistic",
                              "Mood Z statistic",
                              "Permutation Wilcoxon-Mann-Whitney statistic",
                              "Eta-squared correlation ratio",
                              "Cohen's f-squared",
                              "Point biserial correlation coefficient r.pb",
                              "Cohen's d",
                              "Hedge's g*",
                              "Rank biserial correlation",
                              "Cliff's delta"  ) )
          {
            round( as.numeric( as.character( output.b[ round.a ] ) ), 
                   digits = round ) ->
              output.b[ round.a ] ; 
          }
        }
        
        if( !is.null( pvalue.round ) )
        {
          for ( round.a in c( "p-value", 
                              "Anova p-value",
                              "Kruskal-Wallis p-value",
                              "Permutation Fisher-Pitman p-value",
                              "Student p-value",
                              "Wilcoxon p-value",
                              "Mood p-value",
                              "Permutation Wilcoxon-Mann-Whitney p-value",
                              "Anova residuals Shapiro p-value",
                              "Anova residuals Anderson-Darling p-value",
                              "Anova residuals Jarque-Bera p-value",
                              "Bartlett p-value",
                              "Fligner-Killeen p-value",
                              "group1 Shapiro p-value",
                              "group1 Anderson-Darling p-value",
                              "group1 Jarque-Bera p-value",
                              "group2 Shapiro p-value",
                              "group2 Anderson-Darling p-value",
                              "group2 Jarque-Bera p-value",
                              "F-test for variances p-value",
                              "Ansara-Bradley p-value" ) )
          {
            p.round( as.numeric( output.b[ which( names( output.b ) == 
                                                    round.a ) ] ),
                     digits = pvalue.round ) ->
              output.b[ which( names( output.b ) == round.a ) ] ; 
          }
        }
        
      }
      
    }
    
    # No test possible
    if ( is.null( output.b ) )
    {
      # tests
      !( ( is.factor( df.2var[,1] ) |
             is.numeric( df.2var[,1] ) ) &
           ( is.factor( df.2var[,2] ) |
               is.numeric( df.2var[,2] ) ) ) -> notnumfact
      
      if ( is.factor( df.2var[,1] ) )
      {
        !( nlevels( df.2var[,1] ) > 1 ) -> isfactor.v1
      } else
      {
        "-" -> isfactor.v1
      }
      
      if ( is.factor( df.2var[,2] ) )
      {
        !( nlevels( df.2var[,2] ) > 1 ) -> isfactor.v2
      } else
      {
        "-" -> isfactor.v2
      }
      
      if ( is.numeric( df.2var[,1] ) )
      {
        !( nlevels( factor( df.2var[,1] ) ) > 3 ) -> less4numeric.v1
      } else
      {
        "-" -> less4numeric.v1
      }
      
      if ( is.numeric( df.2var[,2] ) )
      {
        !( nlevels( factor( df.2var[,2] ) ) > 3 ) -> less4numeric.v2
      } else
      {
        "-" -> less4numeric.v2
      }
      
      if ( is.factor( df.2var[,1] ) &
           is.factor( df.2var[,2] ) )
      {
        !all( table( df.2var[,1], df.2var[,2] ) > 2 ) -> contingencytab3
      } else
      {
        "-" -> contingencytab3
      }
      
      if ( ( is.numeric( df.2var[,1] ) &
             is.factor( df.2var[,2] ) ) |
           (  is.factor( df.2var[,1] ) &
              is.numeric( df.2var[,2] ) ) )
      {
        if ( is.factor( df.2var[,1] ) )
        { !all( table( df.2var[,1] ) > 4 ) -> less5 }   
        if ( is.factor( df.2var[,2] ) )
        { !all( table( df.2var[,2] ) > 4 ) -> less5 }
      } else
      {
        "-" -> less5
      }
      
      if ( is.numeric( df.2var[,1] ) &
           is.numeric( df.2var[,2] ) )
      {
        all( na.omit( df.2var[,1] == df.2var[,2] ) ) -> equal.num
        !( length( df.2var[,1] ) > 7  ) -> less8num
        
      } else
      {
        "-" -> equal.num
        "-" -> less8num
      }
      
      # fusion
      c( "other", 
         colnames( df )[a], 
         colnames( df )[b], 
         length( df.2var[,1] ),
         length( df[,a] ) - length( df.2var[,1] ),
         class( df.2var[,1] ),
         class( df.2var[,2] ),
         "No test because:",
         notnumfact, 
         isfactor.v1,
         isfactor.v2,
         less4numeric.v1,
         less4numeric.v2,
         contingencytab3,
         less5,
         equal.num,
         less8num
      ) -> output.b
      
      c( "Class", 
         "var1", "var2", 
         "N", "Missing",
         "class var 1",
         "class var 2",
         "No test because:", 
         "Is not factor or numeric",
         "Just 1 level for factor (var1)",
         "Just 1 level for factor (var2)",
         "Less than 4 different values for numeric (var1)", 
         "Less than 4 different values for numeric (var2)", 
         "Less than 3 observations for each cells (2 factors)",
         "Less than 5 observations by level (1 numeric & 1 factor)",
         "Identical variables (2 numerics)",
         "Less than 8 observations (2 numerics)"
      ) -> 
        names( output.b ) 
    }
    
    return( output.b ) ;
  }
  
  # activate packages
  download.packages(  "furrr", "pwr", "moments", "nortest", "DescTools", "coin" ) 
  
  # Merge tables 
  merge( x, y, by = by, by.x = by.x, by.y = by.y ) -> df ; 
  
  # Job
  furrr::future_map(
    1:dim(x)[2],
    fun.a,
    .options = furrr::furrr_options( seed = seed ), .progress = T 
  ) |>  
    rbind.force( empty = "" )  ->
    output ;
  
  # prepare output
  c( "factor", 
     "var1", "var2", 
     "N", "Missing",
     "p-value", "Method",
     "Minimal expected number",
     "Chi-squared method",
     "Yates correction",
     "Chi-squared statistic",
     "Chi-squared degree of freedom",
     "Chi-squared p-value",
     "G-test method",
     "G-test correction",
     "G statistic",
     "G-test degree of freedom",
     "G-test p-value",
     "Fisher method",
     "Fisher p-value",
     "Monte Carlo Chi-squared method",
     "Monte Carlo Chi-squared statistic",
     "Monte Carlo Chi-squared p-value",
     "Cramer's V",
     "Cohen's omega"
  ) -> titles.factor
  
  c( "Class", "var1", "var2", "N", "Missing",
     "p-value", "Method",
     "var1 & var2 normal",
     "Pearson method",
     "Pearson T ratio",
     "Pearson degree of freedom",
     "Pearson p-value",
     "Spearman method",
     "Continuity correction",
     "Spearman S statistic",
     "Spearman p-value",
     "Kendall method",
     "Continuity correction",
     "Kendall Z statistic",
     "Kendall p-value",
     "Monte Carlo Spearman method",
     "Number of permutation",
     "Permutation statistic",
     "Permutation p-value",
     "R-squared coefficient of determinationt",
     "Pearson r correlation coefficient",
     "Spearman rho correlation coefficient",
     "Kendall tau correlation coefficient",
     "Rank biserial correlation coefficient",
     "Cliff's delta",
     "var1 Shapiro p-value",
     "var1 Anderson-Darling p-value",
     "var1 Jarque-Bera p-value",
     "var2 Shapiro p-value",
     "var2 Anderson-Darling p-value",
     "var2 Jarque-Bera p-value"
  ) -> tittles.numeric 
  
  c( "Class", "var1", "var2", "N", "Missing",
     "p-value", "Method",
     "Normality",
     "Homoscedasticity",
     "Anova method",
     "Welch correction",
     "Anova F statistic",
     "Anova degree of freedom numerator",
     "Anova degree of freedom denominator",
     "Anova p-value",
     "Kruskal-Wallis method",
     "Kruskal-Wallis chi-squared statictic",
     "Kruskal-Wallis degree of freedom",
     "Kruskal-Wallis p-value",
     "Monte Carlo Fisher-Pitman method",
     "Number of permutation",
     "Permutation Fisher-Pitman statistic",
     "Permutation Fisher-Pitman p-value",
     "Student method",
     "Welch correction",
     "Student T ratio",
     "Student degree of freedom",
     "Student p-value",
     "Wilcoxon method",
     "Continuity correction",
     "Wilcoxon W statistic",
     "Wilcoxon p-value",
     "Mood method",
     "Mood Z statistic",
     "Mood p-value",
     "Monte Carlo Wilcoxon-Mann-Whitney method",
     "Number of permutation",
     "Permutation Wilcoxon-Mann-Whitney statistic",
     "Permutation Wilcoxon-Mann-Whitney p-value",
     "Eta-squared correlation ratio",
     "Cohen's f-squared",
     "Direction for size effects",
     "Point biserial correlation coefficient r.pb",
     "Cohen's d",
     "Hedge's g*",
     "Rank biserial correlation",
     "Cliff's delta",
     "Anova residuals Shapiro p-value",
     "Anova residuals Anderson-Darling p-value",
     "Anova residuals Jarque-Bera p-value",
     "Bartlett p-value",
     "Fligner-Killeen p-value",
     "group1 Shapiro p-value",
     "group1 Anderson-Darling p-value",
     "group1 Jarque-Bera p-value",
     "group2 Shapiro p-value",
     "group2 Anderson-Darling p-value",
     "group2 Jarque-Bera p-value",
     "F-test for variances p-value",
     "Ansara-Bradley p-value"
  ) -> titles.mix
  
  c( "Class", "var1", "var2", "N", "Missing",
     "Risk of", 
     "In group 1", "Risk1", "Odds1", 
     "In group 2", "Risk2", "Odds2", 
     "Relative Risk", "RR CI lb", "RR CI ub", "CI method", "log(RR)'s SE", 
     "Odds Ratio", "OR CI lb", "OR CI ub", "CI method", "log(OR)'s SE",
     "Fisher's exact test p-value",
     "Cohen's h",
     "Absolute risk reduction/increase (attribuable risk)",
     "Relative risk reduction/increase", 
     "Number needed to treat/harm", 
     "Attribuable risk percent",
     "Preventive fraction" 
  ) -> titles.orrr
  
  c( "Class", 
     "var1", "var2", 
     "N", "Missing",
     "class var 1",
     "class var 2",
     "No test because:", 
     "Is not factor or numeric",
     "Just 1 level for factor (var1)",
     "Just 1 level for factor (var2)",
     "Less than 4 different values for numeric (var1)", 
     "Less than 4 different values for numeric (var2)", 
     "Less than 3 observations for each cells (2 factors)",
     "Less than 5 observations by level (1 numeric & 1 factor)",
     "Identical variables (2 numerics)",
     "Less than 8 observations (2 numerics)"
  ) -> titles.other
  
  NULL -> output.tmp
  for ( i in levels( factor( output[,1] ) ) )
  {
    if ( grepl( "factor", i ) )
    {
      rbind.force( output.tmp,
                   titles.factor,
                   output[ output[,1] == i, ],
                   empty = "" ) ->
        output.tmp ; 
    }
    
    if ( grepl( "numeric", i ) )
    {
      rbind.force( output.tmp,
                   tittles.numeric,
                   output[ output[,1] == i, ],
                   empty = "" ) ->
        output.tmp ; 
    }
    
    if ( grepl( "mix", i ) )
    {
      rbind.force( output.tmp,
                   titles.mix,
                   output[ output[,1] == i, ],
                   empty = "" ) ->
        output.tmp ; 
    }
    
    if ( grepl( "OR-RR", i ) )
    {
      rbind.force( output.tmp,
                   titles.orrr,
                   output[ output[,1] == i, ],
                   empty = "" ) ->
        output.tmp ; 
    }
    
    if ( grepl( "other", i ) )
    {
      rbind.force( output.tmp,
                   titles.other,
                   output[ output[,1] == i, ],
                   empty = "" ) ->
        output.tmp ; 
    }
    
  }
  output.tmp -> output
  
  if ( remove.x.y )
  { 
    gsub( ".x", "", output[,2] ) -> output[,2] ; 
    gsub( ".y", "", output[,3] ) -> output[,3] ;
  }
  
  c( "Class", "var1/DV", "var2/IV", 
     paste( rep( "col", 23), 4:dim( output )[2], sep = "" ) ) ->         
    colnames( output ) ;
  
  # end parallel
  future::plan("sequential")
  
  return( output ) 
}

# 1.2.14 Function to perform univariate and bivaraite analysis
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

UniAndBiVariate.Analysis.OnGroups  <- function( data, groups,
                                                na.rm = TRUE,
                                                conf.level = 0.95, 
                                                binom.ci.method = "exact",
                                                boot.ci.method = "bca",
                                                nsim = 10000, 
                                                seed = 123,
                                                Welch.correct = TRUE,
                                                Yates.correct = TRUE,
                                                Williams.correct = TRUE,
                                                Continuity.correct = TRUE,
                                                Permutations = FALSE,
                                                pvalue.round = NULL,
                                                round = NULL,
                                                ncores = NULL )

{ 
  # Conditions for input
  if ( !is.data.frame( data ) ) { stop( "data is not a data.frame" );   } ;
  if ( !is.character( groups ) ) { stop( "groups is not character" );    } ;
  if ( !is.logical( na.rm ) ) { stop( "na.rm is not TRUE or FALSE" );    } ;
  if ( !is.numeric( conf.level ) ) { stop( "conf.level is not numeric" );    } ;
  if ( !is.character( binom.ci.method ) ) 
  { stop( "binom.ci.method is not character" );    } ;
  if ( !binom.ci.method %in% c("exact", "ac", "asymptotic", "wilson", "prop.test", "bayes", "logit", "cloglog", "probit") ) 
  { stop( "binom.ci.method is not in exact, ac, asymptotic, wilson, prop.test, bayes, logit, cloglog, probit, see binom::binnom.confint()" );    } ;
  if ( !is.character( boot.ci.method ) ) 
  { stop( "boot.ci.method is not character" );    } ;
  if ( !boot.ci.method %in% c("norm", "basic", "stud", "perc", "bca") ) 
  { stop( "boot.ci.method is not in norm, basic, stud, perc, bca, see boot::boot.ci()" );    } ;
  if ( !is.numeric( nsim ) ) { stop( "nsim is not numeric" ) } 
  else { if ( nsim != round( nsim ) ) { stop( "nsim is not integer" ) } }
  if ( !is.numeric( seed ) ) { stop( "nsim is not numeric" ) } 
  else { if ( seed != round( seed ) ) { stop( "seed is not integer" ) } }
  if ( !is.logical( Welch.correct ) ) { stop( "Welch.correct is not TRUE or FALSE" );    } ;
  if ( !is.logical( Yates.correct ) ) { stop( "Yates.correct is not TRUE or FALSE" );    } ;
  if ( !is.logical( Continuity.correct ) ) { stop( "Continuity.correct is not TRUE or FALSE" );    } ;
  if ( !is.logical( Permutations ) ) { stop( "Permutations is not TRUE or FALSE" );    } ;
  if ( !( is.numeric( pvalue.round ) | 
          is.null( pvalue.round ) ) ) { stop( "pvalue.round is neither numeric, neither NULL" );    } ;
  if ( !( is.numeric( round ) | 
          is.null( round ) ) ) { stop( "round is neither numeric, neither NULL" );    } ;
  if ( !is.null(ncores) & !is.numeric(ncores) ) { stop( "ncores is not null nor numeric" ) }
  
  for ( a in groups)
  {
    if ( !(a %in% colnames( data ) ) ) { stop( "groups is not in data"  );    } ;
  }
  # parallel
  if ( !is.null( ncores ) ) { future::plan( "multisession",  workers = ncores ) }

  
  # function definition
  download.packages <- function( PackagesNames, ... )
  {
    # Get a vector with packages names 
    packages1 <- c( PackagesNames, ... ) ;
    
    # Install packages
    for (a in 1:length( packages1 ) )
    {
      try( find.package( packages1[a]), silent = TRUE ) -> test ;
      
      if ( class( test ) == "try-error" )
      { print( packages1[a] ) ; 
        install.packages(  packages1[a] ) ;
      } 
    }
  } ;
  
  rbind.force <- function( data, ..., keep.col = FALSE, empty = NA ) 
  {
    # Unify data
    list( data, ... ) -> input ;
    
    # include list elements
    repeat 
    {
      if (  !any( unlist( lapply( input, class ) ) == "list" ) ) { break }  
      
      which( unlist( lapply( input, class ) ) == "list" )[1] -> a ;
      input[[a]] -> tmp ;
      input[[a]] <- NA ;
      c( input[1:a],  tmp, input[ (a + 1):length( input ) ] ) -> 
        input ;
    }
    
    input[ !is.na( input ) ] ->
      input ;
    
    # delete NULL data and transformt vector in data.frame
    for ( a in 1:length( input ) )
    {
      if ( is.null( dim( input[[a]] ) ) )
      {
        if ( is.null( input[[a]] ) )
        {
          input[[a]] <- NA ;
        } else
        {
          data.frame( matrix( input[[a]], nrow = 1 ),
                      stringsAsFactors = FALSE ) -> input[[a]] ; 
        }
      }
      
      if ( all( dim( input[[a]] ) == 0 ) )
      {
        input[[a]] <- NA ;
      }
    }
    
    input[ !is.na( input ) ] ->
      input ;
    
    # test data class
    if ( !all( unlist( lapply( input, is.data.frame ) ) |
               unlist( lapply( input, is.matrix ) ) |
               unlist( lapply( input, is.vector ) ) ) )
    { stop( "Some argument are not data.frame, neither vector" ) ;
      ; } ;
    
    # Set primer
    input[[1]] -> output ; 
    
    # job in case we keep columns 
    if ( keep.col & length( input ) >1 )
    {
      for ( a in 2:length( input ) )
      { 
        output -> x ;
        input[[a]] -> y ; 
        
        for (a in 1:dim(x)[2]) { x[,a] <- as.character(x[,a])}
        for (a in 1:dim(y)[2]) { y[,a] <- as.character(y[,a])}
        
        x.diff <- setdiff(colnames(x), colnames(y))
        y.diff <- setdiff(colnames(y), colnames(x))
        
        if( dim(x)[1] > 0 ) { x[, c(as.character(y.diff))] <- empty ; }
        if( dim(y)[1] > 0 ) { y[, c(as.character(x.diff))] <- empty ; }
        
        rbind(x, y) -> output ;
      } 
    }
    
    # job in case we do not keep columns
    if ( !keep.col & length( input ) >1 )
    {
      for ( a in 2:length( input ) )
      { 
        output -> x ;
        input[[a]] -> y ; 
        
        colnames(x) <- paste( "X",
                              1:dim( x )[2], 
                              sep = "" ) ;
        colnames(y) <- paste( "X",
                              1:dim( y )[2], 
                              sep = "" ) ;
        
        for (a in 1:dim(x)[2]) { x[,a] <- as.character(x[,a])}
        for (a in 1:dim(y)[2]) { y[,a] <- as.character(y[,a])}
        
        x.diff <- setdiff(colnames(x), colnames(y))
        y.diff <- setdiff(colnames(y), colnames(x))
        
        if( dim(x)[1] > 0 ) { x[, c(as.character(y.diff))] <- empty ; }
        if( dim(y)[1] > 0 ) { y[, c(as.character(x.diff))] <- empty ; }
        
        rbind(x, y) -> output ;
      } 
    }
    
    return( output ) ;
  } 
  
  cbind.force <- function( data, ... , keep.row = FALSE, empty = NA ) 
  {
    # Unify data
    list( data, ... ) -> input ;
    
    # include list elements
    repeat 
    {
      if (  !any( unlist( lapply( input, class ) ) == "list" ) ) { break }  
      
      which( unlist( lapply( input, class ) ) == "list" )[1] -> a ;
      input[[a]] -> tmp ;
      input[[a]] <- NA ;
      c( input[1:a],  tmp, input[ (a + 1):length( input ) ] ) -> 
        input ;
    }
    
    input[ !is.na( input ) ] ->
      input ;
    
    # delete NULL data and transform vector in data.frame
    for ( a in 1:length( input ) )
    {
      if ( is.null( dim( input[[a]] ) ) )
      {
        if ( is.null( input[[a]] ) )
        {
          input[[a]] <- NA ;
        } else
        {
          data.frame( input[[a]],
                      stringsAsFactors = FALSE ) -> input[[a]] ; 
          "vector" -> colnames(  input[[a]] ) ;
        }
      }
      
      if ( all( dim( input[[a]] ) == 0 ) )
      {
        input[[a]] <- NA ;
      }
    }
    
    input[ !is.na( input ) ] ->
      input ;
    
    # test data class
    if ( !all( unlist( lapply( input, is.data.frame ) ) |
               unlist( lapply( input, is.matrix ) ) |
               unlist( lapply( input, is.vector ) ) ) )
    { stop( "Some argument are not data.frame, neither vector" ) ;
      ; } ;
    
    # Set primer
    input[[1]] -> output ; 
    
    # job in case we keep columns 
    if ( keep.row & length( input ) > 1 )
    {
      for ( a in 2:length( input ) )
      { 
        output -> x ;
        input[[a]] -> y ; 
        
        for (a in 1:dim(x)[2]) { x[,a] <- as.character(x[,a])}
        for (a in 1:dim(y)[2]) { y[,a] <- as.character(y[,a])}
        
        x.diff <- setdiff(rownames(x), rownames(y))
        y.diff <- setdiff(rownames(y), rownames(x))
        
        if( dim(x)[2] > 0 ) { x[ c(as.character(y.diff)), ] <- empty ; }
        if( dim(y)[2] > 0 ) { y[ c(as.character(x.diff)), ] <- empty ; }
        
        cbind(x, y) -> output ;
      } 
    }
    
    # job in case we do not keep columns
    if ( !keep.row & length( input ) > 1 )
    {
      for ( a in 2:length( input ) )
      { 
        output -> x ;
        input[[a]] -> y ; 
        
        rownames(x) <- paste( "X",
                              1:dim( x )[1], 
                              sep = "" ) ;
        rownames(y) <- paste( "X",
                              1:dim( y )[1], 
                              sep = "" ) ;
        
        for (a in 1:dim(x)[2]) { x[,a] <- as.character(x[,a])}
        for (a in 1:dim(y)[2]) { y[,a] <- as.character(y[,a])}
        
        x.diff <- setdiff(rownames(x), rownames(y))
        y.diff <- setdiff(rownames(y), rownames(x))
        
        if( dim(x)[2] > 0 ) { x[ c(as.character(y.diff)), ] <- empty ; }
        if( dim(y)[2] > 0 ) { y[ c(as.character(x.diff)), ] <- empty ; }
        
        cbind(x, y) -> output ;
      } 
    }
    
    return( output ) ;
  } ;
  
  StringContatener <- function( vector, separator )
  {   
    # exclude NA
    na.omit( vector ) -> vector ;
    
    # selection of length for loop
    if ( length( vector ) >= 2) 
    { 
      # stock fisrt element
      tmp.val1 <- vector[1] ;
      
      # loop to concatenate the nect elements
      for ( a in 2:length( vector ) ) 
      { 
        tmp.val1 <- paste( tmp.val1, vector[a], sep = separator ) ; 
      } ;
    } 
    else
    {
      tmp.val1 <- vector ;
    } ;
    
    return( tmp.val1 ) ;
  } ;
  
  fun.univariate <- function( num.group.level,
                              variable,
                              group )
  {
    # domestic functions 
    CImean.boot <- function( vector, level = conf.level, nsim = nsim, 
                             boot.ci.method = boot.ci.method )
    {
      # domestic functions 
      # function for bootstrap mean
      mean.boot <- function( x, a) 
      { 
        mean( x[a] ) -> m ;
        length(a) -> n ;
        (n-1) * var( x[a] ) / (n^2) -> v ;
        return( c( m, v ) )
      } 
      
      # job  
      boot::boot( vector, statistic = mean.boot, R = nsim ) -> tmp1 ;
      boot::boot.ci( tmp1, conf = level, type = boot.ci.method ) -> tmp2 ;
      
      tmp2[[4]][ (length( tmp2[[4]] ) - 1):length( tmp2[[4]] ) ] -> ci ;
      
      return( ci ) ;
    } ;
    
    # prepare data 
    data.frame( var = variable,
                grp = group,
                stringsAsFactors = FALSE ) ->
      df
    
    levels( group )[num.group.level] -> level.grp ;
    
    base::subset( df, grp == level.grp, select = var )[,1] -> var ;
    
    # seed
    set.seed( seed ) ;
    
    # primer
    NULL -> output ;
    
    # factor
    if ( is.factor( var ) & length( var ) > 0 )
    {
      # remake factor 
      factor( var ) -> var ;
      
      # for each levels
      fun.lvl <- function( i, var,
                           conf.level = 0.95, 
                           binom.ci.method = "exact",
                           round = NULL )
      {
        # preparation
        levels( var )[i] -> tmp.level ;
        binom::binom.confint( length( var[ var == tmp.level ] ), 
                       length( var ), 
                       conf.level = conf.level, 
                       methods = binom.ci.method )[5:6] ->
          tmp.ci ;
        
        # job
        if ( !is.null( round ) ) 
        {
          c( " ",
             "-",
             tmp.level,
             round( length( var[ var == tmp.level ] ) / length( var ) * 100, 
                    digits = round ), 
             round( tmp.ci[1,1] * 100, 
                    digits = round ), 
             round( tmp.ci[1,2] * 100, digits = round ),
             binom.ci.method,
             length( var[ var == tmp.level ] )
          ) ->
            output.lvl ;
        } else
        {
          c( " ",
             "-",
             tmp.level,
             length( var[ var == tmp.level ] ) / length( var ) * 100, 
             tmp.ci[1,1] * 100, 
             tmp.ci[1,2] * 100,
             binom.ci.method,
             length( var[ var == tmp.level ] )
          ) ->
            output.lvl ;
        }
        
        return( output.lvl ) ;
      }
      
      rbind.force( c( "  ", length( var ) ),
                   lapply( 1:nlevels( var ),
                           fun.lvl,
                           var = var,
                           conf.level = conf.level, 
                           binom.ci.method = binom.ci.method,
                           round = round ),
                   empty = "" ) -> 
        output ;
    }
    
    # numeric 
    if ( is.numeric( var ) & 
         length( var ) > 0 & 
         nlevels( factor( as.character( var ) ) ) > 1 )
    {
      if ( length( var ) >= 1000 )
      {
        t.test( var, conf.level = conf.level )$conf.int -> cistudent1 ;
        ci1 <- cistudent1[1] ;
        ci2 <- cistudent1[2] ;
        type <- "Student" ;
      } else
      { 
        CImean.boot( var, level = conf.level, nsim = nsim, 
                     boot.ci.method = boot.ci.method ) -> ciboot1 ;
        ci1 <- ciboot1[1] ;
        ci2 <- ciboot1[2] ;
        type <- paste( "bootstrap", boot.ci.method, sep = "." ) ;
      }
      
      # job
      if (!is.null( round ) )
      {
        c( " ",
           length( var ), 
           "-",
           round( mean( var ), 
                  digits = round ), 
           round( ci1, 
                  digits = round ), 
           round( ci2, 
                  digits = round ),
           type,
           round( sd( var ), 
                  digits = round )
        ) ->
          output ;
      } else
      {
        c( " ", 
           length( var ), 
           "-", 
           mean( var ), 
           ci1, 
           ci2, 
           type,
           sd( var )
        ) ->
          output ;
      }
    }
    
    # Numeric var with only 1 possible value
    if ( is.numeric( var ) & 
         length( var ) > 0 & 
         nlevels( factor( as.character( var ) ) ) == 1 )
    {
      c(  "_",
          length( var ), 
          "-",
          "only 1",  "value:", 
          "", "", "" ) ->
        output ;
    } 
    
    # Var with 0 obs
    if ( length( var ) == 0 )
    {
      c( "_",
         length( var ), 
         "-",
         "has", "no", "observation", "", "" ) ->
        output ;
    } 
    
    # Not supported
    if ( is.null( output ) )
    {
      c( "_",
         length( var ), "-",
         "Class",
         "not",
         "supported", "", "" ) ->
        output ;
    } 
    
    # formating
    if ( is.null( dim( output ) ) )
    {
      data.frame( matrix( output,
                          nrow = 1),
                  stringsAsFactors = TRUE ) ->
        output ;
    }
    
    return( output )
  }
  
  fun.bivariate <- function( df.2var, df, a, b )
  {
    # domestic function
    p.round <- function( data, digits = 3 )
    {
      if (digits == 1)
      { "" -> tmp1 ; } else 
      { rep( "0", digits - 1 ) -> tmp1 ; }
      
      "0." -> tmp2 ;
      for( a in 1:length(tmp1) )
      {
        paste( tmp2, tmp1[a], sep = "" ) -> tmp2 ;
      }
      
      paste( tmp2, "1", sep = "" ) -> pval ;
      
      for ( a in 1:length(data) )
      {
        if ( !is.na( data[a] ) )
        {
          if ( data[a] >= as.numeric( pval ) )
          {
            round( data[a], digits = digits ) -> data[a] ;
          }
        }
      }
      
      data[ data < as.numeric( pval ) ] <- paste( "< ", pval, sep = "" ) ;
      
      return( data ) ;
    }
    
    CramersV <- function( x, y, na.rm = TRUE )
    {
      if ( na.rm ) 
      {
        na.omit( data.frame( x, y ) ) -> df ;
        df$x -> x ;
        df$y -> y ;  
      }
      
      ftable( x, y ) -> cont.table ;
      
      chisq.test( cont.table )$statistic -> X2 ;
      
      ( X2 / ( length( x ) * ( min( nrow( cont.table ), ncol( cont.table ) ) - 1 ) ) 
      ) -> V2 ;
      
      sqrt( V2 ) -> V
      "Cramer's V"-> names( V ) ;
      
      return( V )   
    } 
    
    eta.squared <- function( x, y )
    {
      if ( !is.factor( x ) ) { stop( "x is not factor" );   } ;
      if ( !is.numeric( y ) ) { stop( "y is not numeric" );   } ;
      
      means <- tapply( y, INDEX = x, FUN = mean ) ;
      samples <- tapply( y, INDEX = x, FUN = length ) ;
      varinter <- sum( samples * ( means - mean( y ) )^2 ) / length( y ) ;
      vartot <- var( y ) ;
      
      return( varinter / vartot ) ;
    };
    
    r.pb <- function( x, y )
    {
      if ( !is.factor( x ) ) { stop( "x is not factor" );   } ;
      if ( !is.numeric( y ) ) { stop( "y is not numeric" );   } ;
      
      sd <- sqrt( sum( (y - mean(y) )^2 ) / (length(y) - 1) ) ;
      means <- tapply( y, INDEX = x, FUN = mean ) ;
      lengths <- tapply( y, INDEX = x, FUN = length ) ;
      
      ( (means[2] - means[1]) / sd ) * sqrt( (lengths[1] * lengths[2]) / 
                                               (length(y) * (length(y) - 1)) )
    }
    
    CohenD <- function( x, y )
    {
      if ( !is.factor( x ) ) { stop( "x is not factor" );   } ;
      if ( !is.numeric( y ) ) { stop( "y is not numeric" );   } ;
      
      SCEs <- tapply( y, INDEX = x, FUN = function(a){sum( (a - mean(a) )^2 ) / (length(a) - 1) } ) ;
      lengths <- tapply( y, INDEX = x, FUN = length ) ;
      
      means <- tapply( y, INDEX = x, FUN = mean ) ;
      
      s <- sqrt( ( (lengths[1] - 1) * SCEs[1] + (lengths[2] - 1) * SCEs[2] ) / 
                   (lengths[1] + lengths[2] - 2) ) ;
      
      (means[2] - means[1]) / s
    }
    
    HedgeGstar <- function( x, y )
    {
      if ( !is.factor( x ) ) { stop( "x is not factor" );   } ;
      if ( !is.numeric( y ) ) { stop( "y is not numeric" );   } ;
      
      SCEs <- tapply( y, INDEX = x, FUN = function(a){sum( (a - mean(a) )^2 ) / (length(a) - 1) } ) ;
      lengths <- tapply( y, INDEX = x, FUN = length ) ;
      means <- tapply( y, INDEX = x, FUN = mean ) ;
      
      s <- sqrt( ( (lengths[1] - 1) * SCEs[1] + (lengths[2] - 1) * SCEs[2] ) / 
                   (lengths[1] + lengths[2] - 2) ) ;
      
      (means[2] - means[1]) / s -> g
      
      (1 - (3 / (4 * (lengths[1] + lengths[2]) - 9) ) ) * g 
    }
    
    CliffDelta <- function( x, y )
    {
      if ( !is.numeric( x ) ) { stop( "x is not numeric" );   } ;
      if ( !is.numeric( y ) ) { stop( "y is not numeric" );   } ;
      
      wilcox.test( x, y )$statistic -> W ;
      
      2 * W / ( length(x) * length(y) ) - 1 
    }
    
    RankBiserialCor <- function( x, y )
    {
      if ( !is.numeric( x ) ) { stop( "x is not numeric" );   } ;
      if ( !is.numeric( y ) ) { stop( "y is not numeric" );   } ;
      
      wilcox.test( x, y )$statistic -> W ;
      
      1 - 2 * W / ( length(x) * length(y) )
    }
    
    oneway.test2 <- function(formula, data, subset, 
                             na.action, var.equal = FALSE)
    {
      if (missing(formula) || (length(formula) != 3L)) 
        stop("'formula' missing or incorrect")
      dp <- as.character.default(formula)
      if (length(dp) != 3L) 
        stop("a two-sided formula is required")
      DNAME <- paste(dp[[2L]], "and", dp[[3L]])
      m <- match.call(expand.dots = FALSE)
      if (is.matrix(eval(m$data, parent.frame()))) 
        m$data <- as.data.frame(data)
      m$var.equal <- NULL
      m[[1L]] <- quote(stats::model.frame)
      mf <- eval(m, parent.frame())
      response <- attr(attr(mf, "terms"), "response")
      y <- mf[[response]]
      if (length(mf[-response]) > 1L) 
        g <- factor(do.call("interaction", mf[-response]))
      else g <- factor(mf[[-response]])
      k <- nlevels(g)
      if (k < 2L) 
        stop("not enough groups")
      n.i <- tapply(y, g, length)
      if (any(n.i < 2)) 
        stop("not enough observations")
      m.i <- tapply(y, g, mean)
      v.i <- tapply(y, g, var)
      w.i <- n.i/v.i
      sum.w.i <- sum(w.i)
      tmp <- sum((1 - w.i/sum.w.i)^2/(n.i - 1))/(k^2 - 1)
      METHOD <- "One-way analysis of means"
      if (var.equal) {
        n <- sum(n.i)
        STATISTIC <- ((sum(n.i * (m.i - mean(y))^2)/(k - 1))/(sum((n.i - 
                                                                     1) * v.i)/(n - k)))
        PARAMETER <- c(k - 1, n - k)
        PVAL <- pf(STATISTIC, k - 1, n - k, lower.tail = FALSE)
      }
      else {
        m <- sum(w.i * m.i)/sum.w.i
        STATISTIC <- sum(w.i * (m.i - m)^2)/((k - 1) * (1 + 2 * 
                                                          (k - 2) * tmp))
        PARAMETER <- c(k - 1, 1/(3 * tmp))
        PVAL <- pf(STATISTIC, k - 1, 1/(3 * tmp), lower.tail = FALSE)
        METHOD <- paste(METHOD, "(not assuming equal variances)")
      }
      names(STATISTIC) <- "F"
      names(PARAMETER) <- c("num df", "denom df")
      RVAL <- list(statistic = STATISTIC, parameter = PARAMETER, 
                   p.value = PVAL, method = METHOD, data.name = DNAME)
      class(RVAL) <- "htest"
      RVAL
    }
    
    perm.cor.test <- function( x,
                               y,
                               B = nsim,
                               seed = 123,
                               method = c( "pearson" ),
                               continuity = FALSE,
                               ... )
    {
      if ( !is.numeric( x ) ) { stop( "x is not numeric" ); } ;
      if ( !is.numeric( y ) ) { stop( "y is not numeric" ); } ;
      if ( !is.numeric( B ) ) { stop( "B is not numeric" );  } ;
      if ( !is.numeric( seed ) ) { stop( "seed is not numeric" ); } ;
      
      arguments <- list( ... ) 
      
      # load pacakges
      download.packages("dplyr")
      
      # permutations
      set.seed( seed )
      data.frame( replicate( B, 
                             sample( y, length(y), FALSE ) ) ) -> 
        perm.sample
      
      # Observed
      cor.test( x,
                y,
                method = method,
                continuity = continuity , 
                ... = arguments
      ) ->
        test.observed
      
      # On perm samples
      perm.sample |>
        lapply( function(y) data.frame(x,y) ) |>
        lapply( function(a) 
        {
          cor.test( a$x,
                    a$y,
                    method = method,
                    continuity = continuity, 
                    ... = arguments
          )
        }) -> test.perm.samples
      
      test.perm.samples |>
        lapply( function(a){ a$statistic } )|>
        unlist() ->
        statistics.perm.samples
      
      # p-value
      sum( abs( statistics.perm.samples ) >= abs( test.observed$statistic ) ) / 
        (B + 1) -> 
        p.value 
      
      # output
      list( p.value = p.value, 
            test.observed = test.observed, 
            statistics.perm.samples = statistics.perm.samples)
    }
    
    perm.t.test <- function( x,
                             y,
                             B = nsim,
                             seed = 123,
                             paired = FALSE, 
                             var.equal = FALSE,
                             ... )
    {
      if ( !is.factor( x ) ) { stop( "x is not factor" ); } ;
      if ( !is.numeric( y ) ) { stop( "y is not numeric" ); } ;
      if ( !is.numeric( B ) ) { stop( "B is not numeric" );  } ;
      if ( !is.numeric( seed ) ) { stop( "seed is not numeric" ); } ;
      
      arguments <- list( ... ) 
      
      # load pacakges
      if ( !require( "dplyr", character.only = TRUE  ) )
      { install.packages( "dplyr" ) ; require( "dplyr", character.only = TRUE ) } ;
      
      # permutations
      set.seed( seed )
      data.frame( replicate( B, 
                             sample( y, length(y), FALSE ) ) ) -> 
        perm.sample
      
      # Observed
      t.test( y ~ x,
              paired = paired, 
              var.equal = var.equal,
              ... = arguments
      ) ->
        test.observed
      
      # On perm samples
      perm.sample |>
        lapply( function(y) data.frame(x,y) ) |>
        lapply( function(a) 
        {
          t.test( a$y ~ a$x,
                  paired = paired, 
                  var.equal = var.equal,
                  ... = arguments
          )
        }) -> test.perm.samples
      
      test.perm.samples |>
        lapply( function(a){ a$statistic } ) |>
        unlist() ->
        statistics.perm.samples
      
      # p-value
      sum( abs( statistics.perm.samples ) >= abs( test.observed$statistic ) ) / 
        (B + 1) -> 
        p.value 
      
      # output
      list( p.value = p.value, 
            test.observed = test.observed, 
            statistics.perm.samples = statistics.perm.samples)
    }
    
    perm.oneway.test <- function( x,
                                  y,
                                  B = nsim,
                                  seed = 123,
                                  var.equal = FALSE )
    {
      if ( !is.factor( x ) ) { stop( "x is not factor" ); } ;
      if ( !is.numeric( y ) ) { stop( "y is not numeric" ); } ;
      if ( !is.numeric( B ) ) { stop( "B is not numeric" );  } ;
      if ( !is.numeric( seed ) ) { stop( "seed is not numeric" ); } ;
      
      # load pacakges
      download.packages("dplyr")
      
      # permutations
      set.seed( seed )
      data.frame( replicate( B, 
                             sample( y, length(y), FALSE ) ) ) -> 
        perm.sample
      
      # Observed
      oneway.test( y ~ x,
                   var.equal = var.equal
      ) ->
        test.observed
      
      # On perm samples
      perm.sample |>
        lapply(  function(y) data.frame(x,y) ) |>
        lapply(  function(a) 
        {
          oneway.test( a$y ~ a$x,
                       var.equal = var.equal
          )
        }) -> test.perm.samples
      
      test.perm.samples |>
        lapply(  function(a){ a$statistic } ) |>
        unlist() ->
        statistics.perm.samples
      
      # p-value
      sum( abs( statistics.perm.samples ) >= abs( test.observed$statistic ) ) / 
        (B + 1) -> 
        p.value 
      
      # output
      list( p.value = p.value, 
            test.observed = test.observed, 
            statistics.perm.samples = statistics.perm.samples)
      
    }
    
    perm.chisq.test <- function( x,
                                 y,
                                 B = nsim,
                                 seed = 123,
                                 correct = TRUE )
    {
      if ( !is.factor( x ) ) { stop( "x is not factor" ); } ;
      if ( !is.factor( y ) ) { stop( "y is not factor" ); } ;
      if ( !is.numeric( B ) ) { stop( "B is not numeric" );  } ;
      if ( !is.numeric( seed ) ) { stop( "seed is not numeric" ); } ;
      
      # load pacakges
      if ( !require( "dplyr", character.only = TRUE  ) )
      { install.packages( "dplyr" ) ; require( "dplyr", character.only = TRUE ) } ;
      
      # permutations
      set.seed( seed )
      data.frame( replicate( B, 
                             sample( y, length(y), FALSE ) ) ) -> 
        perm.sample
      
      # Observed
      chisq.test( x, y,
                  correct = correct ) ->
        test.observed
      
      # On perm samples
      perm.sample |>
        lapply(  function(y) data.frame(x,y) ) |>
        lapply(  function(a) 
        {
          chisq.test( a$y,  a$x,
                      correct = correct 
          )
        }) -> test.perm.samples
      
      test.perm.samples |>
        lapply(  function(a){ a$statistic } ) |>
        unlist() ->
        statistics.perm.samples
      
      # p-value
      sum( abs( statistics.perm.samples ) >= abs( test.observed$statistic ) ) / 
        (B + 1) -> 
        p.value 
      
      # output
      list( p.value = p.value, 
            test.observed = test.observed, 
            statistics.perm.samples = statistics.perm.samples)
    }
    
    # primer
    NULL -> output.b
    
    # Two factors
    if ( is.factor( df.2var[,1] ) &
         is.factor( df.2var[,2] ) )
    {
      if ( nlevels( df.2var[,1] ) > 1 &
           nlevels( df.2var[,2] ) > 1 &
           all( table( df.2var[,1], df.2var[,2] ) > 2 ) )
      {
        # compute
        table( df.2var[,1], df.2var[,2] ) -> ctable1 
        prop.table( ctable1 ) -> ptable1 
        
        if (  nlevels(  df.2var[,1] ) > 2 |
              nlevels(  df.2var[,2] ) > 2 )
        {
          FALSE -> chisq.correct 
          chisq.test( df.2var[,1], df.2var[,2], correct = chisq.correct ) -> 
            chisq ;
          "none" -> gtest.correct
          DescTools::GTest( df.2var[,1], df.2var[,2], correct = gtest.correct ) -> gtest
          list( method = "Fisher not possible", p.value = NA ) -> fisher ;
        } else
        {
          Yates.correct -> chisq.correct 
          chisq.test( df.2var[,1], df.2var[,2], correct = chisq.correct ) -> 
            chisq ;
          if ( Yates.correct | Williams.correct ) 
          { 
            if ( Yates.correct) { "yates" -> gtest.correct }
            if ( Williams.correct) { "williams" -> gtest.correct }
          } else { "none" -> gtest.correct }
          DescTools::GTest( df.2var[,1], df.2var[,2], 
                 correct = gtest.correct ) -> gtest
          fisher.test( df.2var[,1], df.2var[,2], 
                       simulate.p.value = FALSE, B = nsim 
          ) -> fisher ;
        }
        
        if (Permutations)
        {
          perm.chisq.test( df.2var[,1], df.2var[,2], 
                           seed = seed,
                           B = nsim,
                           correct = FALSE ) -> chisq.mc ;
          "Permutation Pearson's Chi-squared Test for Count Data" ->
            chisq.mc$method
        } else
        {
          list( p.value = NA, 
                method = "Permutation test not computed" 
          )  -> chisq.mc
          NA -> chisq.mc$test.observed$statistic
        }
        
        CramersV( df.2var[,1], df.2var[,2], na.rm = FALSE ) -> V ;
        pwr::ES.w2( ptable1 ) -> omega ;
        
        if (  min( chisq$expected ) >= 5 )
        {
          chisq$method -> method 
          chisq$p.value -> p.value 
        }
        
        if (  min( chisq$expected ) < 5 )
        {
          chisq.mc$method -> method ;
          chisq.mc$p.value -> p.value ; 
        }
        
        if (  min( chisq$expected ) >= 3 &
              Yates.correct & 
              nlevels(  df.2var[,1] ) == 2 &
              nlevels(  df.2var[,2] ) == 2 )
        {
          chisq$method -> method ;
          chisq$p.value -> p.value ; 
        }
        
        if (  min( chisq$expected ) < 5 &
              !Yates.correct & 
              nlevels(  df.2var[,1] ) == 2 &
              nlevels(  df.2var[,2] ) == 2 )
        {
          fisher$method -> method ;
          fisher$p.value -> p.value ; 
        }
        
        if (  min( chisq$expected ) < 3 &
              Yates.correct & 
              nlevels(  df.2var[,1] ) == 2 &
              nlevels(  df.2var[,2] ) == 2 )
        {
          fisher$method -> method ;
          fisher$p.value -> p.value ; 
        }
        
        # fusion
        c( "factor",
           colnames( df )[a], 
           colnames( df )[b], 
           length( df.2var[,1] ),
           length( df[,a] ) - length( df.2var[,1] ),
           p.value,
           method,
           min( chisq$expected ),
           chisq$method,
           chisq.correct,
           chisq$statistic,
           chisq$parameter,
           chisq$p.value,
           gtest$method,
           gtest.correct,
           gtest$statistic,
           gtest$parameter,
           gtest$p.value,
           fisher$method,
           fisher$p.value,
           chisq.mc$method,
           chisq.mc$test.observed$statistic,
           chisq.mc$p.value,
           V,
           omega
        ) -> 
          output.b ;
        
        c( "factor", 
           "var1", "var2", 
           "N", "Missing",
           "p-value", "Method",
           "Minimal expected number",
           "Chi-squared method",
           "Yates correction",
           "Chi-squared statistic",
           "Chi-squared degree of freedom",
           "Chi-squared p-value",
           "G-test method",
           "G-test correction",
           "G statistic",
           "G-test degree of freedom",
           "G-test p-value",
           "Fisher method",
           "Fisher p-value",
           "Monte Carlo simulation Chi-squared method",
           "Monte Carlo Chi-squared statistic",
           "Monte Carlo Chi-squared p-value",
           "Cramer's V",
           "Cohen's omega"
        ) -> 
          names( output.b ) ;
        
        # Round 
        if( !is.null( round ) )
        {
          for ( round.a in c( "Minimal expected number",
                              "Chi-squared statistic",
                              "Chi-squared degree of freedom",
                              "G statistic",
                              "G-test degree of freedom",
                              "Monte Carlo Chi-squared statistic",
                              "Cramer's V",
                              "Cohen's omega"
          ) )
          {
            round( as.numeric( as.character( output.b[ round.a ] ) ), 
                   digits = round ) ->
              output.b[ round.a ] ; 
          }
        }
        
        if( !is.null( pvalue.round ) )
        {
          for ( round.a in c( "p-value", 
                              "Chi-squared p-value",
                              "G-test p-value",
                              "Fisher p-value",
                              "Monte Carlo Chi-squared p-value"
          ) )
          {
            p.round( as.numeric( output.b[ which( names( output.b ) == 
                                                    round.a ) ] ),
                     digits = pvalue.round ) ->
              output.b[ which( names( output.b ) == round.a ) ] ; 
          }
        }
        
      }
      
    }
    
    # Two numerics
    if ( is.numeric( df.2var[,1] ) &
         is.numeric( df.2var[,2] ) )
    {
      if ( !all( na.omit( df.2var[,1] == df.2var[,2] ) ) &
           nlevels( factor( df.2var[,1] ) ) > 3 &
           nlevels( factor( df.2var[,2] ) ) > 3  & 
           length( df.2var[,1] ) > 7 )
      {
        # compute
        if ( length( df.2var[,1] ) < 5000 ) 
        { shapiro.test( df.2var[,1] ) -> shapiro1 ; }  else
        { list( "p.value" = NA ) -> shapiro1 ; }
        if ( length( df.2var[,1] ) < 5000 ) 
        { shapiro.test( df.2var[,2] ) -> shapiro2 ; }  else
        { list( "p.value" = NA ) -> shapiro2 ; }
        nortest::ad.test( df.2var[,1] ) -> anderson1 ;
        nortest::ad.test( df.2var[,2] ) -> anderson2 ;
        moments::jarque.test( df.2var[,1] ) -> jarque1 ;
        moments::jarque.test( df.2var[,2] ) -> jarque2 ;
        if ( any( na.omit( c( shapiro1$p.value, anderson1$p.value, 
                              jarque1$p.value,
                              shapiro2$p.value, anderson2$p.value, 
                              jarque2$p.value ) ) < 0.05 ) )  
        { FALSE -> normal ; } else { TRUE -> normal } 
        
        cor.test( df.2var[,1], df.2var[,2], method = "pearson" ) -> pearson ;
        cor.test( df.2var[,1], df.2var[,2], method = "spearman",
                  continuity = Continuity.correct ) -> spearman ;
        cor.test( df.2var[,1], df.2var[,2], method = "kendall",
                  continuity = Continuity.correct ) -> kendall ;
        if (Permutations)
        {
          perm.cor.test( df.2var[,1], df.2var[,2], 
                         B = nsim, seed = seed ) -> pearson.mc ;
          "Permutation Pearson's product-moment correlation test" ->
            pearson.mc$method
        } else
        {
          list( p.value = NA, 
                method = "Permutation test not computed" 
          )  -> pearson.mc
          NA -> pearson.mc$test.observed$statistic
        }
        
        RankBiserialCor( df.2var[,1], df.2var[,2] ) -> rbc ;
        CliffDelta( df.2var[,1], df.2var[,2] ) -> cliff ;
        
        if (normal)
        {
          pearson$p.value -> p.value ;
          pearson$method -> method ; 
        } else
        {
          spearman$p.value -> p.value ;
          spearman$method -> method ;  
        }
        
        # fusion
        c( "numeric",
           colnames( df )[a], 
           colnames( df )[b],   
           length( df.2var[,1] ),
           length( df[,a] ) - length( df.2var[,1] ),
           p.value,
           method,
           normal,
           pearson$method,
           pearson$statistic,
           pearson$parameter,
           pearson$p.value,
           spearman$method,
           Continuity.correct,
           spearman$statistic,
           spearman$p.value,
           kendall$method,
           Continuity.correct,
           kendall$statistic,
           kendall$p.value,
           pearson.mc$method,
           nsim,
           pearson.mc$test.observed$statistic,
           pearson.mc$p.value,
           pearson$estimate^2,
           pearson$estimate,
           spearman$estimate,
           kendall$estimate,
           rbc,
           cliff,
           shapiro1$p.value,
           anderson1$p.value,
           jarque1$p.value,
           shapiro2$p.value,
           anderson2$p.value,
           jarque2$p.value
        ) -> 
          output.b ;
        
        c( "Class", "var1", "var2", "N", "Missing",
           "p-value", "Method",
           "var1 & var2 normal",
           "Pearson method",
           "Pearson T ratio",
           "Pearson degree of freedom",
           "Pearson p-value",
           "Spearman method",
           "Continuity correction",
           "Spearman S statistic",
           "Spearman p-value",
           "Kendall method",
           "Continuity correction",
           "Kendall Z statistic",
           "Kendall p-value",
           "Permutation Pearson method",
           "Number of permutation",
           "Permutation T ratio",
           "Permutation Pearson p-value",
           "R-squared coefficient of determinationt",
           "Pearson r correlation coefficient",
           "Spearman rho correlation coefficient",
           "Kendall tau correlation coefficient",
           "Rank biserial correlation coefficient",
           "Cliff's delta",
           "var1 Shapiro p-value",
           "var1 Anderson-Darling p-value",
           "var1 Jarque-Bera p-value",
           "var2 Shapiro p-value",
           "var2 Anderson-Darling p-value",
           "var2 Jarque-Bera p-value"
        ) -> names( output.b ) ;
        
        # Round 
        if( !is.null( round ) )
        {
          for ( round.a in c( "Pearson T ratio",
                              "Pearson degree of freedom",
                              "Spearman S statistic",
                              "Kendall Z statistic",
                              "Number of permutation",
                              "Permutation T ratio",
                              "R-squared coefficient of determinationt",
                              "Pearson r correlation coefficient",
                              "Spearman rho correlation coefficient",
                              "Kendall tau correlation coefficient",
                              "Rank biserial correlation coefficient",
                              "Cliff's delta"
          ) )
          {
            round( as.numeric( as.character( output.b[ round.a ] ) ), 
                   digits = round ) ->
              output.b[ round.a ] ; 
          }
        }
        
        if( !is.null( pvalue.round ) )
        {
          for ( round.a in c( "p-value",
                              "Pearson p-value",
                              "Spearman p-value",
                              "Kendall p-value",
                              "Permutation Pearson p-value",
                              "var1 Shapiro p-value",
                              "var1 Anderson-Darling p-value",
                              "var1 Jarque-Bera p-value",
                              "var2 Shapiro p-value",
                              "var2 Anderson-Darling p-value",
                              "var2 Jarque-Bera p-value"
          ) )
          {
            p.round( as.numeric( output.b[ which( names( output.b ) == 
                                                    round.a ) ] ),
                     digits = pvalue.round ) ->
              output.b[ which( names( output.b ) == round.a ) ] ; 
          }
        }
      }
      
    }
    
    # One factor and one numeric, first way
    if ( is.factor( df.2var[,1] ) &
         is.numeric( df.2var[,2] )  )
    {
      if ( all( table( df.2var[,1] ) > 4 ) & 
           nlevels( df.2var[,1] ) > 1 &
           nlevels( factor( df.2var[,2] ) ) > 3  )
      {
        # compute
        lm(  df.2var[,2] ~ df.2var[,1] )$residuals -> residuals1
        if ( length( residuals1 ) < 5000 ) 
        { shapiro.test( residuals1 ) -> shapiro ; }  else
        { list( "p.value" = NA ) -> shapiro ; }
        nortest::ad.test( residuals1) -> anderson ;
        moments::jarque.test( residuals1 ) -> jarque ;
        if ( any( c( shapiro$p.value, anderson$p.value, jarque$p.value ) < 0.05 ) ) 
        { FALSE -> normal ; } else { TRUE -> normal } 
        
        bartlett.test( df.2var[,2] ~ df.2var[,1] ) -> bartlett ;
        fligner.test( df.2var[,2] ~ df.2var[,1] ) -> fligner ;
        if ( any( c( bartlett$p.value, fligner$p.value ) < 0.05 ) ) 
        { FALSE -> homoscedastik ; } else { TRUE -> homoscedastik } 
        
        oneway.test2( df.2var[,2] ~ df.2var[,1], var.equal = !Welch.correct ) -> 
          ow.anova ;
        kruskal.test( df.2var[,2] ~ df.2var[,1] ) -> kruskal ;
        if (Permutations)
        {
          perm.oneway.test( df.2var[,1], df.2var[,2], 
                            var.equal = !Welch.correct,
                            B = nsim,
                            seed = seed ) -> ow.anova.mc
          "Permutation Analysis of Variance Table" ->
            ow.anova.mc$method
        } else
        {
          list( p.value = NA, 
                method = "Permutation test not computed" 
          )  -> ow.anova.mc
          NA -> ow.anova.mc$test.observed$statistic
        }
        
        
        eta.squared( df.2var[,1], df.2var[,2] ) -> eta2 ;
        summary( lm( df.2var[,2] ~ df.2var[,1] ) )$r.squared -> r2 ;
        r2 / (1 - r2) -> f2 ;
        
        if ( nlevels( df.2var[,1] ) == 2 &
             !all( na.omit( 
               df.2var[ df.2var[,1] == levels( df.2var[,1] )[1], 2] ) == 
               df.2var[ df.2var[,1] == levels( df.2var[,1] )[2], 2] 
             ) &
             nlevels( factor( 
               df.2var[ df.2var[,1] == levels( df.2var[,1] )[1], 2] 
             ) ) > 3 &
             nlevels( factor( 
               df.2var[ df.2var[,1] == levels( df.2var[,1] )[2], 2]
             ) ) > 3  ) 
        {
          if ( length(  df.2var[ df.2var[,1] == levels( df.2var[,1] )[1], 2] ) < 
               5000 ) 
          { shapiro.test( df.2var[ df.2var[,1] == levels( df.2var[,1] )[1], 2] 
          ) -> shapiro1 ; }  else
          { list( "p.value" = NA ) -> shapiro1 ; }
          if ( length( df.2var[ df.2var[,1] == levels( df.2var[,1] )[2], 2] ) < 
               5000 ) 
          { shapiro.test(df.2var[ df.2var[,1] == levels( df.2var[,1] )[2], 2] ) -> shapiro2 ; }  else
          { list( "p.value" = NA ) -> shapiro2 ; }
          if ( length(  df.2var[ df.2var[,1] == levels( df.2var[,1] )[1], 2] ) > 
               7 ) 
          { nortest::ad.test(  df.2var[ df.2var[,1] == levels( df.2var[,1] )[1], 2]
          ) -> anderson1 ; } else 
          { list( "p.value" = NA ) -> anderson1 ; }
          if ( length( df.2var[ df.2var[,1] == levels( df.2var[,1] )[2], 2] ) > 
               7 ) 
          { nortest::ad.test( df.2var[ df.2var[,1] == levels( df.2var[,1] )[2], 2] 
          ) -> anderson2 ; } else 
          { list( "p.value" = NA ) -> anderson2 ; }
          moments::jarque.test(  df.2var[ df.2var[,1] == levels( df.2var[,1] )[1], 2] 
          ) -> jarque1 ;
          moments::jarque.test( df.2var[ df.2var[,1] == levels( df.2var[,1] )[2], 2]
          ) -> jarque2 ;
          if ( any( na.omit( c( shapiro1$p.value, anderson1$p.value, 
                                jarque1$p.value,
                                shapiro2$p.value, anderson2$p.value, 
                                jarque2$p.value ) ) < 0.05 ) ) 
          { FALSE -> normal ; } else { TRUE -> normal } 
          
          var.test(  df.2var[,2] ~ df.2var[,1] ) -> var1
          ansari.test( df.2var[,2] ~ df.2var[,1]  ) -> ansari1
          if ( any( c( bartlett$p.value, fligner$p.value,
                       var1$p.value, ansari1$p.value ) < 0.05 ) ) 
          { FALSE -> homoscedastik ; } else { TRUE -> homoscedastik } 
          
          t.test( df.2var[,2] ~ df.2var[,1], var.equal = !Welch.correct ) -> 
            student ;
          wilcox.test( df.2var[,2] ~ df.2var[,1], 
                       correct = Continuity.correct ) -> wilcoxon ;
          mood.test(  df.2var[,2] ~ df.2var[,1] ) -> mood
          if (Permutations)
          {
            perm.t.test( df.2var[,1], df.2var[,2],
                         var.equal = !Welch.correct,
                         B = nsim, seed = seed ) -> 
              student.mc ;
            c( student.mc, list( method = "Permutation Two Sample t-test" ) 
            ) -> student.mc
          } else
          {
            list( p.value = NA, 
                  method = "Permutation Two Sample t-test"
            )  -> student.mc
            NA -> student.mc$test.observed$statistic
          }
          
          paste( levels( df.2var[,1] )[1], "->", levels( df.2var[,1] )[2]
          ) -> direction;
          r.pb( df.2var[,1], df.2var[,2] ) -> rpb ;
          CohenD( df.2var[,1], df.2var[,2] ) -> cohend ;
          HedgeGstar( df.2var[,1], df.2var[,2] ) -> hedgegstar ;
          RankBiserialCor( df.2var[ df.2var[,1] == levels( df.2var[,1] )[1], 2], 
                           df.2var[ df.2var[,1] == levels( df.2var[,1] )[2], 2] ) -> 
            rbc ;
          CliffDelta( df.2var[ df.2var[,1] == levels( df.2var[,1] )[1], 2], 
                      df.2var[ df.2var[,1] == levels( df.2var[,1] )[2], 2] ) -> cliff ;
          
          
          if ( ( normal & homoscedastik ) | 
               (normal & !homoscedastik & Welch.correct ) ) 
          {
            student$p.value -> p.final ; 
            student$method -> method.final
          }
          if ( !normal | ( !homoscedastik & !Welch.correct )  ) 
          {
            wilcoxon$p.value -> p.final ; 
            wilcoxon$method -> method.final
          }
        } else
        {
          list( "p.value" = NA ) -> shapiro1 ; 
          list( "p.value" = NA ) -> shapiro2 ; 
          list( "p.value" = NA ) -> anderson1 ; 
          list( "p.value" = NA ) -> anderson2 ; 
          list( "p.value" = NA ) -> jarque1 ; 
          list( "p.value" = NA ) -> jarque2 ; 
          list( "p.value" = NA ) -> jarque1 ; 
          list( "p.value" = NA ) -> jarque2 ; 
          list( "p.value" = NA ) -> var1 ; 
          list( "p.value" = NA ) -> ansari1 ; 
          
          list(
            method = "Test not possible beacause: more than two levels or all values equal in two groups or less than four different possible values in one of groups",
            statistic = NA,
            parameter = NA,
            p.value = NA
          ) -> student ;
          list(
            method = "Test not possible",
            statistic = NA,
            p.value = NA
          ) -> wilcoxon ;
          list(
            method = "Test not possible",
            statistic = NA,
            p.value = NA
          ) -> mood ;
          list(
            method = "Test not possible",
            p.value = NA
          ) -> student.mc
          
          "" -> direction;
          NA -> rpb ;
          NA -> cohend ;
          NA -> hedgegstar ;
          NA -> rbc ;
          NA -> cliff ;
          
          if ( ( normal & homoscedastik ) | 
               (normal & !homoscedastik & Welch.correct ) ) 
          {
            ow.anova$p.value -> p.final ; 
            ow.anova$method -> method.final
          }
          if ( !normal | ( !homoscedastik & !Welch.correct )  ) 
          {
            kruskal$p.value -> p.final ; 
            kruskal$method -> method.final
          }
        }
        
        # fusion
        c( "mix",
           colnames( df )[a], 
           colnames( df )[b], 
           length( df.2var[,1] ),
           length( df[,a] ) - length( df.2var[,1] ),
           p.final,
           method.final,
           normal,
           homoscedastik,
           ow.anova$method,
           Welch.correct,
           ow.anova$statistic,
           ow.anova$parameter[1],
           ow.anova$parameter[2],
           ow.anova$p.value,
           kruskal$method,
           kruskal$statistic,
           kruskal$parameter,
           kruskal$p.value,
           ow.anova.mc$method,
           nsim,
           Welch.correct,
           ow.anova$statistic,
           ow.anova.mc$p.value,
           student$method,
           Welch.correct,
           student$statistic,
           student$parameter,
           student$p.value,
           wilcoxon$method,
           Continuity.correct,
           wilcoxon$statistic,
           wilcoxon$p.value,
           mood$method,
           mood$statistic,
           mood$p.value,
           student.mc$method,
           nsim,
           Welch.correct,
           student$statistic,
           student.mc$p.value,
           eta2,
           f2,
           direction,
           rpb,
           cohend,
           hedgegstar,
           rbc,
           cliff,
           shapiro$p.value, 
           anderson$p.value,
           jarque$p.value,
           bartlett$p.value,
           fligner$p.value,
           shapiro1$p.value,
           anderson1$p.value,
           jarque1$p.value,
           shapiro2$p.value,
           anderson2$p.value,
           jarque2$p.value,
           var1$p.value,
           ansari1$p.value
        ) -> 
          output.b ;
        
        c( "Class", "var1", "var2", "N", "Missing",
           "p-value", "Method",
           "Normality",
           "Homoscedasticity",
           "Anova method",
           "Welch correction",
           "Anova F statistic",
           "Anova degree of freedom numerator",
           "Anova degree of freedom denominator",
           "Anova p-value",
           "Kruskal-Wallis method",
           "Kruskal-Wallis chi-squared statictic",
           "Kruskal-Wallis degree of freedom",
           "Kruskal-Wallis p-value",
           "Permutation Anova method",
           "Number of permutation",
           "Welch correction",
           "Permutation F statistic",
           "Permutation Anova p-value",
           "Student method",
           "Welch correction",
           "StudentT ratio",
           "Student degree of freedom",
           "Student p-value",
           "Wilcoxon method",
           "Continuity correction",
           "Wilcoxon W statistic",
           "Wilcoxon p-value",
           "Mood method",
           "Mood Z statistic",
           "Mood p-value",
           "Permutation Student method",
           "Number of permutation",
           "Welch correction",
           "Permutation T ratio",
           "Permutation Student p-value",
           "Eta-squared correlation ratio",
           "Cohen's f-squared",
           "Direction for size effects",
           "Point biserial correlation coefficient r.pb",
           "Cohen's d",
           "Hedge's g*",
           "Rank biserial correlation",
           "Cliff's delta",
           "Anova residuals Shapiro p-value",
           "Anova residuals Anderson-Darling p-value",
           "Anova residuals Jarque-Bera p-value",
           "Bartlett p-value",
           "Fligner-Killeen p-value",
           "group1 Shapiro p-value",
           "group1 Anderson-Darling p-value",
           "group1 Jarque-Bera p-value",
           "group2 Shapiro p-value",
           "group2 Anderson-Darling p-value",
           "group2 Jarque-Bera p-value",
           "F-test for variances p-value",
           "Ansara-Bradley p-value"
        ) -> names( output.b ) ;
        
        # Round 
        if( !is.null( round ) )
        {
          for ( round.a in c( "Anova F statistic",
                              "Anova degree of freedom numerator",
                              "Anova degree of freedom denominator",
                              "Kruskal-Wallis chi-squared statictic",
                              "Kruskal-Wallis degree of freedom",
                              "Permutation F statistic",
                              "StudentT ratio",
                              "Student degree of freedom",
                              "Wilcoxon W statistic",
                              "Mood Z statistic",
                              "Permutation T ratio",
                              "Eta-squared correlation ratio",
                              "Cohen's f-squared",
                              "Point biserial correlation coefficient r.pb",
                              "Cohen's d",
                              "Hedge's g*",
                              "Rank biserial correlation",
                              "Cliff's delta"  ) )
          {
            round( as.numeric( as.character( output.b[ round.a ] ) ), 
                   digits = round ) ->
              output.b[ round.a ] ; 
          }
        }
        
        if( !is.null( pvalue.round ) )
        {
          for ( round.a in c( "p-value", 
                              "Anova p-value",
                              "Kruskal-Wallis p-value",
                              "Permutation Anova p-value",
                              "Student p-value",
                              "Wilcoxon p-value",
                              "Mood p-value",
                              "Permutation Student p-value",
                              "Anova residuals Shapiro p-value",
                              "Anova residuals Anderson-Darling p-value",
                              "Anova residuals Jarque-Bera p-value",
                              "Bartlett p-value",
                              "Fligner-Killeen p-value",
                              "group1 Shapiro p-value",
                              "group1 Anderson-Darling p-value",
                              "group1 Jarque-Bera p-value",
                              "group2 Shapiro p-value",
                              "group2 Anderson-Darling p-value",
                              "group2 Jarque-Bera p-value",
                              "F-test for variances p-value",
                              "Ansara-Bradley p-value" ) )
          {
            p.round( as.numeric( output.b[ which( names( output.b ) == 
                                                    round.a ) ] ),
                     digits = pvalue.round ) ->
              output.b[ which( names( output.b ) == round.a ) ] ; 
          }
        }
        
      }
      
    }
    
    # One factor and one numeric, second way
    if ( is.numeric(  df.2var[,1] ) &
         is.factor( df.2var[,2] ) )
    {
      if (
        all( table( df.2var[,2] ) > 4 & 
             nlevels( df.2var[,2] ) > 1 &
             nlevels( factor( df.2var[,1] ) ) > 3 )
      )
      {
        # compute
        lm(  df.2var[,1] ~ df.2var[,2] )$residuals -> residuals1
        if ( length( residuals1 ) < 5000 ) 
        { shapiro.test( residuals1 ) -> shapiro ; }  else
        { list( "p.value" = NA ) -> shapiro ; }
        nortest::ad.test( residuals1) -> anderson ;
        moments::jarque.test( residuals1 ) -> jarque ;
        if ( any( c( shapiro$p.value, anderson$p.value, jarque$p.value ) < 0.05 ) ) 
        { FALSE -> normal ; } else { TRUE -> normal } 
        
        bartlett.test( df.2var[,1] ~ df.2var[,2] ) -> bartlett ;
        fligner.test( df.2var[,1] ~ df.2var[,2] ) -> fligner ;
        if ( any( c( bartlett$p.value, fligner$p.value ) < 0.05 ) ) 
        { FALSE -> homoscedastik ; } else { TRUE -> homoscedastik } 
        
        oneway.test2( df.2var[,1] ~ df.2var[,2], var.equal = !Welch.correct ) -> 
          ow.anova ;
        kruskal.test( df.2var[,1] ~ df.2var[,2] ) -> kruskal ;
        if (Permutations)
        {
          perm.oneway.test( df.2var[,2], df.2var[,1], 
                            var.equal = !Welch.correct,
                            B = nsim,
                            seed = seed ) -> ow.anova.mc
          "Permutation Analysis of Variance Table" ->
            ow.anova.mc$method
        } else
        {
          list( p.value = NA, 
                method = "Permutation test not computed" 
          )  -> ow.anova.mc
          NA -> ow.anova.mc$test.observed$statistic
        }
        
        eta.squared( df.2var[,2], df.2var[,1] ) -> eta2 ;
        summary( lm( df.2var[,1] ~ df.2var[,2] ) )$r.squared -> r2 ;
        r2 / (1 - r2) -> f2 ;
        
        if ( nlevels( df.2var[,2] ) == 2 &
             !all( na.omit( 
               df.2var[ df.2var[,2] == levels( df.2var[,2] )[1], 1] ) == 
               df.2var[ df.2var[,2] == levels( df.2var[,2] )[2], 1] 
             ) &
             nlevels( factor( 
               df.2var[ df.2var[,2] == levels( df.2var[,2] )[1], 1] 
             ) ) > 3 &
             nlevels( factor( 
               df.2var[ df.2var[,2] == levels( df.2var[,2] )[2], 1]
             ) ) > 3 ) 
        {
          if ( length(  df.2var[ df.2var[,2] == levels( df.2var[,2] )[1], 1] ) < 
               5000 ) 
          { shapiro.test( df.2var[ df.2var[,2] == levels( df.2var[,2] )[1], 1] 
          ) -> shapiro1 ; }  else
          { list( "p.value" = NA ) -> shapiro1 ; }
          if ( length( df.2var[ df.2var[,2] == levels( df.2var[,2] )[2], 1] ) < 
               5000 ) 
          { shapiro.test(df.2var[ df.2var[,2] == levels( df.2var[,2] )[2], 1] ) -> shapiro2 ; }  else
          { list( "p.value" = NA ) -> shapiro2 ; }
          if ( length(  df.2var[ df.2var[,2] == levels( df.2var[,2] )[1], 1] ) > 
               7 ) 
          { nortest::ad.test(  df.2var[ df.2var[,2] == levels( df.2var[,2] )[1], 1]
          ) -> anderson1 ; } else 
          { list( "p.value" = NA ) -> anderson1 ; }
          if ( length( df.2var[ df.2var[,2] == levels( df.2var[,2] )[2], 1] ) > 
               7 ) 
          { nortest::ad.test( df.2var[ df.2var[,2] == levels( df.2var[,2] )[2], 1] 
          ) -> anderson2 ; } else 
          { list( "p.value" = NA ) -> anderson2 ; }
          moments::jarque.test(  df.2var[ df.2var[,2] == levels( df.2var[,2] )[1], 1] 
          ) -> jarque1 ;
          moments::jarque.test( df.2var[ df.2var[,2] == levels( df.2var[,2] )[2], 1]
          ) -> jarque2 ;
          if ( any( na.omit( c( shapiro1$p.value, anderson1$p.value, 
                                jarque1$p.value,
                                shapiro2$p.value, anderson2$p.value, 
                                jarque2$p.value ) ) < 0.05 ) ) 
          { FALSE -> normal ; } else { TRUE -> normal } 
          
          var.test(  df.2var[,1] ~ df.2var[,2] ) -> var1
          ansari.test( df.2var[,1] ~ df.2var[,2]  ) -> ansari1
          if ( any( c( bartlett$p.value, fligner$p.value,
                       var1$p.value, ansari1$p.value ) < 0.05 ) ) 
          { FALSE -> homoscedastik ; } else { TRUE -> homoscedastik } 
          
          t.test( df.2var[,1] ~ df.2var[,2], var.equal = !Welch.correct ) -> 
            student ;
          wilcox.test( df.2var[,1] ~ df.2var[,2], 
                       correct = Continuity.correct ) -> wilcoxon ;
          mood.test(  df.2var[,1] ~ df.2var[,2] ) -> mood
          if (Permutations)
          {
            perm.t.test( df.2var[,2], df.2var[,1],
                         var.equal = !Welch.correct,
                         B = nsim, seed = seed ) -> 
              student.mc ;
            c( student.mc, list( method = "Permutation Two Sample t-test" ) 
            ) -> student.mc
          } else
          {
            list( p.value = NA, 
                  method = "Permutation Two Sample t-test"
            )  -> student.mc
            NA -> student.mc$test.observed$statistic
          }
          
          paste( levels( df.2var[,2] )[1], "->", levels( df.2var[,2] )[2]
          ) -> direction;
          r.pb( df.2var[,2], df.2var[,1] ) -> rpb ;
          CohenD( df.2var[,2], df.2var[,1] ) -> cohend ;
          HedgeGstar( df.2var[,2], df.2var[,1] ) -> hedgegstar ;
          RankBiserialCor( df.2var[ df.2var[,2] == levels( df.2var[,2] )[1], 1], 
                           df.2var[ df.2var[,2] == levels( df.2var[,2] )[2], 1] ) -> 
            rbc ;
          CliffDelta( df.2var[ df.2var[,2] == levels( df.2var[,2] )[1], 1], 
                      df.2var[ df.2var[,2] == levels( df.2var[,2] )[2], 1] ) -> cliff ;
          
          if ( ( normal & homoscedastik ) | 
               (normal & !homoscedastik & Welch.correct ) ) 
          {
            student$p.value -> p.final ; 
            student$method -> method.final
          }
          if ( !normal | ( !homoscedastik & !Welch.correct )  ) 
          {
            wilcoxon$p.value -> p.final ; 
            wilcoxon$method -> method.final
          }
        } else
        {
          list( "p.value" = NA ) -> shapiro1 ; 
          list( "p.value" = NA ) -> shapiro2 ; 
          list( "p.value" = NA ) -> anderson1 ; 
          list( "p.value" = NA ) -> anderson2 ; 
          list( "p.value" = NA ) -> jarque1 ; 
          list( "p.value" = NA ) -> jarque2 ; 
          list( "p.value" = NA ) -> jarque1 ; 
          list( "p.value" = NA ) -> jarque2 ; 
          list( "p.value" = NA ) -> var1 ; 
          list( "p.value" = NA ) -> ansari1 ; 
          
          list(
            method = "Test not possible beacause: more than two levels or all values equal in two groups or less than four different possible values in one of groups",
            statistic = NA,
            parameter = NA,
            p.value = NA
          ) -> student ;
          list(
            method = "Test not possible",
            statistic = NA,
            p.value = NA
          ) -> wilcoxon ;
          list(
            method = "Test not possible",
            statistic = NA,
            p.value = NA
          ) -> mood ;
          list(
            method = "Test not possible",
            p.value = NA
          ) -> student.mc
          
          "" -> direction;
          NA -> rpb ;
          NA -> cohend ;
          NA -> hedgegstar ;
          NA -> rbc ;
          NA -> cliff ;
          
          if ( ( normal & homoscedastik ) | 
               (normal & !homoscedastik & Welch.correct ) ) 
          {
            ow.anova$p.value -> p.final ; 
            ow.anova$method -> method.final
          }
          if ( !normal | ( !homoscedastik & !Welch.correct )  ) 
          {
            kruskal$p.value -> p.final ; 
            kruskal$method -> method.final
          }
        }
        
        # fusion
        c( "mix",
           colnames( df )[a], 
           colnames( df )[b], 
           length( df.2var[,1] ),
           length( df[,a] ) - length( df.2var[,1] ),
           p.final,
           method.final,
           normal,
           homoscedastik,
           ow.anova$method,
           Welch.correct,
           ow.anova$statistic,
           ow.anova$parameter[1],
           ow.anova$parameter[2],
           ow.anova$p.value,
           kruskal$method,
           kruskal$statistic,
           kruskal$parameter,
           kruskal$p.value,
           ow.anova.mc$method,
           nsim,
           Welch.correct,
           ow.anova$statistic,
           ow.anova.mc$p.value,
           student$method,
           Welch.correct,
           student$statistic,
           student$parameter,
           student$p.value,
           wilcoxon$method,
           Continuity.correct,
           wilcoxon$statistic,
           wilcoxon$p.value,
           mood$method,
           mood$statistic,
           mood$p.value,
           student.mc$method,
           nsim,
           Welch.correct,
           student$statistic,
           student.mc$p.value,
           eta2,
           f2,
           direction,
           rpb,
           cohend,
           hedgegstar,
           rbc,
           cliff,
           shapiro$p.value, 
           anderson$p.value,
           jarque$p.value,
           bartlett$p.value,
           fligner$p.value,
           shapiro1$p.value,
           anderson1$p.value,
           jarque1$p.value,
           shapiro2$p.value,
           anderson2$p.value,
           jarque2$p.value,
           var1$p.value,
           ansari1$p.value
        ) -> 
          output.b ;
        
        c( "Class", "var1", "var2", "N", "Missing",
           "p-value", "Method",
           "Normality",
           "Homoscedasticity",
           "Anova method",
           "Welch correction",
           "Anova F statistic",
           "Anova degree of freedom numerator",
           "Anova degree of freedom denominator",
           "Anova p-value",
           "Kruskal-Wallis method",
           "Kruskal-Wallis chi-squared statictic",
           "Kruskal-Wallis degree of freedom",
           "Kruskal-Wallis p-value",
           "Permutation Anova method",
           "Number of permutation",
           "Welch correction",
           "Permutation F statistic",
           "Permutation Anova p-value",
           "Student method",
           "Welch correction",
           "StudentT ratio",
           "Student degree of freedom",
           "Student p-value",
           "Wilcoxon method",
           "Continuity correction",
           "Wilcoxon W statistic",
           "Wilcoxon p-value",
           "Mood method",
           "Mood Z statistic",
           "Mood p-value",
           "Permutation Student method",
           "Number of permutation",
           "Welch correction",
           "Permutation T ratio",
           "Permutation Student p-value",
           "Eta-squared correlation ratio",
           "Cohen's f-squared",
           "Direction for size effects",
           "Point biserial correlation coefficient r.pb",
           "Cohen's d",
           "Hedge's g*",
           "Rank biserial correlation",
           "Cliff's delta",
           "Anova residuals Shapiro p-value",
           "Anova residuals Anderson-Darling p-value",
           "Anova residuals Jarque-Bera p-value",
           "Bartlett p-value",
           "Fligner-Killeen p-value",
           "group1 Shapiro p-value",
           "group1 Anderson-Darling p-value",
           "group1 Jarque-Bera p-value",
           "group2 Shapiro p-value",
           "group2 Anderson-Darling p-value",
           "group2 Jarque-Bera p-value",
           "F-test for variances p-value",
           "Ansara-Bradley p-value"
        ) -> names( output.b ) ;
        
        # Round 
        if( !is.null( round ) )
        {
          for ( round.a in c( "Anova F statistic",
                              "Anova degree of freedom numerator",
                              "Anova degree of freedom denominator",
                              "Kruskal-Wallis chi-squared statictic",
                              "Kruskal-Wallis degree of freedom",
                              "Permutation F statistic",
                              "StudentT ratio",
                              "Student degree of freedom",
                              "Wilcoxon W statistic",
                              "Mood Z statistic",
                              "Permutation T ratio",
                              "Eta-squared correlation ratio",
                              "Cohen's f-squared",
                              "Point biserial correlation coefficient r.pb",
                              "Cohen's d",
                              "Hedge's g*",
                              "Rank biserial correlation",
                              "Cliff's delta"  ) )
          {
            round( as.numeric( as.character( output.b[ round.a ] ) ), 
                   digits = round ) ->
              output.b[ round.a ] ; 
          }
        }
        
        if( !is.null( pvalue.round ) )
        {
          for ( round.a in c( "p-value", 
                              "Anova p-value",
                              "Kruskal-Wallis p-value",
                              "Permutation Anova p-value",
                              "Student p-value",
                              "Wilcoxon p-value",
                              "Mood p-value",
                              "Permutation Student p-value",
                              "Anova residuals Shapiro p-value",
                              "Anova residuals Anderson-Darling p-value",
                              "Anova residuals Jarque-Bera p-value",
                              "Bartlett p-value",
                              "Fligner-Killeen p-value",
                              "group1 Shapiro p-value",
                              "group1 Anderson-Darling p-value",
                              "group1 Jarque-Bera p-value",
                              "group2 Shapiro p-value",
                              "group2 Anderson-Darling p-value",
                              "group2 Jarque-Bera p-value",
                              "F-test for variances p-value",
                              "Ansara-Bradley p-value" ) )
          {
            p.round( as.numeric( output.b[ which( names( output.b ) == 
                                                    round.a ) ] ),
                     digits = pvalue.round ) ->
              output.b[ which( names( output.b ) == round.a ) ] ; 
          }
        }
        
      }
      
    }
    
    # No test possible
    if ( is.null( output.b ) )
    {
      c( "other", 
         colnames( df )[a], 
         colnames( df )[b], 
         "",
         "",
         "No test if:", 
         "is not factor or numeric",
         "just 1 level for factor",
         "less than 4 differents values for numerics",
         "less than 3 observations for each cell for 2 factors",
         "less than 5 observations by level for 1 numeric & 1 factor",
         "less than 8 values for 2 numerics" ) -> 
        output.b ;
    }
    
    return( output.b ) ;
  }
  
  fun.a <- function( a, data, groups )
  {
    # prepare data
    #=============
    data[, which( !( colnames( data ) %in% groups[a] ) ) ] -> 
      data.vars ;
    
    data[, which( colnames( data ) %in% groups[a] ) ] -> 
      data.group ;
    
    factor( data.group ) ->  data.group ;
    
    furrr::future_map(
      1:dim( data.vars )[2], 
      fun.b,
      data.vars = data.vars,
      data.group = data.group,
      group.name = groups[a],
      .options = furrr::furrr_options( seed = seed ), .progress = T 
    ) |>
      rbind.force() ->
      output.a ; 
    
    c( "factor", 
       "var1", "var2", 
       "N", "Missing",
       "p-value", "Method",
       "Minimal expected number",
       "Chi-squared method",
       "Yates correction",
       "Chi-squared statistic",
       "Chi-squared degree of freedom",
       "Chi-squared p-value",
       "G-test method",
       "G-test correction",
       "G statistic",
       "G-test degree of freedom",
       "G-test p-value",
       "Fisher method",
       "Fisher p-value",
       "Monte Carlo simulation Chi-squared method",
       "Monte Carlo Chi-squared statistic",
       "Monte Carlo Chi-squared p-value",
       "Cramer's V",
       "Cohen's omega"
    )[-c(1:5)] -> titles.factor
    
    c( "Class", "var1", "var2", "N", "Missing",
       "p-value", "Method",
       "Normality",
       "Homoscedasticity",
       "Anova method",
       "Welch correction",
       "Anova F statistic",
       "Anova degree of freedom numerator",
       "Anova degree of freedom denominator",
       "Anova p-value",
       "Kruskal-Wallis method",
       "Kruskal-Wallis chi-squared statictic",
       "Kruskal-Wallis degree of freedom",
       "Kruskal-Wallis p-value",
       "Permutation Anova method",
       "Number of permutation",
       "Welch correction",
       "Permutation F statistic",
       "Permutation Anova p-value",
       "Student method",
       "Welch correction",
       "StudentT ratio",
       "Student degree of freedom",
       "Student p-value",
       "Wilcoxon method",
       "Continuity correction",
       "Wilcoxon W statistic",
       "Wilcoxon p-value",
       "Mood method",
       "Mood Z statistic",
       "Mood p-value",
       "Permutation Student method",
       "Number of permutation",
       "Welch correction",
       "Permutation T ratio",
       "Permutation Student p-value",
       "Eta-squared correlation ratio",
       "Cohen's f-squared",
       "Direction for size effects",
       "Point biserial correlation coefficient r.pb",
       "Cohen's d",
       "Hedge's g*",
       "Rank biserial correlation",
       "Cliff's delta",
       "Anova residuals Shapiro p-value",
       "Anova residuals Anderson-Darling p-value",
       "Anova residuals Jarque-Bera p-value",
       "Bartlett p-value",
       "Fligner-Killeen p-value",
       "group1 Shapiro p-value",
       "group1 Anderson-Darling p-value",
       "group1 Jarque-Bera p-value",
       "group2 Shapiro p-value",
       "group2 Anderson-Darling p-value",
       "group2 Jarque-Bera p-value",
       "F-test for variances p-value",
       "Ansara-Bradley p-value"
    )[-c(1:5)] -> titles.mix
    
    NULL -> output.tmp
    for ( i in levels( factor( output.a[,1] ) ) )
    {
      if ( grepl( "factor", i ) )
      {
        
        c(  i, groups[a], groups[a], groups[a], groups[a] ) -> levels.tmp
        for (j in strsplit( strsplit( i, "-" )[[1]][3], "_" )[[1]] )
        {
          c( levels.tmp,
             "---",
             rep( j, 7)
          ) -> levels.tmp
        }
        
        rbind.force( output.tmp,
                     levels.tmp, 
                     c( c( i, groups[a], "Variable", "N", "Missing" ), 
                        rep( c( "---", "Group N", "Level", "%", 
                                "CI lb", "CI ub", "CI type", "Count" ), 
                             times = strsplit( i, "-" )[[1]][2] ),
                        titles.factor ),
                     output.a[ output.a[,1] == i, ],
                     empty = "" ) ->
          output.tmp ; 
      }
      
      
      if ( grepl( "numeric", i ) )
      {
        
        c(  i, groups[a], groups[a], groups[a], groups[a] ) -> levels.tmp
        for (j in strsplit( strsplit( i, "-" )[[1]][3], "_" )[[1]] )
        {
          c( levels.tmp,
             "---",
             rep( j, 7)
          ) -> levels.tmp
        }
        
        rbind.force( output.tmp,
                     levels.tmp, 
                     c( c( i, groups[a], "Variable", "N", "Missing" ), 
                        rep( c( "---", "Group N", "-", "Mean", 
                                "CI lb", "CI ub", "CI type", "Sd" ), 
                             times = strsplit( i, "-" )[[1]][2] ),
                        titles.mix ),
                     output.a[ output.a[,1] == i, ],
                     empty = "" ) ->
          output.tmp ; 
      }
      
      if ( grepl( "other", i ) )
      {
        
        c(  i, groups[a], groups[a], groups[a], groups[a] ) -> levels.tmp
        for (j in strsplit( strsplit( i, "-" )[[1]][3], "_" )[[1]] )
        {
          c( levels.tmp,
             "---",
             rep( j, 7)
          ) -> levels.tmp
        }
        
        rbind.force( output.tmp,
                     levels.tmp, 
                     c( c( i, groups[a], "Variable", "N", "Missing" ), 
                        rep( c( "---", "Group N", "-", "-", 
                                "-", "-", "-", "-" ), 
                             times = strsplit( i, "-" )[[1]][2] ),
                        "No tests for other" ),
                     output.a[ output.a[,1] == i, ],
                     empty = "" ) ->
          output.tmp ; 
      }
    }
    output.tmp -> output.a
    
    return( output.a )
  }
  
  fun.b <- function( b, data.vars, data.group, group.name )
  {
   # print(a) ; print(b)
    # prepare data
    data.frame( var = data.vars[,b],
                group = data.group,
                stringsAsFactors = FALSE ) -> 
      df.2var ;
    
    if ( na.rm )
    {
      na.omit( df.2var ) -> df.2var ;
      if ( is.factor( df.2var[,1] ) ) { factor( df.2var[,1] ) -> df.2var[,1] ; }
      if ( is.factor( df.2var[,2] ) ) { factor( df.2var[,2] ) -> df.2var[,2] ; }
    }
    
    # bi
    fun.bivariate( df.2var = df.2var,
                   df = df.2var, 
                   a = 1, b = 2 ) ->
      bi ; 
    
    bi[-c(1:5)] -> bi
    
    # uni
    cbind.force( lapply( 1:nlevels( df.2var$group ),
                         FUN = fun.univariate,
                         variable = df.2var$var,
                         group = df.2var$group ),
                 empty = "" ) ->
      uni ;
    
    # factor
    if ( is.factor( df.2var$var ) )
    {
      cbind.force( colnames( data.vars )[b], 
                   dim( df.2var )[1],
                   ( dim( data.vars )[1] - dim( df.2var )[1] ),
                   data.frame( uni,
                               stringsAsFactors = FALSE ),
                   data.frame( matrix( bi,
                                       nrow = 1 ),
                               stringsAsFactors = FALSE ),
                   empty = "" ) ->
        output.b ;
      
      cbind( cbind( paste0( "factor", "-",
                            nlevels( df.2var$group ), "-",
                            StringContatener( levels( df.2var$group ), "_" ) ),
                    group.name ),
             output.b ) -> 
        output.b ;
    }
    
    # Numeric
    if ( is.numeric( df.2var$var ) )
    {
      cbind.force( colnames( data.vars )[b], 
                   dim( df.2var )[1],
                   ( dim( data.vars )[1] - dim( df.2var )[1] ),
                   uni,
                   data.frame( matrix( bi,
                                       nrow = 1 ),
                               stringsAsFactors = FALSE ),
                   empty = "" ) ->
        output.b ;
      
      cbind( cbind( paste0( "numeric", "-",
                            nlevels( df.2var$group ), "-",
                            StringContatener( levels( df.2var$group ), "_" ) ),
                    group.name ),
             output.b ) -> 
        output.b ;
    }
    
    # Other 
    if ( uni[1,1] == "_" )
    {
      cbind.force( colnames( data.vars )[b], 
                   dim( df.2var )[1],
                   ( dim( data.vars )[1] - dim( df.2var )[1] ),
                   uni,
                   empty = "" ) ->
        output.b ;
      
      cbind( cbind( paste0( "other", "-",
                            nlevels( df.2var$group ), "-",
                            StringContatener( levels( df.2var$group ), "_" ) ),
                    group.name ),
             output.b ) -> 
        output.b ;
    }
    
    # output
    return( output.b )
  }
  
  
  # Load packages
  download.packages( "furrr", "dplyr", 
                 "boot", "binom",   "pwr", "moments", "nortest", 
                 "DescTools"  ) ;
  
  # job
  #====
  rbind.force( lapply( 1:length( groups ),
                       FUN = fun.a,
                       data = data,
                       groups = groups
  ), 
  empty = "" ) ->
    output ;
  
  # end parallel
  future::plan("sequential")
  
  # Output
  #=======
  c( "class", "group", "variable", "N", "Missing", 
     paste( "col", 6:dim( output )[2], sep = "" ) ) ->
    colnames( output ) ;
  
  NULL -> rownames( output ) ;
  
  return( output ) ;
} ; 

# 1.2.15 Function to perform bivaraite plot
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Bivariate.Plot <- function( x, y,
                            by = intersect( names( x ), names( y ) ), 
                            by.x = by, by.y = by,
                            ExportFile,
                            na.rm = TRUE,
                            ncores = NULL )
{
  # Input condition
  if ( !is.data.frame( x ) ) { stop( "x is not a data.frame" );   } ;
  if ( !is.data.frame( y ) ) { stop( "y is not a data.frame" );   } ;
  if ( !is.character( by ) ) { stop( "by is not a string" );   } ;
  if ( !is.character( by.x ) ) { stop( "by.x is not a string" );    } ;
  if ( !is.character( by.y ) ) { stop( "by.y is not a string" );    } ;
  if ( !is.character( ExportFile ) ) { stop( "ExportFile is not a string" );    } ;
  if ( !is.logical( na.rm ) ) { stop( "na.rm is not TRUE or FALSE" );    } ;
  if ( !is.null(ncores) & !is.numeric(ncores) ) { stop( "ncores is not null nor numeric" ) }
  
  # parallel
  if ( !is.null( ncores ) ) { future::plan( "multisession",  workers = ncores ) }
  
  # Domestic functions
  download.packages <- function( PackagesNames, ... )
  {
    # Get a vector with packages names 
    packages1 <- c( PackagesNames, ... ) ;
    
    # Install packages
    for (a in 1:length( packages1 ) )
    {
      try( find.package( packages1[a]), silent = TRUE ) -> test ;
      
      if ( class( test ) == "try-error" )
      { print( packages1[a] ) ; 
        install.packages(  packages1[a] ) ;
      } 
    }
  } ;
  
  plot.Bivariate.unique <- function( vector1, vector2, ExportFile, na.rm = TRUE,
                                     name1 = "", name2 = "" )
  {
    # Names
    if ( name1 == "" ) { name1 <- deparse( substitute( vector1 ) ) ; }
    if ( name2 == "" ) { name2 <- deparse( substitute( vector2 ) ) ; }
    
    # Deal with NA
    if ( na.rm )
    {
      cbind( vector1, vector2 ) -> tmp.df ;
      na.omit( tmp.df ) -> tmp.df ;
      tmp.df[,1] -> tmp.var1 ;
      tmp.df[,2] -> tmp.var2 ;
    } else
    {
      vector1 -> tmp.var1 ;
      vector2 -> tmp.var2 ;
    }
    
    # Job
    
    # Two numerics
    if  ( is.numeric( vector1 ) 
          & is.numeric( vector2 ) )
    {
      paste( ExportFile, "/", "ScatterPlot_", name1, "_vs_", name2,
             ".png", sep = "" ) -> tmp.name1 ;
      png( tmp.name1 ) ;
      plot( tmp.var2 ~ tmp.var1, ylab = name2, 
            xlab = name1 ) ; 
      abline( lm( tmp.var2 ~ tmp.var1 ), col = "red" ) ;
      dev.off() ;
    } ;
    
    # Two factors
    if  ( is.factor( vector1 ) & is.factor( vector2 )  ) 
    {
      if ( nlevels(tmp.var1) > 1 | nlevels(tmp.var2) > 1 )
      {
        tmp.var1 <- factor( tmp.var1 ) ;
        tmp.var2 <- factor( tmp.var2 ) ;
        
        paste( ExportFile, "/", "MosaicPlot", name1, "_vs_", 
               name2,
               ".png", sep = "" ) -> tmp.name1 ;
        png( tmp.name1 ) ;
        mosaicplot( tmp.var2 ~ tmp.var1, 
                    ylab = name1, xlab = name2, main = "" ) ;
        dev.off() ;
        
        paste( ExportFile, "/", "BarPLot", name1, "_vs_", 
               name2,
               ".png", sep = "" ) -> tmp.name1 ;
        png( tmp.name1 ) ;
        barplot( table( tmp.var1, tmp.var2 ), leg = TRUE, beside = TRUE, 
                 ylab = "Count",
                 main = paste( "Distribution of", name1, "in function of",
                               name2 ) ) ;    
        dev.off() ;
        
        if ( (nlevels( tmp.var1 ) + nlevels( tmp.var2 )) <= 12 )
        {
          paste( ExportFile, "/", "DensityBarPlot_", name1, "_vs_", name2,
                 ".png", sep = "" ) -> tmp.name1 ;
          png( tmp.name1 ) ;
          prop.table( table( tmp.var1, tmp.var2 ) ) -> PropTab ;
          as.numeric( PropTab ) + 0.01 ->  y.coord ; 
          round( y.coord * 100, digits = 1 ) -> perc ; 
          barplot( PropTab, leg = TRUE, beside = TRUE, 
                   ylab = "Percentages", ylim = c( 0, (max(perc) / 100 + 0.1 ) ),
                   main = paste( "Distribution of", name1, "in function of",
                                 name2 ) ) -> x.coord ; 
          as.numeric( x.coord ) -> x.coord ;
          paste( perc, "%" ) -> perc ; 
          text( x.coord, y.coord,  perc, cex = 1 ) ;
          dev.off() ;
        }
        else
        {
          paste( ExportFile, "/", "DensityBarPlot_", name1, "_vs_", name2,
                 ".png", sep = "" ) -> tmp.name1 ;
          png( tmp.name1 ) ;
          prop.table( table( tmp.var1, tmp.var2 ) ) -> PropTab ;
          barplot( PropTab, leg = TRUE, beside = TRUE, 
                   ylab = "Percentages",
                   main = paste( "Distribution of", name1, "in function of",
                                 name2 ) ) ; 
          dev.off() ;
        } ;
      }
    } ;
    
    # One factor and one numeric, first way
    if  (  is.numeric( vector1 )
           & is.factor( vector2 ) )
    {
      tmp.var2 <- factor( tmp.var2 ) ;
      
      paste( ExportFile, "/", "BoxPlot", name1, "_vs_", 
             name2,
             ".png", sep = "" ) -> tmp.name1 ;
      png( tmp.name1 ) ;
      plot( tmp.var1 ~ tmp.var2, ylab = name1, 
            xlab = name2 ) ; 
      dev.off() ;
      
      paste( ExportFile, "/", "StripChart_", name1, "_vs_", name2,
             ".png", sep = "" ) -> tmp.name1 ;
      png( tmp.name1 ) ;
      stripchart( tmp.var1 ~ tmp.var2, vertical = TRUE, xlab = name2, 
                  ylab = name1 ) ; 
      points( tapply( X = tmp.var1, INDEX = tmp.var2, FUN = mean), col = "red", type = "o" ) ;
      dev.off() ;
    } ;
    
    # One factor and one numeric, second way
    if   ( is.factor( vector1 )
           & is.numeric( vector2 ) )
    {
      tmp.var1 <- factor( tmp.var1 ) ;
      
      paste( ExportFile, "/", "BoxPlot_", name1, "_vs_", name2,
             ".png", sep = "" ) -> tmp.name1 ;
      png( tmp.name1 );
      plot( tmp.var2 ~ tmp.var1, ylab = name2, 
            xlab = name1 ) ; 
      dev.off() ;
      
      paste( ExportFile, "/", "StripChart_", name1, "_vs_", name2,
             ".png", sep = "" ) -> tmp.name1 ;
      png( tmp.name1 ) ;
      stripchart( tmp.var2 ~ tmp.var1, vertical = TRUE, xlab = name1, 
                  ylab = name2 ) ; 
      points( tapply( X = tmp.var2, INDEX = tmp.var1, FUN = mean), col = "red", type = "o" ) ;
      dev.off() ;
    } ;
  } ;
  
  fun.a <- function( a, fun.b, x.length, df, ExportFile, na.rm )
  {
    lapply( (x.length + 1):dim(df)[2],
            FUN = fun.b,
            a = a,
            df = df,
            ExportFile = ExportFile,
            na.rm = na.rm
    )
  }
  
  fun.b <- function( b, a, df, ExportFile, na.rm )
  {
     print("a") ; print(a) ; print("b") ; print(b) ;
    plot.Bivariate.unique( df[,a], df[,b], 
                           ExportFile = ExportFile,
                           na.rm = na.rm,
                           name1 = colnames( df )[a],
                           name2 = colnames( df )[b]
    ) ;
    
  }
  
  # activate packages
  download.packages( "furrr" ) ;
  
  # data preparation
  merge( x, y, by = by, by.x = by.x, by.y = by.y ) -> df ;
  
  # variable to source
  dim( x )[2] -> x.length ;
  
  # job
  furrr::future_map(
    1:x.length,
    fun.a,
    fun.b = fun.b,
    x.length = x.length,
    df = df,
    ExportFile = ExportFile,
    na.rm = na.rm,
    .options = furrr::furrr_options(seed = TRUE), .progress = T 
  )
  
  # end parallel
  future::plan("sequential")
} 

# 1.2.16 Function to perform trivaraite plot
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Trivariate.Plot <- function( x, y, z,
                             by = NULL, 
                             by.x = by, 
                             by.y = by, 
                             by.z = by, 
                             ExportFile, 
                             na.rm = TRUE,
                             ncores = NULL )
{
  # Input condition
  if ( !is.data.frame( x ) ) { stop( "x is not a data.frame" );   } ;
  if ( !is.data.frame( y ) ) { stop( "y is not a data.frame" );   } ;
  if ( !is.data.frame( z ) ) { stop( "z is not a data.frame" );   } ;
  if ( !is.character( by ) ) { stop( "by is not a string" );   } ;
  if ( !is.character( by.x ) ) { stop( "by.x is not a string" );    } ;
  if ( !is.character( by.y ) ) { stop( "by.y is not a string" );    } ;
  if ( !is.character( by.z ) ) { stop( "by.z is not a string" );    } ;
  if ( !is.character( ExportFile ) ) { stop( "ExportFile is not a string" );    } ;
  if ( !is.logical( na.rm ) ) { stop( "na.rm is not TRUE or FALSE" );    } ;
  if ( !is.null(ncores) & !is.numeric(ncores) ) { stop( "ncores is not null nor numeric" ) }
  
  # parallel
  if ( !is.null( ncores ) ) { future::plan( "multisession",  workers = ncores ) }
  
  # Domestic functions
  download.packages <- function( PackagesNames, ... )
  {
    # Get a vector with packages names 
    packages1 <- c( PackagesNames, ... ) ;
    
    # Install packages
    for (a in 1:length( packages1 ) )
    {
      try( find.package( packages1[a]), silent = TRUE ) -> test ;
      
      if ( class( test ) == "try-error" )
      { print( packages1[a] ) ; 
        install.packages(  packages1[a] ) ;
      } 
    }
  } ;
  # Domestic functions
  active.packages <- function( PackagesNames, ... )
  {
    # Get a vector with packages names 
    packages1 <- c( PackagesNames, ... ) ;
    
    # Require or install and require packages
    for ( a in 1:length( packages1 ) )
    {
      if ( !require( packages1[a], character.only = TRUE  ) )
      { install.packages( packages1[a] ) ; require( packages1[a], character.only = TRUE ) } ;
    } ;
  } ;
  
  active.packages( "scatterplot3d", "ggplot2", "ggtern", "ggmosaic" ) ;
  
  
  plot.Trivariate.unique <- function( vector1, vector2, vector3,
                                      ExportFile, na.rm = TRUE,
                                      name1 = "", name2 = "", name3 = "" )
  {
    # Names
    if ( name1 == "" ) { name1 <- deparse( substitute( vector1 ) ) ; }
    if ( name2 == "" ) { name2 <- deparse( substitute( vector2 ) ) ; }
    if ( name3 == "" ) { name3 <- deparse( substitute( vector3 ) ) ; }
    
    # Make df
    vector1 -> var1 ;
    vector2 -> var2 ;
    vector3 -> var3 ;
    data.frame( var1 = var1, var2 = var2, var3 = var3 ) -> df ;
    
    # Deal with NA
    if ( na.rm )
    {
      na.omit( df ) -> df ;
    }
    
    
    # Job
    
    # Three numerics
    if  ( ( is.numeric( vector1 )  ) 
          & ( is.numeric( vector2 )  )
          & ( is.numeric( vector3 )  ) )
    {
      paste( ExportFile, "/", "ScatterPlot3d_", name1, "_", name2, "_", name3,
             ".png", sep = "" ) -> tmp.name1 ;
      
      png( tmp.name1 ) ;
      scatterplot3d( df, 
                     type = "h", highlight.3d = TRUE,
                     angle=60, pch = 16, 
                     xlab = name1,
                     ylab = name2,
                     zlab = name3, 
                     main = "Scatterplot 3d" ) -> s3d ;
      s3d$plane3d(  lm( var3 ~  var1 + var2, data = df ), lty.box = "solid" ) ;
      dev.off() ;
      
      
      paste( ExportFile, "/", "ScatterPlot2d_", name1, "_", name2, "_", name3,
             ".png", sep = "" ) -> tmp.name1 ;
      
      ggplot(data = df ) +
        aes( x = var1, y = var3, size = var2 ) +
        geom_point( shape = 1) + 
        geom_abline( aes( intercept = lm( residuals( lm( var3 ~ var2, data = df ) ) ~ residuals( lm( var1 ~ var2, data = df ) ) )$coefficients[1],
                          slope = lm( residuals( lm( var3 ~ var2, data = df ) ) ~ residuals( lm( var1 ~ var2, data = df ) ) )$coefficients[2], 
                          colour = "Partial" ) ) +
        geom_abline( aes( intercept = lm( var3 ~ var1, data = df )$coefficients[1],
                          slope = lm( var3 ~ var1, data = df )$coefficients[2], 
                          colour = "Normal" ) ) +
        labs( title = "ScatterPlot 2d",
              x = name1,
              y = name3,
              size = name2,
              colour = "Correlation" )  -> g1 ;
      ggsave( tmp.name1, g1 ) ;
      
      
      paste( ExportFile, "/", "TernaryPlot_", name1, "_", name2, "_", name3,
             ".png", sep = "" ) -> tmp.name1 ;
      
      ggtern(data = df ) + 
        aes( x = var1, y = var2, z = var3, colour = var3 ) +
        geom_point() + 
        geom_interpolate_tern( aes( value = var3 ),
                               colour   = "grey10",
                               formula  = value ~ x + y,
                               method   = "lm" ) +
        theme_showarrows() +
        labs( title = "TernaryPlot",
              x = name1,
              y = name2,
              z = name3,
              colour = name3 ) -> g1 ;
      ggsave( tmp.name1, g1 ) ;
    } ;
    
    # Three factors
    if  ( is.factor( vector1 ) & is.factor( vector2 ) & 
          is.factor( vector3 )) 
    {
      df$var1 <- factor( df$var1 ) ;
      df$var2 <- factor( df$var2 ) ;
      df$var3 <- factor( df$var3 ) ;
      
      paste( ExportFile, "/", "MosaicPlot_", name1, "_", 
             name2, "_", name3,
             ".png", sep = "" ) -> tmp.name1 ;
      
      ggplot( data = df ) +
        geom_mosaic( aes( x = product( var1, var2 ), fill = var1 ) ) + 
        theme( axis.text.x = element_text ( angle = -40, hjust = 0.1 ) ) + 
        guides( fill = guide_legend( title = name2, reverse = TRUE ) ) + 
        facet_grid( var3 ~ . ) +
        labs( title = "Mosaic plot", x = name1, 
              subtitle = paste( "Grid on", name3 ) ) -> g1 ;
      ggsave( tmp.name1, g1 ) ;
      
      
      paste( ExportFile, "/", "BarPlot_", name1, "_", 
             name2, "_", name3, ".png", sep = "" ) -> tmp.name1 ;
      
      ggplot( data = df ) +
        geom_bar(aes( x = var1, fill = var2 ),
                 stat = "count", 
                 position = "dodge" ) + 
        facet_grid( var3 ~ . ) +
        labs( title = "Bar plot", x = name1, y = "Count", fill = name2,
              subtitle = paste( "Grid on", name3 ) ) -> g1 ;
      ggsave( tmp.name1, g1 ) ;
      
      
      paste( ExportFile, "/", "CountPlot_", name1, "_", 
             name2, "_", name3, ".png", sep = "" ) -> tmp.name1 ;
      
      ggplot( data = df ) +
        aes( x = var1, y = var2 ) +
        geom_count() + 
        facet_grid( var3 ~ . ) +
        labs( title = "Count plot", x = name1, y = name2,
              subtitle = paste( "Grid on", name3 ) ) -> g1 ;
      ggsave( tmp.name1, g1 ) ;
    } 
    
    # Two factors and one numeric
    if  ( ( is.numeric( vector1 ) ) 
          & ( is.factor( vector2 ) ) 
          & ( is.factor( vector3 ) ) )
    {
      df$var2 <- factor( df$var2 ) ;
      df$var3 <- factor( df$var3 ) ;
      
      
      paste( ExportFile, "/", "BoxPlot_", name1, "_", 
             name2, "_", name3, ".png", sep = "" ) -> tmp.name1 ;
      
      ggplot( data = df ) +
        aes( x = 1, y = var1 ) +
        geom_boxplot() + 
        facet_grid( var3 ~ var2 ) +
        labs( title = "Box plot", x = "", y = name1,
              subtitle = paste( "Grid on", name2, "horizontaly and", name3, 
                                "verticaly" ) ) -> g1 ;
      ggsave( tmp.name1, g1 ) ;
      
      
      paste( ExportFile, "/", "Histogram_", name1, "_", 
             name2, "_", name3, ".png", sep = "" ) -> tmp.name1 ;
      
      ggplot( data = df ) +
        aes( x = var1, y = ) +
        geom_histogram( binwidth = diff( 
          pretty( range(df$var1), n = nclass.FD( df$var1), min.n = 1)[1:2] ),
          fill = "white", colour = "darkgrey" ) + 
        facet_grid( var3 ~ var2 ) +
        labs( title = "Histogram", x = name1,
              subtitle = paste( "Grid on", name2, "horizontaly and", name3, 
                                "verticaly" ) ) -> g1 ;
      ggsave( tmp.name1, g1 ) ;
      
      
      paste( ExportFile, "/", "DensityCurve_", name1, "_", 
             name2, "_", name3, ".png", sep = "" ) -> tmp.name1 ;
      
      ggplot( data = df ) +
        aes( x = var1 ) +
        geom_density() + 
        facet_grid( var3 ~ var2 ) +
        labs( title = "Density curve", x = name1, y = "Density",
              subtitle = paste( "Grid on", name2, "horizontaly and", name3, 
                                "verticaly" ) ) -> g1 ;
      ggsave( tmp.name1, g1 ) ;
      
    } ;
    
    # One factor and Two numerics
    if   ( ( is.factor( vector1 ) ) 
           & ( is.numeric( vector2 )  )
           & ( is.numeric( vector3 )  ) )
    {
      df$var1 <- factor( df$var1 ) ;
      
      
      paste( ExportFile, "/", "ScatterplotOneWindow_", name1, "_", name2,
             "_", name3,  ".png", sep = "" ) -> tmp.name1 ;
      
      ggplot( data = df ) +
        aes( x = var2, y = var3, colour = var1 ) +
        geom_point() + 
        geom_smooth( method = "lm", se = FALSE ) +
        labs( title = "Scatter plot on groups", x = name2, 
              y = name3, colour = name1 ) -> g1 ;
      ggsave( tmp.name1, g1 ) ;
      
      paste( ExportFile, "/", "ScatterplotGrid_", name1, "_", name2,
             "_", name3,  ".png", sep = "" ) -> tmp.name1 ;
      
      ggplot( data = df ) +
        aes( x = var2, y = var3 ) +
        geom_point() + 
        geom_smooth( method = "lm", se = FALSE ) +
        facet_grid( var1 ~ . ) +
        labs( title = "Scatter plot on groups", x = name2, y = name3, 
              subtitle = paste( "Grid on", name1 ) ) -> g1 ;
      ggsave( tmp.name1, g1 ) ;
    } ;
  } ;
  
  fun.a <- function( a, df, ExportFile, na.rm )
  {
    lapply( (dim(x)[2] + 1):(dim(x)[2] + dim(y)[2] - 1),
            FUN = fun.b,
            a = a,
            df = df,
            ExportFile = ExportFile,
            na.rm = na.rm ) ;
  }
  
  fun.b <- function( b, a, df, ExportFile, na.rm )
  {
    lapply( (dim(x)[2] + dim(y)[2]):(dim(data)[2]),
            FUN = fun.c,
            a = a,
            b = b,
            df = df,
            ExportFile = ExportFile,
            na.rm = na.rm
    ) ;
  }
  
  fun.c <- function( c, a, b, df, ExportFile, na.rm )
  {
    print( paste( "a:", a) ) ; print( paste( "b:", b) ) ; print( paste( "c:", c) )
    
    if ( a != b & a != c & b != c )
    {
      plot.Trivariate.unique( df[,a], df[,b],df[,c], 
                              ExportFile = ExportFile,
                              na.rm = na.rm,
                              name1 = colnames( df )[a],
                              name2 = colnames( df )[b],
                              name3 = colnames( df )[c]
      ) ;
    } 
  }
  
  # activate packages
  download.packages( "furrr" ) ;
  
  # Merge tables 
  merge( x, y, by = by, by.x = by.x, by.y = by.y ) -> data ;
  
  merge( data, z, by = by, by.x = by.x, by.y = by.z ) -> data ;
  
  # job
  furrr::future_map( 1:dim(x)[2],
                     fun.a,
                     df = data,
                     ExportFile = ExportFile,
                     na.rm = na.rm,
                     .options = furrr::furrr_options(seed = TRUE), .progress = T 
  ) ;
  
  # end parallel
  future::plan("sequential")
} 

# 1.3 Special graphics functions   -----------------------------
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 1.3.1
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


# 1.4 Special statistics functions   -----------------------------
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 1.4.1 Multiple regression Function
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Multiple.Regressions <- function( 
    data,
    na.omit = TRUE,
    outcomes, 
    families,
    changing.predictors,
    fixed.predictors = "",
    FULL = TRUE,
    ANOVA.ANODE = TRUE,
    HMF.test = TRUE,
    conf.level = 0.95,
    pvalue.round = 3,
    round = 2,
    PLOT = FALSE, 
    ExportName = paste( getwd(),
                        "/",
                        sep = ""), 
    parallel.outcomes = TRUE,
    ncores = NULL
)
{
  # input quality controls 
  if ( !is.data.frame( data ) ) { stop ( "data is not of dataframe type" ) } ;
  if ( any( is.na( data ) ) ) { warning( "data countains NA" ) } ;
  if ( tibble::is_tibble( data ) ) { data.frame( data ) -> data ; } 
  if ( !is.logical( na.omit ) ) { stop( "na.omit is not a logical" ) } ;
  if ( !is.list( outcomes ) ) { stop( "outcomes is not a list" ) } ;
  if ( !is.character( unlist( outcomes ) ) ) { stop( "outcomes doesn't countain character" ) } ;
  if ( !is.character( families ) ) { stop( "families is not a vector of character type" ) } ;
  if ( !all( families %in% c( "multinomial", "ordinal", "gaussian", "binomial", "poisson", "quasibinomial", "quasipoisson" ) ) ) 
  { stop( "families contains a non supported distribution" ) } ;
  if ( !is.list( changing.predictors ) ) { stop( "changing.predictors is not a list" ) } ;
  if ( !is.character( unlist( changing.predictors ) ) ) { stop( "changing.predictors doesn't countain character" ) } ;
  if ( !is.character( fixed.predictors ) ) { stop( "fixed.predictors is not a vector of character type" ) } ;
  if ( !is.logical( FULL ) ) { stop( "FULL is not a logical" ) } ;
  if ( !is.logical( ANOVA.ANODE ) ) { stop( "ANOVA.ANODE is not a logical" ) } ;
  if ( !is.logical( HMF.test ) ) { stop( "HMF.test is not a logical" ) } ;
  if ( !is.numeric( conf.level ) ) { stop( "conf.level is not numeric" ) } ;
  if ( !( is.numeric( pvalue.round ) | 
          is.null( pvalue.round ) ) ) { stop( "pvalue.round is neither numeric, neither NULL" );    } ;
  if ( !( is.numeric( round ) | 
          is.null( round ) ) ) { stop( "round is neither numeric, neither NULL" );    } ;
  if ( !is.logical( PLOT ) ) { stop( "PLOT is not a logical" ) } ;
  if ( !is.character( ExportName ) ) { stop( "ExportName is not a vector of character type" ) } ;
  if ( !is.logical( parallel.outcomes ) ) { stop( "parallel.outcomes is not a logical" ) } ;
  if ( !is.null(ncores) & !is.numeric(ncores) ) { stop( "ncores is not null nor numeric" ) }
  
  # parallel
  if ( !is.null( ncores ) ) { future::plan( "multisession",  workers = ncores ) }
  
  # Domestic functions
  download.packages <- function( PackagesNames, ... )
  {
    # Get a vector with packages names 
    packages1 <- c( PackagesNames, ... ) ;
    
    # Install packages
    for (a in 1:length( packages1 ) )
    {
      try( find.package( packages1[a]), silent = TRUE ) -> test ;
      
      if ( class( test ) == "try-error" )
      { print( packages1[a] ) ; 
        install.packages(  packages1[a] ) ;
      } 
    }
  } ;
  
  rbind.force <- function( data, ..., keep.col = FALSE, empty = NA ) 
  {
    # Unify data
    list( data, ... ) -> input ;
    
    # include list elements
    repeat 
    {
      if (  !any( unlist( lapply( input, class ) ) == "list" ) ) { break }  
      
      which( unlist( lapply( input, class ) ) == "list" )[1] -> a ;
      input[[a]] -> tmp ;
      input[[a]] <- NA ;
      c( input[1:a],  tmp, input[ (a + 1):length( input ) ] ) -> 
        input ;
    }
    
    input[ !is.na( input ) ] ->
      input ;
    
    # delete NULL data and transformt vector in data.frame
    for ( a in 1:length( input ) )
    {
      if ( is.null( dim( input[[a]] ) ) )
      {
        if ( is.null( input[[a]] ) )
        {
          input[[a]] <- NA ;
        } else
        {
          data.frame( matrix( input[[a]], nrow = 1 ),
                      stringsAsFactors = FALSE ) -> input[[a]] ; 
        }
      }
      
      if ( all( dim( input[[a]] ) == 0 ) )
      {
        input[[a]] <- NA ;
      }
    }
    
    input[ !is.na( input ) ] ->
      input ;
    
    # test data class
    if ( !all( unlist( lapply( input, is.data.frame ) ) |
               unlist( lapply( input, is.matrix ) ) |
               unlist( lapply( input, is.vector ) ) ) )
    { stop( "Some argument are not data.frame, neither vector" ) ;
      ; } ;
    
    # Set primer
    input[[1]] -> output ; 
    
    # job in case we keep columns 
    if ( keep.col & length( input ) >1 )
    {
      for ( a in 2:length( input ) )
      { 
        output -> x ;
        input[[a]] -> y ; 
        
        for (a in 1:dim(x)[2]) { x[,a] <- as.character(x[,a])}
        for (a in 1:dim(y)[2]) { y[,a] <- as.character(y[,a])}
        
        x.diff <- setdiff(colnames(x), colnames(y))
        y.diff <- setdiff(colnames(y), colnames(x))
        
        if( dim(x)[1] > 0 ) { x[, c(as.character(y.diff))] <- empty ; }
        if( dim(y)[1] > 0 ) { y[, c(as.character(x.diff))] <- empty ; }
        
        rbind(x, y) -> output ;
      } 
    }
    
    # job in case we do not keep columns
    if ( !keep.col & length( input ) >1 )
    {
      for ( a in 2:length( input ) )
      { 
        output -> x ;
        input[[a]] -> y ; 
        
        colnames(x) <- paste( "X",
                              1:dim( x )[2], 
                              sep = "" ) ;
        colnames(y) <- paste( "X",
                              1:dim( y )[2], 
                              sep = "" ) ;
        
        for (a in 1:dim(x)[2]) { x[,a] <- as.character(x[,a])}
        for (a in 1:dim(y)[2]) { y[,a] <- as.character(y[,a])}
        
        x.diff <- setdiff(colnames(x), colnames(y))
        y.diff <- setdiff(colnames(y), colnames(x))
        
        if( dim(x)[1] > 0 ) { x[, c(as.character(y.diff))] <- empty ; }
        if( dim(y)[1] > 0 ) { y[, c(as.character(x.diff))] <- empty ; }
        
        rbind(x, y) -> output ;
      } 
    }
    
    return( output ) ;
  } 
  
  cbind.force <- function( data, ... , keep.row = FALSE, empty = NA ) 
  {
    # Unify data
    list( data, ... ) -> input ;
    
    # include list elements
    repeat 
    {
      if (  !any( unlist( lapply( input, class ) ) == "list" ) ) { break }  
      
      which( unlist( lapply( input, class ) ) == "list" )[1] -> a ;
      input[[a]] -> tmp ;
      input[[a]] <- NA ;
      c( input[1:a],  tmp, input[ (a + 1):length( input ) ] ) -> 
        input ;
    }
    
    input[ !is.na( input ) ] ->
      input ;
    
    # delete NULL data and transform vector in data.frame
    for ( a in 1:length( input ) )
    {
      if ( is.null( dim( input[[a]] ) ) )
      {
        if ( is.null( input[[a]] ) )
        {
          input[[a]] <- NA ;
        } else
        {
          data.frame( input[[a]],
                      stringsAsFactors = FALSE ) -> input[[a]] ; 
          "vector" -> colnames(  input[[a]] ) ;
        }
      }
      
      if ( all( dim( input[[a]] ) == 0 ) )
      {
        input[[a]] <- NA ;
      }
    }
    
    input[ !is.na( input ) ] ->
      input ;
    
    # test data class
    if ( !all( unlist( lapply( input, is.data.frame ) ) |
               unlist( lapply( input, is.matrix ) ) |
               unlist( lapply( input, is.vector ) ) ) )
    { stop( "Some argument are not data.frame, neither vector" ) ;
      ; } ;
    
    # Set primer
    input[[1]] -> output ; 
    
    # job in case we keep columns 
    if ( keep.row & length( input ) > 1 )
    {
      for ( a in 2:length( input ) )
      { 
        output -> x ;
        input[[a]] -> y ; 
        
        for (a in 1:dim(x)[2]) { x[,a] <- as.character(x[,a])}
        for (a in 1:dim(y)[2]) { y[,a] <- as.character(y[,a])}
        
        x.diff <- setdiff(rownames(x), rownames(y))
        y.diff <- setdiff(rownames(y), rownames(x))
        
        if( dim(x)[2] > 0 ) { x[ c(as.character(y.diff)), ] <- empty ; }
        if( dim(y)[2] > 0 ) { y[ c(as.character(x.diff)), ] <- empty ; }
        
        cbind(x, y) -> output ;
      } 
    }
    
    # job in case we do not keep columns
    if ( !keep.row & length( input ) > 1 )
    {
      for ( a in 2:length( input ) )
      { 
        output -> x ;
        input[[a]] -> y ; 
        
        if ( dim( x )[1] > 0 ) 
        {
          rownames(x) <- paste( "X",
                                1:dim( x )[1], 
                                sep = "" ) ;
        }
        
        if ( dim( y )[1] > 0 ) 
        {
          rownames(y) <- paste( "X",
                                1:dim( y )[1], 
                                sep = "" ) ;
        }
        
        
        
        for (a in 1:dim(x)[2]) { x[,a] <- as.character(x[,a])}
        for (a in 1:dim(y)[2]) { y[,a] <- as.character(y[,a])}
        
        x.diff <- setdiff(rownames(x), rownames(y))
        y.diff <- setdiff(rownames(y), rownames(x))
        
        if( dim(x)[2] > 0 ) { x[ c(as.character(y.diff)), ] <- empty ; }
        if( dim(y)[2] > 0 ) { y[ c(as.character(x.diff)), ] <- empty ; }
        
        cbind(x, y) -> output ;
      } 
    }
    
    return( output ) ;
  } ;
  
  String.Contatener <- function( vector, separator )
  {   
    # exclude NA
    na.omit( vector ) -> vector ;
    
    # selection of length for loop
    if ( length( vector ) >= 2) 
    { 
      # stock fisrt element
      tmp.val1 <- vector[1] ;
      
      # loop to concatenate the nect elements
      for ( a in 2:length( vector ) ) 
      { 
        tmp.val1 <- paste( tmp.val1, vector[a], sep = separator ) ; 
      } ;
    } 
    else
    {
      tmp.val1 <- vector ;
    } ;
    
    return( tmp.val1 ) ;
  } ;
  
  p.round <- function( data, digits = 3 )
  {
    if (digits == 1)
    { "" -> tmp1 ; } else 
    { rep( "0", digits - 1 ) -> tmp1 ; }
    
    "0." -> tmp2 ;
    for( a in 1:length(tmp1) )
    {
      paste( tmp2, tmp1[a], sep = "" ) -> tmp2 ;
    }
    
    paste( tmp2, "1", sep = "" ) -> pval ;
    
    for ( a in 1:length(data) )
    {
      if ( !is.na( data[a] ) )
      {
        if ( data[a] >= as.numeric( pval ) )
        {
          round( data[a], digits = digits ) -> data[a] ;
        }
      }
    }
    
    data[ data < as.numeric( pval ) ] <- paste( "< ", pval, sep = "" ) ;
    
    return( data ) ;
  }
  
  IFELSE <- function( condition, true, false )
  {
    if (condition)
    {
      return( true )
    } else
    {
      return( false )
    }
  }
  
  cohen.f2 <- function( model, pseudo.R2 = FALSE, family )
  {
    attr(terms(model), 'term.labels') -> terms1 ; 
    as.character( terms(model) )[2] -> outcome ;
    
    NULL -> f2 ;
    
    if ( !pseudo.R2 )
    {
      for ( a in 1:length(terms1) )
      {
        if ( length(terms1) == 1 )
        { 
          stats::update( model, reformulate( "1" ) ) -> model.bis ;
        } else
        {
          stats::update( model, reformulate( terms1[-a] ) ) -> model.bis ; 
        }
        
        c( f2, 
           (summary( model )$r.squared -  summary( model.bis  )$r.squared ) / (1 - summary( model )$r.squared) ) -> 
          f2 ;
      }
    }  
    
    if ( pseudo.R2 & any( class( model ) == "glm" ) )
    {
      for ( a in 1:length(terms1) )
      {
        if ( length(terms1) == 1 )
        { 
          stats::update( model, reformulate( "1", outcome ), family = family )-> model.bis ;
        } else
        {
          stats::update( model, reformulate( terms1[-a], outcome ), family = family ) -> model.bis ; 
        }
        
        c( f2, 
           (MuMIn::r.squaredLR( model, stats::update( model, reformulate( "1", outcome ), family = family  ) )[1] -  MuMIn::r.squaredLR( model.bis, stats::update( model, reformulate( "1" ), family = family ) )[1]  ) / (1 -  MuMIn::r.squaredLR( model, stats::update( model, reformulate( "1", outcome ), family = family ) )[1] )  ) -> 
          f2 ;
      }
    }
    
    if ( pseudo.R2 & all( class( model ) != "glm" ) )
    {
      for ( a in 1:length(terms1) )
      {
        if ( length(terms1) == 1 )
        { 
          stats::update( model, reformulate( "1", outcome ) )-> model.bis ;
        } else
        {
          stats::update( model, reformulate( terms1[-a], outcome ) ) -> model.bis ; 
        }
        
        c( f2, 
           (MuMIn::r.squaredLR( model, stats::update( model, reformulate( "1", outcome )  ) )[1] -  MuMIn::r.squaredLR( model.bis, stats::update( model, reformulate( "1" ) ) )[1]  ) / (1 -  MuMIn::r.squaredLR( model, stats::update( model, reformulate( "1", outcome ) ) )[1] )  ) -> 
          f2 ;
      }
    }
    
    terms1 -> names( f2 ) ;
    
    return( f2 )
  }
  
  Systematic.FP <- function( output, predictors, family, data, na.omit )
  {
    if( any( grepl( ":", predictors ) ) )
    {
      predictors[ !grepl( ":", predictors ) ] -> predictors ; 
    }
    
    require( mfp )
    data |>
      base::subset( select = predictors ) |>
      dplyr::select_if( is.numeric ) |>
      colnames() -> 
      pred.num ;
    
    c( "Predictors", "df.initial", "select", "alpha", 
       "df.final", "power1", "power2" ) ->
      return1 ;
    
    for ( a in pred.num )
    {
      paste( "fp(",
             a,
             ",df = 4, select = 1, scale = TRUE)") -> 
        fp ;
      
      if ( na.omit == TRUE ) { na.omit( data ) -> data } 
      
      reformulate( c(fp, predictors[ which( predictors != a) ] ), output ) |>
        mfp::mfp( 
          family = family,
          data = data ) -> 
        tmp.mfp ;
      
      tmp.mfp$fptable[a,] |>
        as.matrix() |>
        (function(x) c( a,x) )() |>
        (function(x) rbind( return1, x ) )() ->
        return1 ;
    }
    
    NULL -> rownames(return1) ;
    
    return( return1 )
  }
  
  residuals.polr <- function( model )
  {
    factor( model$model[,1] ) -> multinom.var ;
    
    NULL -> disjonctif.table ;
    
    for ( a in 1:nlevels( multinom.var ) )
    {
      as.character( multinom.var ) -> tmp.var ;
      
      paste( levels(multinom.var)[a], "a", sep = "" ) -> 
        tmp.var[ tmp.var == levels(multinom.var)[a] ] ;
      0 -> tmp.var[ tmp.var != paste( levels(multinom.var)[a], "a", sep = "" ) ] ;
      1 -> tmp.var[ tmp.var == paste( levels(multinom.var)[a], "a", sep = "" ) ] ;
      cbind( disjonctif.table, 
             as.numeric( as.character( tmp.var ) ) ) -> 
        disjonctif.table ;
      
      levels(multinom.var)[a] -> 
        colnames( disjonctif.table )[ ncol( disjonctif.table ) ] ;
    }
    
    disjonctif.table - model$fitted.values -> output ;
    
    return( output )
  }
  
  Normality.Plot.Unique <- function( vector, name )
  {
    par( mfrow = c( 2, 2), oma = c( 0, 0, 2, 0) )
    
    # Clean missing value
    na.omit( vector ) -> vector ;
    as.numeric( vector ) -> vector ;
    
    # plot histogram
    hist( vector, main = "Histogram", xlab = "Variable", col = "blue" ) ;
    round( moments::kurtosis( vector ), digits = 2 ) -> tmp.val1 ;
    round( moments::skewness( vector ), digits = 2 ) -> tmp.val2 ;
    paste( "Kurtosis: ", tmp.val1, " ; ", "Skewness: ", tmp.val2, sep = "" ) -> tmp.name1 ;
    title( sub = tmp.name1 ) ;
    
    # plot density 
    plot( density( vector ), 
          main = "Density plot", xlab = "Variable", col = "blue" ) ;
    curve( dnorm( x, mean( vector ), sd( vector ) ), add = TRUE, col = "red", lwd = 2, lty = 2 ) ;
    abline( v = mean( vector ), col = "blue", lwd = 2, lty = 2) ;
    abs( range( vector )[2] - range( vector )[1] ) / 20 -> legend.distance1 ;
    abs( range( density( vector )$y )[2] - range( density( vector )$y )[1] ) / 20 -> legend.distance2 ;
    text( x = mean( vector ) + legend.distance1, y = legend.distance2, expression( mu ), col = "blue" ) ;
    legend( x = "topright", lty = c( 1, 2 ), col = c( "blue", "red" ), c( "Sample", "Normal" ), cex = 0.6 ) ;
    round( moments::jarque.test( vector )$p.value, digits = 3 ) -> tmp.val1 ;
    if ( tmp.val1 < 0.001 ) { tmp.val1 <- "< 0.001"} ;
    paste( "Jarque-Bera test p value: ", tmp.val1 ) -> tmp.name1 ;
    if ( tmp.val1 == "< 0.001" | tmp.val1 < 0.05 ) 
    { title( sub = tmp.name1, col.sub = "green", font.sub = 2 ) ; }
    else
    { title( sub = tmp.name1 ) ; } ;
    
    # plot ecdf 
    plot( ecdf( vector ), main = "Empirical cumulative distribution plot", xlab = "Variable", 
          ylab = "Density", col = "blue", ylim = c( -0.2, 1.2 ) )
    plot( add = TRUE, ecdf( rnorm( 10000, mean = mean( vector ), sd = sd( vector ) ) ), col = "red" ) ;
    abline( h = 0.5, lty = 2, lwd = 1, col = "grey80" )
    legend( x = "bottomright", lty = c( 1, 1 ),col = c( "blue", "red" ), c( "Sample", "Normal" ), cex = 0.6 ) ;
    round( nortest::ad.test( vector )$p.value, digits = 3 ) -> tmp.val1 ;
    if ( tmp.val1 < 0.001 ) { tmp.val1 <- "< 0.001"} ;
    paste( "Anderson-Darling test p value: ", tmp.val1, sep = "" ) -> tmp.name1 ;
    if ( tmp.val1 == "< 0.001" | tmp.val1 < 0.05 ) 
    { title( sub = tmp.name1, col.sub = "green", font.sub = 2 ) ; }
    else
    { title( sub = tmp.name1 ) ; } ;
    
    # plot qq 
    qqnorm( vector, col = "blue" ) ;
    qqline( vector, col = "red" ) ;
    legend( x = "bottomright", lty = c( 1 ),col = c( "red" ), c( "Henry's line" ), cex = 0.6 ) ;
    if ( length( vector ) > 5000 )
    {
      "Shapiro-Wilk test not performed (N > 5000 )" -> tmp.name1 ;
      title( sub = tmp.name1 ) ;
    } else
    {
      round( shapiro.test( vector )$p.value, digits = 3 ) -> tmp.val1 ;
      if ( tmp.val1 < 0.001 ) { tmp.val1 <- "< 0.001"} ;
      paste( "Shapiro-Wilk test p value: ", tmp.val1, sep = "" ) -> tmp.name1 ;
      if ( tmp.val1 == "< 0.001" | tmp.val1 < 0.05 ) 
      { title( sub = tmp.name1, col.sub = "green", font.sub = 2 ) ; }
      else
      { title( sub = tmp.name1 ) ; } ;
    }
    
    # put title 
    tmp.name2 <- paste( "Noramlity Study of", name, sep = " " ) ;
    mtext( text =  tmp.name2, outer = TRUE, cex = 1.5 ) ;
  }
  
  Formula.Maker <- function( outcome, fixed.effects = "", interactions = "", random.effects = "", 
                             random.interactions = list(""), covariance = TRUE, DeleteTerms = NULL )
  {
    # Cheking inuts
    if ( !all( random.interactions == "" ) )
    {
      if ( length(random.interactions) != length(random.effects) ) 
      { print( "Missing random interactions arguments" ) ;}
    } ;
    
    # Integration of fixed effects
    if ( !all( fixed.effects == "" ) ) 
    { 
      if ( length( which(fixed.effects == "" ) ) > 0 )
      {
        fixed.effects[-which(fixed.effects == "")] -> Predictors ; 
      }
      else
      {
        fixed.effects  -> Predictors ; 
      }    
    }
    else
    { "1" -> Predictors } ;
    
    # Integration of interactions
    if ( all( interactions != "" ) )
    {
      for ( a in 1:length( interactions ) )
      {
        paste( interactions[[a]][1], ":", interactions[[a]][2], sep = "" ) -> tmp.val1
        c( Predictors, tmp.val1 ) -> Predictors ; 
      } ;
    } ;
    
    # Integration of random effects
    if ( all( random.effects != "" ) )
    {
      for ( a in 1:length( random.effects) )
      {
        if ( all( random.interactions == "" ) )
        {
          paste( "(1 | ", random.effects[a], ")", sep = "" ) -> tmp.val1 ;
          c( Predictors, tmp.val1 ) -> Predictors ;
        } ;
      } ;
    } ;
    
    # Integration of random interactions 
    if ( any( random.interactions != "" ) )
    {
      if ( covariance )
      {
        for ( a in 1:length(random.effects) )
        {
          if ( all( random.interactions[[a]] != "1" ) )
          {
            "(1" -> tmp.val1 ;
            for ( b in 1:length( random.interactions[[a]] ) )
            {
              if ( random.interactions[[a]][b] != "" )
              {
                paste( tmp.val1, " + ", random.interactions[[a]][b], sep = "" ) -> tmp.val1 ;
              } ;
            } ;
            paste( tmp.val1, " | ", random.effects[a], ")", sep = "" ) -> tmp.val2 ;
            c( Predictors, tmp.val2 ) -> Predictors ;
          }
          if ( all( random.interactions[[a]] == "1" ) )
          {
            paste( "(1", " | ", random.effects[a], ")", sep = "" ) -> tmp.val2 ;
            c( Predictors, tmp.val2 ) -> Predictors ;
          } ;
        } ;
      } ;
      
      if ( !covariance )
      {
        for ( a in 1:length( random.effects) )
        {
          paste( "(1 | ", random.effects[a], ")", sep = "" ) -> tmp.val1 ;
          c( Predictors, tmp.val1 ) -> Predictors ;
          for ( b in 1:length(random.interactions[[a]]) )
          {
            if ( random.interactions[[a]][b] != "" )
            {
              paste( "(", random.interactions[[a]][b], " || ", random.effects[a], ")", sep = "" ) -> tmp.val1 ;
              c( Predictors, tmp.val1 ) -> Predictors ;
            } ;
          } ;
        } ;
      } ;
    } ;
    
    # Deletion of terms 
    if ( all( !is.null( DeleteTerms ) ) )
    {
      if ( class(DeleteTerms) == "numeric" )
      {
        Predictors[ -DeleteTerms ] -> Predictors ;
      } ;
      if ( class(DeleteTerms) == "character" )
      {
        Predictors[ !( Predictors %in% DeleteTerms ) ] -> Predictors ;
      } ;
    } ;
    
    # Generation of formula  
    reformulate( Predictors, outcome ) -> Formula ; 
    
    return( Formula ) ;
  } ;
  
  hmftest.systematic <- function( formula2 , data ) 
  {
    formula2 |>
      as.character() ->
      formula2.ch ;
    
    if ( grepl( ":", formula2.ch[3]) )
    {
      return( "No hmf test for models with interactions" )
    }
    
    reformulate( paste0( "0 | ", formula2.ch[3]), formula2.ch[2] ) ->
      formula2.new  ;
    
    dfidx::dfidx( data, shape = "wide", choice = formula2.ch[2] ) ->
      data.new ;
    
    mlogit::mlogit( formula2.new, 
                    data = data.new 
    ) -> model.new ; 
    
    c( "var", "Chisq", "df", "p-value" ) -> output ; 
    
    for (a in 2:nlevels( data[, formula2.ch[2] ] ) )
    { 
      mlogit::mlogit( formula2.new, 
                      data = data.new,
                      alt.subset = levels( data[, formula2.ch[2] ] )[-a]
      ) -> model.alt ;
      
      try( mlogit::hmftest( model.new, model.alt ) ) ->
        tmp ;
      
      if (attr( tmp,"class") == "try-error" )
      {
        "" -> output ; 
      } else
      {
        rbind( output, 
               c( levels( data[, formula2.ch[2] ] )[a], 
                  IFELSE( is.null( round ), 
                          tmp$statistic,
                          round( tmp$statistic, round ) ) ,
                  tmp$parameter,
                  IFELSE( is.null( pvalue.round ), 
                          tmp$p.value, p.round( tmp$p.value, pvalue.round ) ) )
        ) -> 
          output ;
      }
      
    }
    
    return( data.frame(output) )
  }
  
  Multinomial.SubsetLevels <- function( formula2 , data, round  )
  {
    formula2 |>
      as.character() ->
      formula2.ch ;
    
    nnet::multinom( reformulate(as.character(formula2)[3], 
                                as.character(formula2)[2] ), 
                    data = data,
                    Hess = TRUE ) -> m1 
    
    
    cbind( paste0( rownames(summary(m1)$coefficients),
                   ": Base model" ),
           IFELSE( !is.null(round),
                   round( summary(m1)$coefficients, 
                          round ),
                   summary(m1)$coefficients ) 
    ) -> output ;
    
    if ( nlevels( data[, formula2.ch[2] ] ) > 3 )
    {
      rbind.force( output,
                   rbind.force(  lapply( 2:nlevels( data[, formula2.ch[2] ] ), 
                                         FUN = function(a)
                                         {
                                           data[ data[, formula2.ch[2] ] != 
                                                   levels( data[, formula2.ch[2] ] )[a],] ->
                                             data2
                                           
                                           factor( data2[, formula2.ch[2] ] ) ->
                                             data2[, formula2.ch[2] ]
                                           
                                           nnet::multinom( reformulate(as.character(formula2)[3], 
                                                                       as.character(formula2)[2] ), 
                                                           data = data2,
                                                           Hess = TRUE ) -> m1 
                                           
                                           cbind( paste0( rownames(summary(m1)$coefficients),
                                                          ": -", 
                                                          levels( data[, formula2.ch[2] ] )[a] ,
                                                          " model" ),
                                                  IFELSE( !is.null(round),
                                                          round( summary(m1)$coefficients, 
                                                                 round ),
                                                          summary(m1)$coefficients ) 
                                           ) 
                                         }) ), empty = "" ) -> 
        output ;
    } else
    {
      rbind.force( output,
                   rbind.force( lapply( 2:nlevels( data[, formula2.ch[2] ] ), 
                                        FUN = function(a)
                                        {
                                          data[ data[, formula2.ch[2] ] != 
                                                  levels( data[, formula2.ch[2] ] )[a],] ->
                                            data2
                                          
                                          factor( data2[, formula2.ch[2] ] ) ->
                                            data2[, formula2.ch[2] ]
                                          
                                          nnet::multinom( reformulate(as.character(formula2)[3], 
                                                                      as.character(formula2)[2] ), 
                                                          data = data2,
                                                          Hess = TRUE ) -> m1 
                                          
                                          cbind( paste0( levels( data2[, formula2.ch[2] ] )[2],
                                                         ": -", 
                                                         levels( data[, formula2.ch[2] ] )[a] ,
                                                         " model" ),
                                                 t(IFELSE( !is.null(round),
                                                           round( summary(m1)$coefficients, 
                                                                  round ),
                                                           summary(m1)$coefficients ) )
                                          ) 
                                        }) ),
                   empty = "" )  -> 
        output ;
    }
    
    output |>
      data.frame() |>
      dplyr::arrange( X1 ) |>
      t() |>
      (function(x)  cbind( c( "Outcome levels ->", m1$coefnames ), 
                           x ) )() -> output
    
    return( data.frame(output) )
  }
  
  brant.perso <- function (model, by.var = F) 
  {
    print.testresult <- function(model,X2,df.v,by.var) {
      p.values = pchisq(X2,df.v,lower.tail=FALSE) 
      if(by.var){
        var.names = unlist(strsplit(as.character(formula(model))[3],split=" \\+ "))
      }else{
        var.names = names(coef(model))
      }
      # longest name
      longest.char = max(nchar(var.names))
      n.tabs = ceiling(longest.char/7)
      n.tabs = ifelse(n.tabs<2,2,n.tabs)
      for(i in 1:length(var.names)){
        name = var.names[i]
        tabs.sub = ceiling(nchar(name)/7)-1
      }
      result.matrix = matrix(c(X2, df.v, p.values), ncol = 3)
      rownames(result.matrix) = c("Omnibus", var.names)
      colnames(result.matrix) = c("X2","df","probability")
      result.matrix
    }
    
    temp.data = model$model
    y_name = as.character(formula(model))[2]
    x_names = as.character(formula(model))[3]
    x_names = gsub( "\n    ", "", x_names )
    y = as.numeric(temp.data[[y_name]])
    temp.data$y = y
    x.variables = strsplit(x_names, " \\+ ")[[1]]
    x.factors = c()
    for (name in x.variables) {
      if (!is.numeric(temp.data[, name])) {
        x.factors = c(x.factors, name)
      }
    }
    if (length(x.factors) > 0) {
      tab = table(data.frame(temp.data[, y_name], temp.data[, 
                                                            x.factors]))
      count0 = sum(tab == 0)
    }
    else {
      count0 = 0
    }
    J = max(y, na.rm = T)
    K = length(coef(model))
    for (m in 1:(J - 1)) {
      temp.data[[paste0("z", m)]] = ifelse(y > m, 1, 0)
    }
    binary.models = list()
    beta.hat = matrix(NA, nrow = J - 1, ncol = K + 1, byrow = T)
    var.hat = list()
    for (m in 1:(J - 1)) {
      mod = glm(paste0("z", m, " ~ ", x_names), data = temp.data, 
                family = "binomial")
      binary.models[[paste0("model", m)]] = mod
      beta.hat[m, ] = coef(mod)
      var.hat[[m]] = vcov(mod)
    }
    X.temp = model$model[2:length(model$model)]
    X = matrix(1, nrow = length(X.temp[, 1]), ncol = 1)
    for (var in X.temp) {
      if (is.numeric(var)) {
        X = cbind(X, var)
      }
      if (is.character(var)) {
        var = as.factor(var)
      }
      if (is.factor(var)) {
        for (level in levels(var)[2:length(levels(var))]) {
          X = cbind(X, ifelse(var == level, 1, 0))
        }
      }
    }
    tau = matrix(model$zeta, nrow = 1, ncol = J - 1, byrow = T)
    pi.hat = matrix(NA, nrow = length(model$model[, 1]), ncol = J - 
                      1, byrow = T)
    for (m in 1:(J - 1)) {
      pi.hat[, m] = binary.models[[m]]$fitted.values
    }
    varBeta = matrix(NA, nrow = (J - 1) * K, ncol = (J - 1) * 
                       K)
    for (m in 1:(J - 2)) {
      for (l in (m + 1):(J - 1)) {
        Wml = Matrix::Diagonal(x = pi.hat[, l] - pi.hat[, 
                                                        m] * pi.hat[, l])
        Wm = Matrix::Diagonal(x = pi.hat[, m] - pi.hat[, 
                                                       m] * pi.hat[, m])
        Wl = Matrix::Diagonal(x = pi.hat[, l] - pi.hat[, 
                                                       l] * pi.hat[, l])
        Xt = t(X)
        varBeta[((m - 1) * K + 1):(m * K), ((l - 1) * K + 
                                              1):(l * K)] = as.matrix((solve(Xt %*% Wm %*% 
                                                                               X) %*% (Xt %*% Wml %*% X) %*% solve(Xt %*% Wl %*% 
                                                                                                                     X))[-1, -1])
        varBeta[((l - 1) * K + 1):(l * K), ((m - 1) * K + 
                                              1):(m * K)] = varBeta[((m - 1) * K + 1):(m * 
                                                                                         K), ((l - 1) * K + 1):(l * K)]
      }
    }
    betaStar = c()
    for (m in 1:(J - 1)) {
      betaStar = c(betaStar, beta.hat[m, -1])
    }
    for (m in 1:(J - 1)) {
      varBeta[((m - 1) * K + 1):(m * K), ((m - 1) * K + 1):(m * 
                                                              K)] = var.hat[[m]][-1, -1]
    }
    I = diag(1, K)
    E0 = diag(0, K)
    for (i in 1:(J - 2)) {
      for (j in 1:(J - 1)) {
        if (j == 1) {
          temp = I
        }
        else if (j == i + 1) {
          temp = cbind(temp, -I)
        }
        else {
          temp = cbind(temp, E0)
        }
      }
      if (i == 1) {
        D = temp
      }
      else {
        D = rbind(D, temp)
      }
    }
    X2 = t(D %*% betaStar) %*% solve(D %*% varBeta %*% t(D)) %*% 
      (D %*% betaStar)
    df.v = (J - 2) * K
    if (by.var) {
      combinations = getCombiCoefs(model)
      for (v in unique(combinations$var)) {
        k = subset(combinations, var == v)$i
        s = c()
        df.v.temp = 0
        for (e in k) {
          s = c(s, seq(from = e, to = K * (J - 1), by = K))
          df.v.temp = df.v.temp + J - 2
        }
        s = sort(s)
        Ds = D[, s]
        Ds = Ds[which(!apply(Ds == 0, 1, all)), ]
        if (!is.null(dim(Ds))) 
          X2 = c(X2, t(Ds %*% betaStar[s]) %*% solve(Ds %*% 
                                                       varBeta[s, s] %*% t(Ds)) %*% (Ds %*% betaStar[s]))
        else X2 = c(X2, t(Ds %*% betaStar[s]) %*% solve(Ds %*% 
                                                          varBeta[s, s] %*% t(t(Ds))) %*% (Ds %*% betaStar[s]))
        df.v = c(df.v, df.v.temp)
      }
    }
    else {
      for (k in 1:K) {
        s = seq(from = k, to = K * (J - 1), by = K)
        Ds = D[, s]
        Ds = Ds[which(!apply(Ds == 0, 1, all)), ]
        if (!is.null(dim(Ds))) 
          X2 = c(X2, t(Ds %*% betaStar[s]) %*% solve(Ds %*% 
                                                       varBeta[s, s] %*% t(Ds)) %*% (Ds %*% betaStar[s]))
        else X2 = c(X2, t(Ds %*% betaStar[s]) %*% solve(Ds %*% 
                                                          varBeta[s, s] %*% t(t(Ds))) %*% (Ds %*% betaStar[s]))
        df.v = c(df.v, J - 2)
      }
    }
    result.matrix = print.testresult(model, X2, df.v, by.var)
    if (count0 != 0) {
      warning(paste0(count0, " combinations in table(dv,ivs) do not occur. Because of that, the test results might be invalid."))
    }
    result.matrix
  }
  
  nominal_test.perso <- function( model, formula1, data.clm )
  {
    lapply( attr( terms( model ),"term.labels"), 
            function(a) 
            {
              ordinal::clm(  formula1, 
                             nominal = reformulate( a ),
                             data = data.clm ) |>
                (function(x) anova( model, x ) )() |>
                data.frame() -> tmp ;
              cbind( Predictors = a, tmp[2,-1] )
            }) |>
      dplyr::bind_rows()
  }
  
  pairs2 <- function( y, X, ExportName, n )
  {
    data.frame(y) |>
      lapply(as.numeric) |>
      data.frame() -> y
    data.frame(X) |>
      lapply(as.numeric) |>
      data.frame() -> X
    
    (ncol(X) / n) |> trunc() -> npairs
    (ncol(X) %% n) -> addpairs
    
    if ( npairs != 0 )
    {
      for (a in 0:(npairs - 1) )
      {
        png( paste( ExportName,
                    "Pair_Graphics",
                    "_", a +1,
                    ".png",
                    sep = "" ) )
        y |>
          cbind(X[, (1 + n * a):(
            n * (a + 1) ) ]) |>
          pairs( cex.labels = 0.8, main = paste( "Pairs graphic", a + 1 ) )
        dev.off() ;
      }
    }
    
    if ( addpairs != 0 )
    {
      png( paste( ExportName,
                  "Pair_Graphics",
                  "_", (npairs + 1),
                  ".png",
                  sep = "" ) )
      y |>
        cbind(  subset( X, select = (1 + n * npairs):ncol(X) ) ) |>
        pairs(  cex.labels = 0.8, main = paste( "Pairs graphic", npairs + 1 ) )
      dev.off() ;
    }
  }
  
  termplot2 <- function( model, ExportName )
  {
    ( (ncol( model$model  ) - 1) / 9) |> trunc() -> n ;
    ( (ncol( model$model  ) - 1) %% 9) -> o ;
    
    if ( n != 0 )
    {
      for (a in 1:n )
      {
        png( paste( ExportName,
                    "RegressionsTerms_vs_Predictors_",
                    a,
                    ".png",
                    sep = "" ) )
        layout( matrix( 1:9, ncol=3, byrow=T ) )
        par( oma = c( 0, 0, 2, 0) )
        termplot( model, 
                  terms = attr( terms( model ),"term.labels")[((a - 1) * 9 + 1):(a  * 9)],
                  ask = FALSE,
                  partial.resid = TRUE, 
                  se = TRUE, 
                  smooth = panel.smooth )
        mtext( text =  paste( "Regression terms vs Predictors", a ), 
               outer = TRUE, cex = 1.5 ) ;
        dev.off() ;
      }
    }
    
    if ( o != 0 )
    {
      png( paste( ExportName,
                  "RegressionsTerms_vs_Predictors_",
                  n + 1,
                  ".png",
                  sep = "" ) )
      layout( matrix( 1:9, ncol=3, byrow=T ) )
      par( oma = c( 0, 0, 2, 0) )
      termplot( model, 
                terms = attr( terms( model ),"term.labels")[(n * 9 + 1):(n * 9 + o)],
                ask = FALSE,
                partial.resid = TRUE, 
                se = TRUE, 
                smooth = panel.smooth )
      mtext( text =  paste( "Regression terms vs Predictors", n + 1), 
             outer = TRUE, cex = 1.5 ) ;
      dev.off() ;
    }
    
  } ;
  
  residualPlots2 <- function( model, ExportName )
  {
    ( (ncol( model$model  ) - 1) / 9) |> trunc() -> n ;
    ( (ncol( model$model  ) - 1) %% 9) -> o ;
    
    if ( n != 0 )
    {
      for (a in 1:n )
      {
        png( paste( ExportName,
                    "Pearson_Residuals_vs_Independant_Vars",
                    a,
                    ".png",
                    sep = "" ) )
        layout( matrix( 1:9, ncol=3, byrow=T ) )
        par( oma = c( 0, 0, 2, 0) )
        car::residualPlot( model, 
                           terms = reformulate( attr( terms( model ),"term.labels")[((a - 1) * 9 + 1):(a  * 9)] ),
                           tests = FALSE, 
                           fitted = FALSE, 
                           ask = FALSE, 
                           type = "rstandard" )
        mtext( text =  paste( "Pearson Residuals vs Independant Vars", a), 
               outer = TRUE, cex = 1.5 ) ;
        dev.off() ;
      }
    }
    
    if ( o != 0 )
    {
      png( paste( ExportName,
                  "Pearson_Residuals_vs_Independant_Vars",
                  n + 1,
                  ".png",
                  sep = "" ) )
      layout( matrix( 1:9, ncol=3, byrow=T ) )
      par( oma = c( 0, 0, 2, 0) )
      car::residualPlot( model, 
                         terms = reformulate( attr( terms( model ),"term.labels")[(n * 9 + 1):(n * 9 + o)] ),
                         tests = FALSE, 
                         fitted = FALSE, 
                         ask = FALSE, 
                         type = "rstandard" )
      mtext( text =  paste( "Pearson Residuals vs Independant Vars", n + 1), 
             outer = TRUE, cex = 1.5 ) ;
      dev.off() ;
    }
  }
  
  avPlots2 <- function( model, ExportName )
  {
    ( (length( names(model$coefficients) ) - 1) / 9) |> trunc() -> n ;
    ( (length( names(model$coefficients)  ) - 1) %% 9) -> o ;
    
    if ( n != 0 )
    {
      for (a in 1:n )
      {
        png( paste( ExportName,
                    "Added-Variable_Plots",
                    a,
                    ".png",
                    sep = "" ) )
        layout( matrix( 1:9, ncol=3, byrow=T ) )
        par( oma = c( 0, 0, 2, 0) )
        for (b in names(model$coefficients)[-1][((a - 1) * 9 + 1):(a  * 9)])
        {
          car::avPlot( model, 
                       variable =  b
          ) ;
        }
        mtext( text =  paste( "Added-Variable Plots", a ), 
               outer = TRUE, cex = 1.5 ) ;
        dev.off() ;
      }
    }
    
    if ( o != 0 )
    {
      png( paste( ExportName,
                  "Added-Variable_Plots",
                  n + 1,
                  ".png",
                  sep = "" ) )
      layout( matrix( 1:9, ncol=3, byrow=T ) )
      par( oma = c( 0, 0, 2, 0) )
      for (b in names(model$coefficients)[-1][(n * 9 + 1):(n * 9 + o)])
      {
        car::avPlot( model, 
                     variable =  b
        ) ;
      }
      mtext( text =  paste( "Added-Variable Plots", n + 1 ), 
             outer = TRUE, cex = 1.5 ) ;
      dev.off() ;
    }
  }
  
  crPlots2 <- function( model, ExportName )
  {
    ( (ncol( model$model  ) - 1) / 9) |> trunc() -> n ;
    ( (ncol( model$model  ) - 1) %% 9) -> o ;
    
    if ( n != 0 )
    {
      for (a in 1:n )
      {
        png( paste( ExportName,
                    "Component-Residuals_Plots",
                    a,
                    ".png",
                    sep = "" ) )
        layout( matrix( 1:9, ncol=3, byrow=T ) )
        par( oma = c( 0, 0, 2, 0) )
        car::crPlots( model, 
                      terms = reformulate( attr( terms( model ),"term.labels")[((a - 1) * 9 + 1):(a  * 9)] ),
                      ask = FALSE, main = "" )
        mtext( text =  paste( "Component-Residuals Plots", a), 
               outer = TRUE, cex = 1.5 ) ;
        dev.off() ;
      }
    }
    
    if ( o != 0 )
    {
      png( paste( ExportName,
                  "Component-Residuals_Plots",
                  n + 1,
                  ".png",
                  sep = "" ) )
      layout( matrix( 1:9, ncol=3, byrow=T ) )
      par( oma = c( 0, 0, 2, 0) )
      car::crPlots( model, 
                    terms = reformulate( attr( terms( model ),"term.labels")[(n * 9 + 1):(n * 9 + o)] ),
                    ask = FALSE, main = "" )
      mtext( text =  paste( "Component-Residuals Plots", n + 1), 
             outer = TRUE, cex = 1.5 ) ;
      dev.off() ;
    }
  }
  
  
  Lm.Analysis <- function( outcome, predictors, 
                           data, 
                           na.omit = TRUE,
                           FULL = TRUE, 
                           selected.predictors = NULL,
                           ANOVA = FALSE )
  {
    # Formula
    Formula.Maker( outcome, predictors ) -> 
      formula ;
    
    # model
    if ( na.omit == TRUE ) { na.omit( data ) -> data } 
    
    lm( formula, data = data ) ->
      m1 ;
    
    m1 |>
      (function(x) list( model = x )  )() -> 
      output ;
    
    m1 |> summary() -> summary1 ;
    
    m1 |>
      car::Confint( level = conf.level ) |>
      as.data.frame() |>
      (function(x) IFELSE( is.null( round ),
                           x,
                           round( x, round ) ) )() |>
      (function(x) cbind( Predictors = rownames(x), x ) )() |>
      (function(x) rbind.force( colnames(x), x ) )() -> 
      confint1 ;
    
    # prepare results 
    if (FULL)
    {
      # formula
      "Model:" -> results.tab ;
      
      formula |>
        deparse() |>
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      "" |> (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      # missing data
      c( "Observations deleted due to missingness:",
         dim( data )[1] - dim( m1$model )[1] ) |>
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      "" |> (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      #  slopes and t.tests
      "Model coefficients and t-tests" |> 
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      summary1 |> 
        coef() |>
        as.data.frame() |>   
        dplyr::transmute( `Std. Error` =  IFELSE( is.null( round ), 
                                                  `Std. Error`,
                                                  round( `Std. Error`, round ) ),
                          Df = summary1$df[2],
                          `t value` =  IFELSE( is.null( round ), 
                                               `t value`,
                                               round( `t value`, round ) ),
                          `Pr(>|t|)` =  IFELSE( is.null( pvalue.round ), 
                                                `Pr(>|t|)`,
                                                p.round( `Pr(>|t|)`, pvalue.round ) ) ) |>
        (function(x) rbind.force( colnames(x), x ) )()  |>
        (function(x) cbind( confint1, x ) )() |>
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      "" |> (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      c( "Degrees of freedom:", summary1$df[2],
         "Number of Coefficients:", summary1$df[1] ) |>
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      "" |> (function(x) rbind.force( results.tab, x, empty = "") )() -> results.tab ;
      
      # Anova
      m1 |>
        car::Anova(  type = 3) |>
        as.data.frame() |>
        (function(x) cbind( Predictors = rownames(x), x ) )() |> 
        (function(x) data.frame( Predictors = x$Predictors,
                                 `Sum Sq` = IFELSE( is.null( round ), 
                                                    x$`Sum Sq`,
                                                    round( x$`Sum Sq`, round ) ),
                                 `Df numerator` = x$Df,
                                 `Df denominator` = c( rep( m1$df.residual, 
                                                            times = dim(x)[1] - 1), NA ),
                                 `F value` =  IFELSE( is.null( round ), 
                                                      x$`F value`,
                                                      round( x$`F value`, round ) ),
                                 `Pr(>F)` =  IFELSE( is.null( pvalue.round ), 
                                                     x$`Pr(>F)`,
                                                     p.round( x$`Pr(>F)`, pvalue.round ) ) ) )() |>
        cbind(   `Cohen's f-squared on R-squared` =  IFELSE( is.null( round ), 
                                                             c( NA, cohen.f2( m1 ), NA ),
                                                             c( NA, round( cohen.f2( m1 ), round ), NA  ) ) ) |>
        cbind(   `Partial eta-squared` =  IFELSE( is.null( round ), 
                                                  c( NA, heplots::etasq( m1 )[,1] ),
                                                  c( NA, round( heplots::etasq( m1 )[,1], round )  ) ) ) |>
        cbind(  AIC =  IFELSE( is.null( round ), 
                               AIC( m1 ),
                               round( AIC( m1 ), round ) ) ) ->
        anova1 ;
      
      # fusion anova and CI
      c( confint1[1,], 
         colnames(anova1)[-1] ) |>
        matrix( nrow = 1 ) -> 
        tmp.anova ;
      
      for ( a in as.character(anova1$Predictors)[-length(anova1$Predictors)] )
      {
        confint1[grep( a, confint1[,1] ) , ] -> tmp.ci1
        
        anova1[grep( a, anova1[,1] ) , ] -> tmp.anova1
        
        if ( !grepl( ":", a ) )
        {
          if ( length( grep( ":", tmp.ci1[,1] ) ) > 0 )
          {
            tmp.ci1[ -grep( ":", tmp.ci1[,1] ) , ] -> tmp.ci1
            
            tmp.anova1[ -grep( ":", 
                               as.character( tmp.anova1[,1] ) 
            ),  ] -> 
              tmp.anova1
          }
        }
        
        if ( grepl( ":", a ) )
        {
          strsplit( a, ":" ) |>
            unlist() ->
            sub.names.interaction
          
          confint1 -> tmp.ci1
          for ( b in sub.names.interaction )
          {
            tmp.ci1[grep( b, tmp.ci1[,1] ) , ] -> tmp.ci1
          }
        }
        
        cbind.force( tmp.ci1,
                     tmp.anova1[, -1 ],
                     empty = "" ) |>
          (function(x) rbind.force( tmp.anova,
                                    x,
                                    empty = "" ) )() ->
          tmp.anova ;
      }
      
      tmp.anova |>
        rbind.force(  
          c( "Residuals", "", "", "", 
             as.matrix( anova1[dim( anova1 )[1],-1] ) )  , 
          empty = "" ) ->
        tmp.anova ;
      
      "ANOVA (type 3 tests)" |> (function(x) rbind.force( results.tab, x, empty = "" ) )() -> 
        results.tab ;
      
      tmp.anova |>
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      "" |> (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      # Models infos
      c( "Multiple R-squared:", 
         IFELSE( is.null( round ), 
                 summary1$r.squared,
                 round( summary1$r.squared, round ) ),
         "Adjusted R-squared:", 
         IFELSE( is.null( round ), 
                 summary1$adj.r.squared,
                 round( summary1$adj.r.squared, round ) ) ) |>
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      c( "AIC:", 
         IFELSE( is.null( round ), 
                 AIC(m1),
                 round( AIC(m1), round ) ),
         "AICc:", 
         IFELSE( is.null( round ), 
                 MuMIn::AICc(m1),
                 round( MuMIn::AICc(m1), round ) ) ) |> 
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      "" |> (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      # post hoc analysis with no plots
      # Residuals normality 
      residuals( m1 ) -> residuals1 ;
      if ( length( residuals1 ) < 5000 ) 
      { shapiro.test( residuals1 ) -> shapiro.res ; }  else
      { list( "p.value" = NA ) -> shapiro.res ; }
      nortest::ad.test( residuals1 ) -> anderson.res ;
      moments::jarque.test( residuals1 ) -> jarque.res ;
      
      "Normality tests on Residuals" |> 
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      c( "Shapiro test p-value:", 
         IFELSE( is.null( pvalue.round ), 
                 shapiro.res$p.value,
                 p.round( shapiro.res$p.value, pvalue.round ) ),
         "Anderson-Darling test p-value:", 
         IFELSE( is.null( pvalue.round ), 
                 anderson.res$p.value,
                 p.round( anderson.res$p.value, pvalue.round ) ),
         "Jarque-Bera test p-value:", 
         IFELSE( is.null( pvalue.round ), 
                 jarque.res$p.value,
                 p.round( jarque.res$p.value, pvalue.round ) ) ) |> 
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      "" |> (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      # Residuals homosedasticity 
      "Homosedasticity tests on Residuals" |> 
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      c( "Score test for Non-Constant Error Variance p-value:", 
         IFELSE( is.null( pvalue.round ), 
                 car::ncvTest( m1 )$p,
                 p.round( car::ncvTest( m1 )$p, pvalue.round ) ),
         "Breusch-Pagan test p-value:", 
         IFELSE( is.null( pvalue.round ), 
                 lmtest::bptest(m1)$p.value,
                 p.round( lmtest::bptest(m1)$p.value, pvalue.round ) ) )  |> 
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      "" |> (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      # Residuals independancy 
      "Independancy of Residuals" |> 
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      set.seed( 123) ;
      car::durbinWatsonTest( m1 ) -> dw1 ; 
      c( "Durbin-Watson statistic (1.5 - 2.5):",
         IFELSE( is.null( round ), 
                 dw1$dw,
                 round( car::durbinWatsonTest( m1 )$p, round ) ),
         "Durbin-Watson test p-value:", 
         IFELSE( is.null( pvalue.round ), 
                 dw1$p,
                 p.round( car::durbinWatsonTest( m1 )$p, pvalue.round ) ) ) |> 
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      "" |> (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      #  Multicollinearity
      if ( length( attr( terms(m1),"term.labels") ) > 1 )
      {
        c( "Multicollinearity check" ) |> 
          (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
        
        c( "(generalized) Variance Inflation Factors:" ) |> 
          (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
        
        car::vif( m1 ) |>
          (function(x) IFELSE( is.null( round ), 
                               x,
                               round( x, round ) ) )() |>
          as.data.frame() |>
          (function(x) cbind( Predictors = rownames(x), x ) )()  -> 
          tmp.vif ;
        
        if ( ncol( tmp.vif ) == 2 ) { "VIF" -> colnames( tmp.vif )[2] }
        
        tmp.vif |>
          (function(x) rbind.force( colnames(x), x ) )() |>
          (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
        
        "" |> (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
        
        # besley
        attr( terms( m1 ),"term.labels" ) -> Vars
        base::subset( data, 
                      select = Vars[ 
                        !( Vars  %in% Vars[ grep( ":", Vars ) ] ) ] ) |>
          dplyr::select_if( is.numeric ) ->
          data2 
        
        VisCollin::colldiag( mod = lm(
          reformulate( colnames(data2),
                       as.character(formula)[2] ),
          data = data), 
          scale = FALSE, 
          center = FALSE, add.intercept = T ) -> 
          besley
        
        "Belsley criteria (computed on numeric predictors only):" |> 
          (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
        data.frame( besley$condindx, besley$pi) |>
          (function(x) rbind( colnames(x), x ) )() |>
          (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
        "" |> (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
        
        # other criteria
        if ( ncol(data2) > 1 )
        {
          "Other criteron on numeric predictors only:" |> 
            (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
          "===================================" |> 
            (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
          
          #omcdiag( data2,
          #           data[,outcome]
          #  )  |> 
          #    capture.output() |>
          #    data.frame() |>
          #    (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
          
          #  imcdiag( data2,
          #          data[,outcome]
          #  )  |> 
          #   capture.output() |>
          #    data.frame() |>
          #    (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
          # "" |>  (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
        }
        
      }
      
      
      #  Linearity and non-addititvity check
      c(  "Linearity and non-addititvity check" ) |> 
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      c( "Curvature test and Tukey's test for non-additivity:" ) |> 
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      car::residualPlot( m1, plot = FALSE ) |>
        (function(x)  IFELSE( is.null( pvalue.round ), 
                              x[2],
                              p.round( x[2], pvalue.round ) ) )() |>
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      "Best Fractional Polynomial for each numeric predictor:" |> 
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      formula |> as.character() -> formula1 ;
      
      Systematic.FP( output = formula1[2], 
                     predictors = attr( terms(m1), 'term.labels'),
                     family = "gaussian", 
                     data = data, 
                     na.omit = na.omit ) |>
        as.data.frame() |>
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      "" |> (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      # Observation with major influence
      c( "Observation with major influence" ) |> 
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      c( "Number of observations",
         "with a Cook distance",
         "over 4 / N:",
         sum( cooks.distance( m1 ) > 4 / nrow( data ) )
      ) |> 
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      "" |> (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      c( "Bonferroni Outlier test" ) |> 
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      car::outlierTest( m1) |> 
        capture.output() |> 
        matrix(  ncol = 1) |>
        as.data.frame() |>
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      "" |> (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      "/////////////////////////////////////////" |> 
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
    }
    
    if ( !FULL & ANOVA )
    {
      # Anova
      m1 |>
        car::Anova( type = 3) |>
        as.data.frame() |>
        (function(x) cbind( Predictors = rownames(x), x ) )() |> 
        (function(x)  data.frame( Predictors = x$Predictors,
                                  `Sum Sq` = IFELSE( is.null( round ), 
                                                     x$`Sum Sq`,
                                                     round( x$`Sum Sq`, round ) ),
                                  `Df numerator` = x$Df,
                                  `Df denominator` = c( rep( m1$df.residual, 
                                                             times = dim(x)[1] - 1), NA ),
                                  `F value` =  IFELSE( is.null( round ), 
                                                       x$`F value`,
                                                       round( x$`F value`, round ) ),
                                  `Pr(>F)` =  IFELSE( is.null( pvalue.round ), 
                                                      x$`Pr(>F)`,
                                                      p.round( x$`Pr(>F)`, pvalue.round ) ) ) )() |>
        cbind(   `Cohen's f-squared on R-squared` =  IFELSE( is.null( round ), 
                                                             c( NA, cohen.f2( m1 ), NA ),
                                                             c( NA, round( cohen.f2( m1 ), round ), NA  ) ) ) |>
        cbind(   `Partial eta-squared` =  IFELSE( is.null( round ), 
                                                  c( NA, heplots::etasq( m1 )[,1] ),
                                                  c( NA, round( heplots::etasq( m1 )[,1], round )  ) ) ) |>
        cbind(   AIC =  IFELSE( is.null( round ), 
                                AIC( m1 ),
                                round( AIC( m1 ), round ) ) ) ->
        anova1 ;
      
      # fusion anova and CI
      c( confint1[1,], 
         colnames(anova1)[-1] ) |>
        matrix( nrow = 1 ) -> 
        tmp.anova ;
      
      for ( a in as.character(anova1$Predictors)[-length(anova1$Predictors)] )
      {
        confint1[grep( a, confint1[,1] ) , ] -> tmp.ci1
        
        anova1[grep( a, anova1[,1] ) , ] -> tmp.anova1
        
        if ( !grepl( ":", a ) )
        {
          if ( length( grep( ":", tmp.ci1[,1] ) ) > 0 )
          {
            tmp.ci1[ -grep( ":", tmp.ci1[,1] ) , ] -> tmp.ci1
            
            tmp.anova1[ -grep( ":", 
                               as.character( tmp.anova1[,1] ) 
            ),  ] -> 
              tmp.anova1
          }
        }
        
        if ( grepl( ":", a ) )
        {
          strsplit( a, ":" ) |>
            unlist() ->
            sub.names.interaction
          
          confint1 -> tmp.ci1
          for ( b in sub.names.interaction )
          {
            tmp.ci1[grep( b, tmp.ci1[,1] ) , ] -> tmp.ci1
          }
        }
        
        cbind.force( tmp.ci1,
                     tmp.anova1[, -1 ],
                     empty = "" ) |>
          (function(x) rbind.force( tmp.anova,
                                    x,
                                    empty = "" ) )() ->
          tmp.anova ;
      }
      
      tmp.anova |>
        rbind.force( 
          c( "Residuals", "", "", "", 
             as.matrix( anova1[dim( anova1 )[1],-1] ) )  , 
          empty = "" ) ->
        tmp.anova ;
      
      # Extraction
      lapply( 1:length(selected.predictors),  
              function(a){ 
                tmp.anova[ grep( selected.predictors[a],  tmp.anova[,1] ), ] } ) |> 
        (function(x) rbind.force( tmp.anova[1,], x, empty = "" ) )() |>
        unique() ->
        results.tab ;
    }
    
    
    if ( !FULL & !ANOVA )
    {
      # Compute output
      
      summary1 |> 
        coef() |>
        as.data.frame()|>  
        dplyr::transmute( `Std. Error` =  IFELSE( is.null( round ), 
                                                  `Std. Error`,
                                                  round( `Std. Error`, round ) ),
                          Df = summary1$df[2],
                          `t value` =  IFELSE( is.null( round ), 
                                               `t value`,
                                               round( `t value`, round ) ),
                          `Pr(>|t|)` =  IFELSE( is.null( pvalue.round ), 
                                                `Pr(>|t|)`,
                                                p.round( `Pr(>|t|)`, pvalue.round ) ) ) |>
        (function(x) rbind.force( colnames(x), x ) )()  |>
        (function(x) cbind( confint1, x ) )()  -> 
        tmp.student ;
      
      # Extraction
      lapply( 1:length(selected.predictors),  
              function(a){ 
                tmp.student[ grep( selected.predictors[a],  tmp.student[,1] ), ] } ) |> 
        (function(x)  rbind.force( tmp.student[1,], x, empty = "" ) )() |>
        unique() ->
        results.tab ;
    }
    
    
    # output 
    NULL -> rownames( results.tab ) ;
    NULL -> colnames( results.tab ) ;
    
    c( output, list( results.tab = results.tab ) ) -> 
      output ;
    
    return( output )
  }
  
  Glm.Analysis <- function( outcome, predictors, 
                            family,
                            data, 
                            na.omit = TRUE,
                            FULL = TRUE, 
                            selected.predictors = NULL,
                            ANODE = FALSE )
  {
    # Formulaf
    if ( length( outcome ) == 2 ) 
    { paste( "cbind(", outcome[1], ",", outcome[2], ")" ) -> outcome ;
      as.formula( paste(outcome, 
                        " ~ ", 
                        as.character( reformulate( predictors ) )[2] ) 
      ) -> 
        formula ; 
    } else
    {
      Formula.Maker( outcome, predictors ) -> 
        formula ;
    }
    
    # model
    if ( na.omit == TRUE ) { na.omit( data ) -> data } 
    
    glm( formula, family = family, data = data ) ->
      m1 ;
    
    m1 |> 
      (function(x) list( model = x ) )() -> 
      output ;
    
    m1 |> summary() -> summary1 ;
    
    m1 |> 
      car::Confint(  level = conf.level ) |>
      exp() |>
      (function(x)  IFELSE( is.null( round ),
                            x,
                            round( x, round ) ) )() |>
      as.data.frame() |> 
      (function(x) cbind( Predictors = rownames(x), x ) )() |> 
      (function(x)  rbind.force( c( colnames(x)[1], 
                                    paste( "exp of", 
                                           colnames(x)[-1] ) ), 
                                 x ) )() -> 
      confint1 ;
    
    # prepare results 
    if (FULL)
    {
      # formula
      "Model:" -> results.tab ;
      
      formula |> 
        deparse() |> 
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      "" |> (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      # missing data
      c( "Observations deleted due to missingness:",
         dim( data )[1] - dim( m1$model )[1] ) |> 
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      "" |> (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      #  slopes and t.tests
      "Model coefficients and t-tests" |> 
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      summary1 |> 
        coef() |>
        as.data.frame() |>  
        dplyr::transmute( `Std. Error` =  IFELSE( is.null( round ), 
                                                  `Std. Error`,
                                                  round( `Std. Error`, round ) ),
                          `--` = "",
                          `z value` =  IFELSE( is.null( round ), 
                                               `z value`,
                                               round( `z value`, round ) ),
                          `Pr(>|z|)` =  IFELSE( is.null( pvalue.round ), 
                                                `Pr(>|z|)`,
                                                p.round( `Pr(>|z|)`, pvalue.round ) ) ) |>
        (function(x) rbind.force( colnames(x), x ) )()  |>
        (function(x) cbind( confint1, x )  )() |>
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      "" |> (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      c( "Degrees of freedom:", summary1$df[2],
         "Number of Coefficients:", summary1$df[1] ) |> 
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      "" |> (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      # Anova
      m1 |>
        car::Anova(  type = 3) |>
        as.data.frame() |>
        (function(x) cbind( Predictors = rownames(x), x ) )() |>
        dplyr::transmute( Predictors = Predictors,
                          `LR Chisq` =  IFELSE( is.null( round ), 
                                                `LR Chisq`,
                                                round( `LR Chisq`, round ) ),
                          `Chisq Df` = Df,
                          `Residual Df` = m1$df.residual,
                          `--` = "",
                          `Pr(>Chisq)` =  IFELSE( is.null( pvalue.round ), 
                                                  `Pr(>Chisq)`,
                                                  p.round( `Pr(>Chisq)`, pvalue.round ) ) ) |>
        cbind(  `Cohen's f-squared on pseudo-R-squared` =  IFELSE( is.null( round ), 
                                                                   cohen.f2( m1, TRUE, family ),
                                                                   round( cohen.f2( m1, TRUE, family ), 
                                                                          round ) ) ) |>
        cbind( 
          `--` = "",
          AIC = IFELSE( is.null( round ), 
                        AIC( m1 ),
                        round( AIC( m1 ), round ) )) ->
        anova1 ;
      
      # fusion anova and CI
      c( confint1[1,], 
         colnames(anova1)[-1] ) |>
        matrix( nrow = 1 ) -> 
        tmp.anova ;
      
      for ( a in as.character(anova1$Predictors) )
      {
        confint1[grep( a, confint1[,1] ) , ] -> tmp.ci1
        
        anova1[grep( a, anova1[,1] ) , ] -> tmp.anova1
        
        if ( !grepl( ":", a ) )
        {
          if ( length( grep( ":", tmp.ci1[,1] ) ) > 0 )
          {
            tmp.ci1[ -grep( ":", tmp.ci1[,1] ) , ] -> tmp.ci1
            
            tmp.anova1[ -grep( ":", 
                               as.character( tmp.anova1[,1] ) 
            ),  ] -> 
              tmp.anova1
          }
        }
        
        if ( grepl( ":", a ) )
        {
          strsplit( a, ":" ) |>
            unlist() ->
            sub.names.interaction
          
          confint1 -> tmp.ci1
          for ( b in sub.names.interaction )
          {
            tmp.ci1[grep( b, tmp.ci1[,1] ) , ] -> tmp.ci1
          }
        }
        
        cbind.force( tmp.ci1,
                     tmp.anova1[, -1 ],
                     empty = "" ) |>
          (function(x) rbind.force( tmp.anova,
                                    x,
                                    empty = "" ) )() ->
          tmp.anova ;
      }
      
      "ANODE (type 3 tests)" |> 
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      tmp.anova |>
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      "" |> (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      # Models infos
      c( "Multiple Cox an Snell pseuod-R-squared:", 
         IFELSE( is.null( round ), 
                 MuMIn::r.squaredLR( m1, stats::update( m1, reformulate( "1" ) ) )[1],
                 round( MuMIn::r.squaredLR( m1, stats::update( m1, reformulate( "1" ) ) )[1], 
                        round ) ),
         "Nagelkerke Adjusted pseudo-R-squared:", 
         IFELSE( is.null( round ), 
                 attr( MuMIn::r.squaredLR( m1, stats::update( m1, reformulate( "1" ) ) ),
                       "adj.r.squared"),
                 round( attr( MuMIn::r.squaredLR( m1, stats::update( m1, reformulate( "1" ) ) ),
                              "adj.r.squared"), 
                        round ) ) ) |> 
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      c( "AIC:", 
         IFELSE( is.null( round ), 
                 AIC(m1),
                 round( AIC(m1), round ) ),
         "AICc:", 
         IFELSE( is.null( round ), 
                 MuMIn::AICc(m1),
                 round( MuMIn::AICc(m1), round ) ) ) |> 
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      "" |> (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      # post hoc analysis with no plots
      
      # Dispersion 
      c( "Dispersion:", 
         IFELSE( is.null( round ), 
                 summary( m1 )$dispersion ,
                 round(  summary( m1 )$dispersion , round ) ) ) |> 
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      "" |> (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      #  Multicollinearity
      if ( length( attr( terms(m1),"term.labels") ) > 1 )
      {
        c( "Multicollinearity check" ) |> 
          (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
        
        c( "(generalized) Variance Inflation Factors:" ) |> 
          (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
        
        car::vif( m1 ) |>
          (function(x) IFELSE( is.null( round ), 
                               x,
                               round( x, round ) ) )() |>
          as.data.frame() |>
          (function(x)   cbind( Predictors = rownames(x), x ) )() -> 
          tmp.vif ;
        
        if ( ncol( tmp.vif ) == 2 ) { "VIF" -> colnames( tmp.vif )[2] }
        
        tmp.vif |>
          (function(x)  rbind.force( colnames(x), x ) )() |>
          (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
        
        "" |> (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
        
        # besley
        attr( terms( m1 ),"term.labels" ) -> Vars
        subset( data, 
                select = Vars[ 
                  !( Vars  %in% Vars[ grep( ":", Vars ) ] ) ] ) |>
          dplyr::select_if( is.numeric ) ->
          data2 
        
        VisCollin::colldiag( mod = glm(
          reformulate( colnames(data2),
                       as.character(formula)[2] ),
          family = family,
          data = data), 
          scale = FALSE, 
          center = FALSE, add.intercept = T ) -> 
          besley
        
        "Belsley criteria (computed on numeric predictors only):" |> (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
        data.frame( besley$condindx, besley$pi) |>
          (function(x) rbind( colnames(x), x ) )() |>
          (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
        "" |> (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      }
      
      #  Linearity and non-addititvity check
      c(  "Linearity and non-addititvity check" ) |> 
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab 
      
      "Best Fractional Polynomial for each numeric predictor:" |> 
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      formula |> as.character() -> formula1 ;
      
      Systematic.FP( output = formula1[2], 
                     predictors = attr( terms(m1), 'term.labels'),
                     family = family, 
                     data = data, 
                     na.omit = na.omit ) |>
        as.data.frame() |>
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      "" |> (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      # Observation with major influence
      c( "Observation with major influence" ) |> 
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      c( "Number of observations",
         "with a Cook distance",
         "over 4 / N:",
         sum( cooks.distance( m1 ) > 4 / nrow( data ) )
      ) |> 
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      "" |> (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      car::outlierTest( m1) |> 
        capture.output() |> 
        matrix(  ncol = 1) |>
        as.data.frame() |>
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      "" |> (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      "/////////////////////////////////////////////////////" |> 
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
    }
    
    if ( !FULL & ANODE )
    {
      # Anova
      m1 |>
        car::Anova(  type = 3) |>
        as.data.frame() |>
        (function(x) cbind( Predictors = rownames(x), x ) )() |>
        dplyr::transmute( Predictors = Predictors,
                          `LR Chisq` =  IFELSE( is.null( round ), 
                                                `LR Chisq`,
                                                round( `LR Chisq`, round ) ),
                          `Chisq Df` = Df,
                          `Residual Df` = m1$df.residual,
                          `--` = "",
                          `Pr(>Chisq)` =  IFELSE( is.null( pvalue.round ), 
                                                  `Pr(>Chisq)`,
                                                  p.round( `Pr(>Chisq)`, pvalue.round ) ) ) |>
        cbind(   `Cohen's f-squared on pseudo-R-squared` =  IFELSE( is.null( round ), 
                                                                    cohen.f2( m1, TRUE, family ),
                                                                    round( cohen.f2( m1, TRUE, family ), 
                                                                           round ) ) ) |>
        cbind( 
          `--` = "",
          AIC = IFELSE( is.null( round ), 
                        AIC( m1 ),
                        round( AIC( m1 ), round ) )) ->
        anova1 ;
      
      # fusion anova and CI
      c( confint1[1,], 
         colnames(anova1)[-1] ) |>
        matrix(  nrow = 1 ) -> 
        tmp.anova ;
      
      for ( a in as.character(anova1$Predictors) )
      {
        confint1[grep( a, confint1[,1] ) , ] -> tmp.ci1
        
        anova1[grep( a, anova1[,1] ) , ] -> tmp.anova1
        
        if ( !grepl( ":", a ) )
        {
          if ( length( grep( ":", tmp.ci1[,1] ) ) > 0 )
          {
            tmp.ci1[ -grep( ":", tmp.ci1[,1] ) , ] -> tmp.ci1
            
            tmp.anova1[ -grep( ":", 
                               as.character( tmp.anova1[,1] ) 
            ),  ] -> 
              tmp.anova1
          }
        }
        
        if ( grepl( ":", a ) )
        {
          strsplit( a, ":" ) |>
            unlist() ->
            sub.names.interaction
          
          confint1 -> tmp.ci1
          for ( b in sub.names.interaction )
          {
            tmp.ci1[grep( b, tmp.ci1[,1] ) , ] -> tmp.ci1
          }
        }
        
        cbind.force( tmp.ci1,
                     tmp.anova1[, -1 ],
                     empty = "" ) |>
          (function(x) rbind.force( tmp.anova,
                                    x,
                                    empty = "" ) )() ->
          tmp.anova ;
      }
      
      # Extraction
      lapply( 1:length(selected.predictors),  
              function(a){ 
                tmp.anova[ grep( selected.predictors[a],  tmp.anova[,1] ), ] } ) |> 
        (function(x) rbind.force( tmp.anova[1,], x, empty = "" ) )() |>
        unique() ->
        results.tab ;
    }
    
    
    if ( !FULL & !ANODE )
    {
      # Compute output
      summary1 |> 
        coef() |>
        as.data.frame() |>  
        dplyr::transmute( `Std. Error` =  IFELSE( is.null( round ), 
                                                  `Std. Error`,
                                                  round( `Std. Error`, round ) ),
                          `--` = "",
                          `z value` =  IFELSE( is.null( round ), 
                                               `z value`,
                                               round( `z value`, round ) ),
                          `Pr(>|z|)` =  IFELSE( is.null( pvalue.round ), 
                                                `Pr(>|z|)`,
                                                p.round( `Pr(>|z|)`, pvalue.round ) ) ) |>
        (function(x) rbind.force( colnames(x), x ) )()  |>
        (function(x)  cbind( confint1, x ) )() -> 
        tmp.student ;
      
      # Extraction
      lapply( 1:length(selected.predictors),  
              function(a){ 
                tmp.student[ grep( selected.predictors[a],  tmp.student[,1] ), ] } ) |> 
        (function(x) rbind.force( tmp.student[1,], x, empty = "" ) )() |>
        unique() ->
        results.tab ;
    }
    
    
    # output 
    NULL -> rownames( results.tab ) ;
    NULL -> colnames( results.tab ) ;
    
    c( output, list( results.tab = results.tab ) ) -> 
      output ;
    
    return( output )
  }
  
  Multinom.Analysis <- function( outcome, predictors,
                                 data, 
                                 HMF.test = TRUE,
                                 na.omit = TRUE,
                                 FULL = TRUE, 
                                 selected.predictors = NULL,
                                 ANODE = FALSE )
  {
    # Formula
    Formula.Maker( outcome, predictors ) -> 
      formula ;
    
    # model
    if ( na.omit == TRUE ) { na.omit( data ) -> data } 
    
    nnet::multinom( reformulate(as.character(formula)[3], as.character(formula)[2]), 
                    data = data, Hess = TRUE ) ->
      m1 ;
    
    m1 |> 
      (function(x) list( model = x ) )() -> 
      output ;
    
    m1 |> summary() -> summary1 ;
    
    summary1$coefficients |>
      (function(x) cbind( Predictors = rownames(x), x) )() |> 
      as.data.frame() |> 
      tidyr::gather( key = Predic, value = "Estimate", -Predictors ) ->
      Estimates ;
    
    summary1$standard.errors |>
      (function(x) cbind( Predictors = rownames(x), x) )() |> 
      as.data.frame() |> 
      tidyr::gather( key = Predic, value = "SE", -Predictors ) ->
      SEs ;
    
    merge( Estimates, SEs ) |>
      dplyr::mutate( Estimate = as.numeric( Estimate ), 
                     SE = as.numeric( SE ) ) |> 
      dplyr::transmute( Predictors = paste( Predictors, "|", Predic ),
                        Estimate = Estimate,
                        lb = Estimate - qnorm( (1 - conf.level) / 2, lower.tail = FALSE ) * SE,
                        ub = Estimate + qnorm( (1 - conf.level) / 2, lower.tail = FALSE ) * SE
      ) -> ci ;
    
    c( paste( (1 - conf.level) / 2 * 100, "%" ),
       paste( (1 -(1 - conf.level) / 2 ) * 100, "%" )  ) ->
      colnames( ci )[3:4] ;
    ci[,1] -> rownames( ci ) ;
    
    ci[,-1] |>
      exp() |>
      (function(x)  IFELSE( is.null( round ),
                            x,
                            round( x, round ) ) )() |>
      as.data.frame() |> 
      (function(x) cbind( Predictors = rownames(x), x ) )() -> 
      confint1 ;
    
    paste( "exp of", 
           colnames(confint1)[-1] ) ->
      colnames(confint1)[-1] ;
    
    
    # prepare results 
    if (FULL)
    {
      # formula
      "Model:" -> results.tab ;
      
      formula |> 
        deparse() |> 
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      "" |> (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      # missing data
      c( "Observations deleted due to missingness:",
         dim( data )[1] - dim( m1$residuals )[1] ) |> 
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      "" |> (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      #  slopes and t.tests
      "Model coefficients and t-tests" |> 
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      abs(summary1$coefficients /  summary1$standard.errors) |>
        pnorm(  lower.tail = FALSE )  |> 
        as.matrix(as.matrix() * 2)  |>  
        (function(x) IFELSE( is.null( pvalue.round ),
                             x, 
                             p.round( x, pvalue.round ) ) )() |>
        (function(x)  cbind( rownames(x), x) )() |> 
        as.data.frame() |> 
        tidyr::gather( key = V2, value = `Pr(>|z|)`, -V1 )  |> 
        dplyr::mutate( 
          Predictors = paste( V1, "|", V2 ) ) |>
        dplyr::select(  Predictors, `Pr(>|z|)` ) ->
        P ;
      
      (summary1$coefficients /  summary1$standard.errors) |>
        (function(x) IFELSE( is.null( round ),
                             x, 
                             round( x, round ) ) )() |>
        (function(x) cbind( rownames(x), x) )() |> 
        as.data.frame() |> 
        tidyr::gather( key = V2, value = `z value`, -V1 )  |> 
        dplyr::mutate(  
          Predictors = paste( V1, "|", V2 ) ) |>
        dplyr::select(  Predictors, `z value` ) ->
        Z ;
      
      
      summary1$standard.errors |> 
        (function(x) IFELSE( is.null( round ),
                             x, 
                             round( x, round ) ) )() |>
        (function(x) cbind( rownames(x), x) )() |> 
        as.data.frame() |> 
        tidyr::gather( key = V2, value = `Std. Error`, -V1 ) |>
        dplyr::mutate( 
          Predictors = paste( V1, "|", V2 ) ) |>
        dplyr::select(  Predictors, `Std. Error` ) ->
        SE1 ;
      
      merge( confint1, SE1) |>
        merge(   Z  ) |>
        dplyr::mutate( `--` = "" ) |>
        merge(  P )|>
        (function(x) rbind.force( colnames(x), x ) )()  |>
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      "" |> (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      c( "Number of Coefficients:", dim(summary1$standard.errors)[1] * dim(summary1$standard.errors)[2] ) |> 
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      "" |> (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      # Anova
      m1 |>
        car::Anova(  type = 3) |>
        as.data.frame() |>
        (function(x) cbind( Predictors = rownames(x), x ) )() |>
        dplyr::transmute( Predictors = Predictors,
                          `LR Chisq` =  IFELSE( is.null( round ), 
                                                `LR Chisq`,
                                                round( `LR Chisq`, round ) ),
                          `Chisq Df` = Df,
                          `Residual Df` = dim( m1$residuals)[1] - dim(summary1$standard.errors)[1] * dim(summary1$standard.errors)[2] ,
                          `--` = "",
                          `Pr(>Chisq)` =  IFELSE( is.null( pvalue.round ), 
                                                  `Pr(>Chisq)`,
                                                  p.round( `Pr(>Chisq)`, pvalue.round ) ) ) |>
        cbind(   `Cohen's f-squared on pseudo-R-squared` =  IFELSE( is.null( round ), 
                                                                    cohen.f2( m1, TRUE ),
                                                                    round( cohen.f2( m1, TRUE ), 
                                                                           round ) ) ) |>
        cbind(  
          `--` = "",
          AIC = IFELSE( is.null( round ), 
                        AIC( m1 ),
                        round( AIC( m1 ), round ) )) ->
        anova1 ;
      
      # fusion anova and CI
      c( colnames( confint1 ), 
         colnames(anova1)[-1] ) |>
        matrix(  nrow = 1 ) -> 
        tmp.anova ;
      
      for ( a in as.character(anova1$Predictors) )
      {
        confint1[grep( a, confint1[,1] ) , ] -> tmp.ci1
        
        anova1[grep( a, anova1[,1] ) , ] -> tmp.anova1
        
        if ( !grepl( ":", a ) )
        {
          if ( length( grep( ":", tmp.ci1[,1] ) ) > 0 )
          {
            tmp.ci1[ -grep( ":", tmp.ci1[,1] ) , ] -> tmp.ci1
            
            tmp.anova1[ -grep( ":", 
                               as.character( tmp.anova1[,1] ) 
            ),  ] -> 
              tmp.anova1
          }
        }
        
        if ( grepl( ":", a ) )
        {
          strsplit( a, ":" ) |>
            unlist() ->
            sub.names.interaction
          
          confint1 -> tmp.ci1
          for ( b in sub.names.interaction )
          {
            tmp.ci1[grep( b, tmp.ci1[,1] ) , ] -> tmp.ci1
          }
        }
        
        cbind.force( tmp.ci1,
                     tmp.anova1[, -1 ],
                     empty = "" ) |>
          (function(x) rbind.force( tmp.anova,
                                    x,
                                    empty = "" ) )() ->
          tmp.anova ;
      }
      
      "ANODE (type 3 tests)" |> 
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      tmp.anova |>
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      "" |> (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      # Models infos
      c( "Multiple Cox an Snell pseuod-R-squared:", 
         IFELSE( is.null( round ), 
                 MuMIn::r.squaredLR( m1, stats::update( m1, reformulate( "1" ) ) )[1],
                 round( MuMIn::r.squaredLR( m1, stats::update( m1, reformulate( "1" ) ) )[1], 
                        round ) ),
         "Nagelkerke Adjusted pseudo-R-squared:", 
         IFELSE( is.null( round ), 
                 attr( MuMIn::r.squaredLR( m1, stats::update( m1, reformulate( "1" ) ) ),
                       "adj.r.squared"),
                 round( attr( MuMIn::r.squaredLR( m1, stats::update( m1, reformulate( "1" ) ) ),
                              "adj.r.squared"), 
                        round ) ) ) |> 
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      c( "AIC:", 
         IFELSE( is.null( round ), 
                 AIC(m1),
                 round( AIC(m1), round ) ),
         "AICc:", 
         IFELSE( is.null( round ), 
                 MuMIn::AICc(m1),
                 round( MuMIn::AICc(m1), round ) ) ) |> 
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      "" |> (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      # post hoc analysis with no plots
      
      #  Multicollinearity
      c( "Multicollinearity check" ) |> 
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      c( "(generalized) Variance Inflation Factors:", "No intercept include for computations: vifs may not be sensible" ) |> 
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      if ( length( attr( terms( formula ),"term.labels" ) ) == 1 )
      {
        data.frame( "no possible because just 1 predictor" ) -> tmp.mc ;
      } else
      {
        "" -> tmp.mc
        # vif
        car::vif( m1 ) |>
          (function(x) IFELSE( is.null( round ), 
                               x,
                               round( x, round ) ) )() |>
          as.data.frame() |>
          (function(x)  cbind( Predictors = rownames(x), x ) )() -> 
          tmp.vif ;
        
        if ( ncol( tmp.vif ) == 2 ) { "VIF" -> colnames( tmp.vif )[2] }
        
        tmp.vif |>
          (function(x) rbind.force( colnames(x), x ) )() |>
          (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
        "" |> (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
        
        # besley
        attr( terms( m1 ),"term.labels" ) -> Vars
        base::subset( data, 
                      select = Vars[ 
                        !( Vars  %in% Vars[ grep( ":", Vars ) ] ) ] ) |>
          dplyr::select_if( is.numeric ) ->
          data2 
        
        VisCollin::colldiag( mod = nnet::multinom(
          reformulate( colnames(data2),
                       as.character(formula)[2] ),
          data = data,
          model = T ), 
          scale = FALSE, 
          center = FALSE, add.intercept = T ) -> 
          besley
        
        "Belsley criteria (computed on numeric predictors only):" |> (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
        data.frame( besley$condindx, besley$pi ) |>
          (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
        "" |> (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      }
      
      tmp.mc |>
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      "" |> (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      # Independence of Irrelevant Alternatives assumption : Hauslab-McFadden test
      c( "Independence of Irrelevant Alternatives assumption" ) |> 
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      if ( HMF.test )
      {
        c( "Hauslab-McFadden test:" ) |> 
          (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
        
        hmftest.systematic( formula, data ) |>
          data.frame() |>
          (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ; 
        
        "" |> (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      }
      
      c( "Substracting each levels of outcome:" ) |> 
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      Multinomial.SubsetLevels( formula, data, round = round ) |>
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      "" |> (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      "/////////////////////////////////////////////////////" |> 
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
    }
    
    if ( !FULL & ANODE )
    {
      # Anova
      m1 |>
        car::Anova( type = 3) |>
        as.data.frame() |>
        (function(x) cbind( Predictors = rownames(x), x ) )() |>
        dplyr::transmute( Predictors = Predictors,
                          `LR Chisq` =  IFELSE( is.null( round ), 
                                                `LR Chisq`,
                                                round( `LR Chisq`, round ) ),
                          `Chisq Df` = Df,
                          `Residual Df` = dim( m1$residuals)[1] - dim(summary1$standard.errors)[1] * dim(summary1$standard.errors)[2] ,
                          `--` = "",
                          `Pr(>Chisq)` =  IFELSE( is.null( pvalue.round ), 
                                                  `Pr(>Chisq)`,
                                                  p.round( `Pr(>Chisq)`, pvalue.round ) ) ) |>
        cbind(   `Cohen's f-squared on pseudo-R-squared` =  IFELSE( is.null( round ), 
                                                                    cohen.f2( m1, TRUE ),
                                                                    round( cohen.f2( m1, TRUE ), 
                                                                           round ) ) ) |>
        cbind(  
          `--` = "",
          AIC = IFELSE( is.null( round ), 
                        AIC( m1 ),
                        round( AIC( m1 ), round ) )) ->
        anova1 ;
      
      # fusion anova and CI
      c( colnames( confint1 ), 
         colnames(anova1)[-1] ) |>
        matrix(  nrow = 1 ) -> 
        tmp.anova ;
      
      for ( a in as.character(anova1$Predictors) )
      {
        confint1[grep( a, confint1[,1] ) , ] -> tmp.ci1
        
        anova1[grep( a, anova1[,1] ) , ] -> tmp.anova1
        
        if ( !grepl( ":", a ) )
        {
          if ( length( grep( ":", tmp.ci1[,1] ) ) > 0 )
          {
            tmp.ci1[ -grep( ":", tmp.ci1[,1] ) , ] -> tmp.ci1
            
            tmp.anova1[ -grep( ":", 
                               as.character( tmp.anova1[,1] ) 
            ),  ] -> 
              tmp.anova1
          }
        }
        
        if ( grepl( ":", a ) )
        {
          strsplit( a, ":" ) |>
            unlist() ->
            sub.names.interaction
          
          confint1 -> tmp.ci1
          for ( b in sub.names.interaction )
          {
            tmp.ci1[grep( b, tmp.ci1[,1] ) , ] -> tmp.ci1
          }
        }
        
        cbind.force( tmp.ci1,
                     tmp.anova1[, -1 ],
                     empty = "" ) |>
          (function(x) rbind.force( tmp.anova,
                                    x,
                                    empty = "" ) )() ->
          tmp.anova ;
      }
      
      # Extraction
      lapply( 1:length(selected.predictors),  
              function(a){ 
                tmp.anova[ grep( selected.predictors[a],  tmp.anova[,1] ), ] } ) |> 
        (function(x) rbind.force( tmp.anova[1,], x, empty = "" ) )() |>
        unique() ->
        results.tab ;
    }
    
    
    if ( !FULL & !ANODE )
    {
      #  slopes and t.tests
      abs(summary1$coefficients /  summary1$standard.errors) |>
        pnorm(  lower.tail = FALSE )  |> 
        (function(x)  as.matrix(as.matrix(x) * 2) )()  |>  
        (function(x) IFELSE( is.null( pvalue.round ),
                             x, 
                             p.round( x, pvalue.round ) ) )() |>
        (function(x)  cbind( rownames(x), x) )() |> 
        as.data.frame() |> 
        tidyr::gather( key = V2, value = `Pr(>|z|)`, -V1 )  |> 
        dplyr::mutate(  
          Predictors = paste( V1, "|", V2 ) ) |>
        dplyr::select(  Predictors, `Pr(>|z|)` ) ->
        P ;
      
      (summary1$coefficients /  summary1$standard.errors) |>
        (function(x) IFELSE( is.null( round ),
                             x, 
                             round( x, round ) ) )() |>
        (function(x) cbind( rownames(x), x) )() |> 
        as.data.frame() |> 
        tidyr::gather( key = V2, value = `z value`, -V1 )  |> 
        dplyr::mutate(  
          Predictors = paste( V1, "|", V2 ) ) |>
        dplyr::select(  Predictors, `z value` ) ->
        Z ;
      
      
      summary1$standard.errors |> 
        (function(x) IFELSE( is.null( round ),
                             x, 
                             round( x, round ) ) )() |>
        (function(x) cbind( rownames(x), x) )() |> 
        as.data.frame() |> 
        tidyr::gather( key = V2, value = `Std. Error`, -V1 ) |>
        dplyr::mutate(  
          Predictors = paste( V1, "|", V2 ) ) |>
        dplyr::select(  Predictors, `Std. Error` ) ->
        SE1 ;
      
      merge( confint1, SE1) |>
        merge(   Z  ) |>
        dplyr::mutate( `--` = "" ) |>
        merge(  P )|>
        (function(x) rbind.force( colnames(x), x) )()    -> 
        tmp.student ;
      
      # Extraction
      lapply( 1:length(selected.predictors),  
              function(a){ 
                tmp.student[ grep( selected.predictors[a],  tmp.student[,1] ), ] } ) |> 
        (function(x) rbind.force( tmp.student[1,], x, empty = "" ) )() |>
        unique() ->
        results.tab ;
    }
    
    
    # output 
    NULL -> rownames( results.tab ) ;
    NULL -> colnames( results.tab ) ;
    
    c( output, list( results.tab = results.tab ) ) -> 
      output ;
    
    return( output )
  }
  
  Ordinal.Analysis <- function( outcome, predictors,  
                                data, 
                                na.omit = TRUE,
                                FULL = TRUE, 
                                selected.predictors = NULL,
                                ANODE = FALSE )
  {
    # Formula
    Formula.Maker( outcome, predictors ) -> 
      formula ;
    
    # model
    formula -> formula1 ;
    
    data -> data.clm ;
    
    if ( na.omit == TRUE ) { na.omit( data ) -> data } 
    
    MASS::polr( formula1, data = data, Hess = TRUE ) ->
      m1 ;
    
    try( ordinal::clm( formula1, data = data.clm ), silent = T  ) -> clm1
    
    m1 |> summary() -> summary1 ;
    
    summary1$coefficients |>
      as.data.frame() |>
      (function(x) data.frame( Predictors = rownames(x),
                               Estimate = x$Value,
                               lb = x$Value - qnorm( (1 - conf.level) / 2, lower.tail = FALSE ) * x$`Std. Error`,
                               ub = x$Value + qnorm( (1 - conf.level) / 2, lower.tail = FALSE ) * x$`Std. Error` 
      ) 
      )() -> ci ;
    
    c( paste( (1 - conf.level) / 2 * 100, "%" ),
       paste( (1 -(1 - conf.level) / 2 ) * 100, "%" )  ) ->
      colnames( ci )[3:4] ;
    ci[,1] -> rownames( ci ) ;
    
    ci[,-1] |>
      exp() |>
      (function(x) IFELSE( is.null( round ),
                           x,
                           round( x ) ) )() |>
      as.data.frame() |> 
      (function(x) cbind( Predictors = rownames(x), x ) )() |> 
      (function(x) rbind.force( c( colnames(x)[1], 
                                   paste( "exp of", 
                                          colnames(x)[-1] ) ), 
                                x ) )() -> 
      confint1 ;
    
    # prepare results 
    if (FULL)
    {
      # formula
      "Model:" -> results.tab ;
      
      formula |> 
        deparse() |> 
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      "" |> (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      # missing data
      c( "Observations deleted due to missingness:",
         dim( data )[1] - dim( m1$model )[1] ) |> 
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      "" |> (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      #  slopes and t.tests
      "Model coefficients and t-tests" |> 
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      summary1 |> 
        coef() |>
        as.data.frame() |>  
        dplyr::transmute( `Std. Error` =  IFELSE( is.null( round ), 
                                                  `Std. Error`,
                                                  round( `Std. Error`, round ) ),
                          `--` = "",
                          `z value` =  IFELSE( is.null( round ), 
                                               Value / `Std. Error`,
                                               round( Value / `Std. Error`, round ) ),
                          `Pr(>|z|)` =  IFELSE( is.null( pvalue.round ), 
                                                pnorm( abs( Value / `Std. Error` ), 
                                                       lower.tail = FALSE ) * 2,
                                                p.round( pnorm( abs( Value / `Std. Error` ), 
                                                                lower.tail = FALSE ) * 2,
                                                         pvalue.round ) ) ) |>
        (function(x) rbind.force( colnames(x), x) )()  |>
        (function(x)  cbind( confint1, x )  )() |>
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      "" |> (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      c( "Degrees of freedom:", summary1$df.residual,
         "Number of Coefficients:", length(coef(m1)) + length(m1$zeta) ) |> 
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      "" |> (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      # Anova
      m1 |>
        car::Anova( type = 3) |>
        as.data.frame() |>
        (function(x) cbind( Predictors = rownames(x), x ) )() |>
        dplyr::transmute( Predictors = Predictors,
                          `LR Chisq` =  IFELSE( is.null( round ), 
                                                `LR Chisq`,
                                                round( `LR Chisq`, round ) ),
                          `Chisq Df` = Df,
                          `Residual Df` = m1$df.residual,
                          `--` = "",
                          `Pr(>Chisq)` =  IFELSE( is.null( pvalue.round ), 
                                                  `Pr(>Chisq)`,
                                                  p.round( `Pr(>Chisq)`, pvalue.round ) ) ) |>
        cbind(  `Cohen's f-squared on pseudo-R-squared` =  IFELSE( is.null( round ), 
                                                                   cohen.f2( m1, TRUE ),
                                                                   round( cohen.f2( m1, TRUE ), 
                                                                          round ) ) ) |>
        cbind( 
          `--` = "",
          AIC = IFELSE( is.null( round ), 
                        AIC( m1 ),
                        round( AIC( m1 ), round ) )) ->
        anova1 ;
      
      # fusion anova and CI
      c( confint1[1,], 
         colnames(anova1)[-1] ) |>
        matrix( nrow = 1 ) -> 
        tmp.anova ;
      
      for ( a in as.character(anova1$Predictors) )
      {
        c( confint1[1,], 
           colnames(anova1)[-1] ) |>
          matrix( nrow = 1 ) -> 
          tmp.anova ;
        
        for ( a in as.character(anova1$Predictors) )
        {
          confint1[grep( a, confint1[,1] ) , ] -> tmp.ci1
          
          anova1[grep( a, anova1[,1] ) , ] -> tmp.anova1
          
          if ( !grepl( ":", a ) )
          {
            if ( length( grep( ":", tmp.ci1[,1] ) ) > 0 )
            {
              tmp.ci1[ -grep( ":", tmp.ci1[,1] ) , ] -> tmp.ci1
              
              tmp.anova1[ -grep( ":", 
                                 as.character( tmp.anova1[,1] ) 
              ),  ] -> 
                tmp.anova1
            }
          }
          
          if ( grepl( ":", a ) )
          {
            strsplit( a, ":" ) |>
              unlist() ->
              sub.names.interaction
            
            confint1 -> tmp.ci1
            for ( b in sub.names.interaction )
            {
              tmp.ci1[grep( b, tmp.ci1[,1] ) , ] -> tmp.ci1
            }
          }
          
          cbind.force( tmp.ci1,
                       tmp.anova1[, -1 ],
                       empty = "" ) |>
            (function(x) rbind.force( tmp.anova,
                                      x,
                                      empty = "" ) )() ->
            tmp.anova ;
        }
      }
      
      "ANODE (type 3 tests)" |> 
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      tmp.anova |>
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      "" |> (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      # Models infos
      c( "Multiple Cox an Snell pseuod-R-squared:", 
         IFELSE( is.null( round ), 
                 MuMIn::r.squaredLR( m1, stats::update( m1, reformulate( "1" ) ) )[1],
                 round( MuMIn::r.squaredLR( m1, stats::update( m1, reformulate( "1" ) ) )[1], 
                        round ) ),
         "Nagelkerke Adjusted pseudo-R-squared:", 
         IFELSE( is.null( round ), 
                 attr( MuMIn::r.squaredLR( m1, stats::update( m1, reformulate( "1" ) ) ),
                       "adj.r.squared"),
                 round( attr( MuMIn::r.squaredLR( m1, stats::update( m1, reformulate( "1" ) ) ),
                              "adj.r.squared"), 
                        round ) ) ) |> 
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      c( "AIC:", 
         IFELSE( is.null( round ), 
                 AIC(m1),
                 round( AIC(m1), round ) ),
         "AICc:", 
         IFELSE( is.null( round ), 
                 MuMIn::AICc(m1),
                 round( MuMIn::AICc(m1), round ) ) ) |> 
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      "" |> (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      # post hoc analysis with no plots
      
      #  Multicollinearity
      c( "Multicollinearity check" ) |> 
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      c( "(generalized) Variance Inflation Factors:", "No intercept: vifs may not be sensible" ) |> 
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      if ( length( attr( terms( formula ),"term.labels" ) ) == 1 )
      {
        data.frame( "no possible because just 1 predictor" ) -> tmp.mc ;
      } else
      {
        "" -> tmp.mc
        # vif
        car::vif( m1 ) |>
          (function(x) IFELSE( is.null( round ), 
                               x,
                               round( round ) ) )() |>
          as.data.frame() |>
          (function(x) cbind( Predictors = rownames(x), x ) )() -> 
          tmp.vif ;
        
        if ( ncol( tmp.vif ) == 2 ) { "VIF" -> colnames( tmp.vif )[2] }
        
        tmp.vif |>
          (function(x) rbind.force( colnames(x), x) )() |>
          (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
        "" |> (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
        
        # besley
        attr( terms( m1 ),"term.labels" ) -> Vars
        subset( data, 
                select = Vars[ 
                  !( Vars  %in% Vars[ grep( ":", Vars ) ] ) ] ) |>
          dplyr::select_if( is.numeric ) ->
          data2 
        
        VisCollin::colldiag( mod = MASS::polr(
          reformulate( colnames(data2),
                       as.character(formula)[2] ),
          data = data ), 
          scale = FALSE, 
          center = FALSE, add.intercept = T ) -> 
          besley
        
        "Belsley criteria (computed on numeric predictors only):" |> (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
        data.frame( besley$condindx, besley$pi) |>
          (function(x) rbind( colnames(x), x ) )() |>
          (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
        "" |> (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
        
      }
      
      tmp.mc |>
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      "" |> (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      # Proportional odds assumptions
      c( "Proportional odds assumption" ) |> 
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      c( "Test of Brant:" ) |> 
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      if ( length( grep( ":", attr( terms( m1 ), "term.labels" ) ) ) == 0 &
           length( attr( terms( m1 ), "term.labels" )  ) > 1)
      {
        brant.perso(m1) |> 
          as.matrix() |> 
          (function(x) data.frame( rownames(x), x) )() |>
          setNames( c( "Predictors", "Chisq", "df", "p" ) ) |> 
          (function(x) data.frame( Predictors = x$Predictors, "Chisq" = IFELSE( is.null(round), 
                                                                                x[,"Chisq"], 
                                                                                round( x[,"Chisq"], round) ),
                                   "p" = IFELSE( is.null( pvalue.round ), 
                                                 x[,"p"], 
                                                 p.round( x[,"p"], pvalue.round ) )
          ) )() |> 
          (function(x) rbind( colnames(x), x ) )() |> 
          (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
        "" |> (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      } else
      {
        "test is not applicable because presence of interacions or because just 1 predictor" |> 
          (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
        "" |> (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      }
      
      c( "Nominal test:" ) |> 
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      if (attr( clm1,"class") == "try-error" )
      {
        "Nominal test not computable" -> output ; 
      } else
      {
        nominal_test.perso( clm1, formula1, data.clm ) |>
          setNames( c( "Predictors", "Df", "logLik", "AIC", "LRT", "Pr(>Chi)" ) ) |> 
          (function(x) data.frame( "logLik" = IFELSE( is.null(round), 
                                                      x[,"logLik"], 
                                                      round( x[,"logLik"], round) ),
                                   "AIC" = IFELSE( is.null(round), 
                                                   x[,"AIC"], 
                                                   round( x[,"AIC"], round) ),
                                   "LRT" = IFELSE( is.null(round), 
                                                   x[,"LRT"], 
                                                   round( x[,"LRT"], round) ),
                                   "Pr(>Chi)" = IFELSE( is.null( pvalue.round ), 
                                                        x[,"Pr(>Chi)"], 
                                                        p.round( x[,"Pr(>Chi)"], pvalue.round ) )
          ) )() |> 
          (function(x) rbind( colnames(x), x ) )() |> 
          (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      }
      
      
      "" |> (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      "/////////////////////////////////////////////////////" |> 
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
    }
    
    if ( !FULL & ANODE )
    {
      # Anova
      m1 |>
        car::Anova( type = 3) |>
        as.data.frame() |>
        (function(x) cbind( Predictors = rownames(x), x ) )() |>
        dplyr::transmute( Predictors = Predictors,
                          `LR Chisq` =  IFELSE( is.null( round ), 
                                                `LR Chisq`,
                                                round( `LR Chisq`, round ) ),
                          `Chisq Df` = Df,
                          `Residual Df` = m1$df.residual,
                          `--` = "",
                          `Pr(>Chisq)` =  IFELSE( is.null( pvalue.round ), 
                                                  `Pr(>Chisq)`,
                                                  p.round( `Pr(>Chisq)`, pvalue.round ) ) ) |>
        cbind(  `Cohen's f-squared on pseudo-R-squared` =  IFELSE( is.null( round ), 
                                                                   cohen.f2( m1, TRUE ),
                                                                   round( cohen.f2( m1, TRUE ), 
                                                                          round ) ) ) |>
        cbind( 
          `--` = "",
          AIC = IFELSE( is.null( round ), 
                        AIC( m1 ),
                        round( AIC( m1 ), round ) )) ->
        anova1 ;
      
      # fusion anova and CI
      c( confint1[1,], 
         colnames(anova1)[-1] ) |>
        matrix( nrow = 1 ) -> 
        tmp.anova ;
      
      for ( a in as.character(anova1$Predictors) )
      {
        c( confint1[1,], 
           colnames(anova1)[-1] ) |>
          matrix( nrow = 1 ) -> 
          tmp.anova ;
        
        for ( a in as.character(anova1$Predictors) )
        {
          confint1[grep( a, confint1[,1] ) , ] -> tmp.ci1
          
          anova1[grep( a, anova1[,1] ) , ] -> tmp.anova1
          
          if ( !grepl( ":", a ) )
          {
            if ( length( grep( ":", tmp.ci1[,1] ) ) > 0 )
            {
              tmp.ci1[ -grep( ":", tmp.ci1[,1] ) , ] -> tmp.ci1
              
              tmp.anova1[ -grep( ":", 
                                 as.character( tmp.anova1[,1] ) 
              ),  ] -> 
                tmp.anova1
            }
          }
          
          if ( grepl( ":", a ) )
          {
            strsplit( a, ":" ) |>
              unlist() ->
              sub.names.interaction
            
            confint1 -> tmp.ci1
            for ( b in sub.names.interaction )
            {
              tmp.ci1[grep( b, tmp.ci1[,1] ) , ] -> tmp.ci1
            }
          }
          
          cbind.force( tmp.ci1,
                       tmp.anova1[, -1 ],
                       empty = "" ) |>
            (function(x) rbind.force( tmp.anova,
                                      x,
                                      empty = "" ) )() ->
            tmp.anova ;
        }
      }
      
      # Extraction
      lapply( 1:length(selected.predictors),  
              function(a){ 
                tmp.anova[ grep( selected.predictors[a],  tmp.anova[,1] ), ] } ) |> 
        (function(x) rbind.force( tmp.anova[1,], x, empty = "" ) )() |>
        unique() ->
        results.tab ;
    }
    
    if ( !FULL & !ANODE )
    {
      # Compute output
      summary1 |> 
        coef() |>
        as.data.frame() |>  
        (function(x) data.frame( `Std. Error` =  IFELSE( is.null( round ), 
                                                         x$`Std. Error`,
                                                         round( x$`Std. Error`, round ) ),
                                 `--` = "",
                                 `z value` =  IFELSE( is.null( round ), 
                                                      x$Value / x$`Std. Error`,
                                                      round( x$Value / x$`Std. Error`, round ) ),
                                 `Pr(>|z|)` =  IFELSE( is.null( pvalue.round ), 
                                                       pnorm( abs( x$Value / x$`Std. Error` ), 
                                                              lower.tail = FALSE ) * 2,
                                                       p.round( pnorm( abs( x$Value / x$`Std. Error` ), 
                                                                       lower.tail = FALSE ) * 2,
                                                                pvalue.round ) ) ) )() |>
        (function(x) rbind.force( colnames(x), x) )()  |>
        (function(x) cbind( confint1, x ) )()  -> 
        tmp.student ;
      
      # Extraction
      lapply( 1:length(selected.predictors),  
              function(a){ 
                tmp.student[ grep( selected.predictors[a],  tmp.student[,1] ), ] 
              } ) |> 
        (function(x) rbind.force( tmp.student[1,], x, empty = "" ) )() |>
        unique() ->
        results.tab ;
    }
    
    
    # output 
    NULL -> rownames( results.tab ) ;
    NULL -> colnames( results.tab ) ;
    
    list( model = m1,  results.tab = results.tab  ) -> 
      output ;
    
    return( output )
  }
  
  Lm.Plot <- function( model, ExportName )
  {
    # Pair graphics on variables 
    pairs2( subset( model$model, select = 1), 
            subset( model$model, select = -1), 
            ExportName, 4 )
    
    # Terms plot
    if ( length( attr( terms(model),"term.labels") ) < 7 &
         all( !grepl( ":", attr( terms(model),"term.labels") ) ) )
    {
      termplot2( model, ExportName) ;
    }
    
    # Normality Study
    png( paste( ExportName,
                "Normality_Study_of_Studendized_Residuals",
                ".png",
                sep = "" ) )
    MASS::studres( model ) |> Normality.Plot.Unique( "Studendized Residuals") ;
    dev.off() ;
    
    # Residuals vs IV
    residualPlots2( model, ExportName ) ;
    
    # Added variables plot 
    avPlots2( model, ExportName) ;
    
    # Residuals vs Fitted
    png( paste( ExportName,
                "Residuals_vs_Fitted",
                ".png",
                sep = "" ),
         width = 270,
         height = 600 )
    par( mfrow = c( 3, 1), oma = c( 0, 0, 2, 0) )
    plot( model , c(1), ask = FALSE, sub.caption = "")
    car::residualPlot( model, type = "rstandard", col.quad = "red", 
                       ylab = "Standardized reisudals",
                       main = "Standardized residual vs Fitted")
    plot( model , c(3), ask = FALSE, sub.caption = "")
    mtext( text =  "Residuals vs Fitted Graphics", 
           outer = TRUE, cex = 1.5 ) ;
    dev.off() ;
    
    # Component + residuals  plot 
    if ( all( !grepl( ":", attr( terms(model),"term.labels") ) ) )
    {
      crPlots2( model, ExportName )
    }
    
    #  Cook's distance and Leverage graphics 
    png( paste( ExportName,
                "Cooksdistance_and_Leverage_Graphics",
                ".png",
                sep = "" ),
         width = 270,
         height = 600 )
    par( mfrow = c( 3, 1), oma = c( 0, 0, 2, 0) )
    plot( model , c(5:6), ask = FALSE, sub.caption = "")
    dotchart( sort( sort( cooks.distance( model ), decreasing = T )[1:15] ), 
              main = "Top 15 Cook's distances", 
              xlab = "Cook distance", 
              sub = paste( "cutoff:", 
                           round( 4 / (length( cooks.distance( model ) ) ), 2 ) ) )
    abline( v = 4 / (length( nrow( model$model ) ) ), 
            col = "red" )
    mtext( text =  "Cook's distance and Leverage Graphics", 
           outer = TRUE, cex = 1.2 ) ;
    dev.off() ;
    
    # Influences graphics 
    png( paste( ExportName,
                "Influence_Plots",
                ".png",
                sep = "" ) )
    car::infIndexPlot( model, main =  "Influence Index Plot" )
    dev.off() ;
  }
  
  Glm.Plot <- function( model, ExportName )
  {
    # Pair graphics on variables 
    data.frame( model$fitted.values ) |>
      magrittr::set_colnames( paste( "fitted.LogOR",
                                     as.character( terms(model) )[2],
                                     sep = ".")  ) |>
      pairs2( 
        subset( model$model, select = -1), 
        ExportName, 4 )
    
    # Terms plot
    if ( length( attr( terms(model),"term.labels") ) < 7  &
         all( !grepl( ":", attr( terms(model),"term.labels") ) ) )
    {
      termplot2(model, ExportName )
    }
    
    # Added variables plot 
    model |> avPlots2( ExportName) ;
    
    # Compornent + residuals  plot 
    if ( all( !grepl( ":", attr( terms(model),"term.labels") ) ) )
    {
      crPlots2( model, ExportName )
    }
    
    # Residuals vs Fitted
    png( paste( ExportName,
                "Residuals_vs_Fitted",
                ".png",
                sep = "" ),
         width = 270,
         height = 600 )
    par( mfrow = c( 3, 1), oma = c( 0, 0, 2, 0) )
    plot( model , c(1), ask = FALSE, sub.caption = "")
    car::residualPlot( model, col.quad = "red")
    plot( model$fitted.values,
          sqrt( abs( residuals( model, type = "pearson" ) ) ),
          ylab = "sqrt( | Pearson's reisduals | )",
          xlab =  "Fitted values",
          main = "Scale-Location"
    )
    car::loessLine( model$fitted.values,
                    sqrt( abs( residuals( model, type = "pearson" ) ) ),
                    col = "red" )
    mtext( text =  "Residuals vs Fitted Graphics", 
           outer = TRUE, cex = 1.5 ) ;
    dev.off() ;
    
    #  Cook's distance and Leverage graphics 
    png( paste( ExportName,
                "Cooksdistance_and_Leverage_Graphics",
                ".png",
                sep = "" ),
         width = 270,
         height = 600 )
    par( mfrow = c( 3, 1), oma = c( 0, 0, 2, 0) )
    plot( model , c(5:6), ask = FALSE, sub.caption = "")
    dotchart( sort( sort( cooks.distance( model ), decreasing = T )[1:15] ), 
              main = "Top 15 Cook's distances", 
              xlab = "Cook distance", 
              sub = paste( "cutoff:", 
                           round( 4 / (length( cooks.distance( model ) ) ), 2 ) ) )
    abline( v = 4 / (length( cooks.distance( model ) ) ), 
            col = "red" )
    mtext( text =  "Cook's distance and Leverage Graphics", 
           outer = TRUE, cex = 1.2 ) ;
    dev.off() ;
    
    # Influences graphics 
    png( paste( ExportName,
                "Influence_Plots",
                ".png",
                sep = "" ) )
    car::infIndexPlot( model )
    dev.off() ;
  }
  
  Multinom.Plot <- function( model, data, ExportName )
  {
    # Pair graphics on variables 
    attr( terms( model ),"term.labels" ) -> Vars
    
    data.frame( model$fitted.values ) |>
      (function(x) magrittr::set_colnames( x, paste( "fitted.LogOR",
                                                     colnames(x),
                                                     sep = ".")  ) )() |>
      pairs2( 
        data.frame(
          subset( data, 
                  select = Vars[ 
                    !( Vars  %in% Vars[ grep( ":", Vars ) ] ) ] )), 
        ExportName, 2 )
    
    # Residuals vs Fitted
    model$fitted.values |>
      as.data.frame() |>
      tidyr::gather( key = Levels, value = Fitted  ) -> 
      Fitted1 ;
    
    model$residuals |>
      as.data.frame() |>
      tidyr::gather( key = levels1, value = Residuals  ) |>
      dplyr::select( -levels1 ) -> 
      Resid1 ;
    
    cbind( Fitted1, Resid1 ) |> 
      ggplot() +
      geom_point( aes( x = Fitted, y = Residuals ) ) +
      facet_grid( . ~ Levels, scales = "free" ) +
      labs( title = "Residuals vs Fitted for cumulative link models" ) -> 
      g1 ;
    
    paste( ExportName,
           "Residuals_vs_Fitted",
           ".png",
           sep = "" ) |>
      ggsave( g1, width = 8, height = 3 ) ;
  }
  
  Ordinal.Plot <- function( model, ExportName )
  {
    # Pair graphics on variables 
    data.frame( model$fitted.values ) |>
      (function(x) magrittr::set_colnames( x, paste( "fitted.LogOR",
                                                     colnames(x),
                                                     sep = ".")  ) )() |>
      pairs2( 
        subset( model$model, select = -1), 
        ExportName, 2 )
    
    # Residuals vs Fitted
    model$fitted.values |>
      as.data.frame() |>
      tidyr::gather( key = Levels, value = Fitted  ) -> 
      Fitted1 ;
    
    model |>
      residuals.polr() |>
      as.data.frame() |>
      tidyr::gather( key = levels1, value = Residuals  ) |>
      dplyr::select( -levels1 ) -> 
      Resid1 ;
    
    cbind( Fitted1, Resid1 ) |> 
      ggplot() +
      geom_point( aes( x = Fitted, y = Residuals ) ) +
      facet_grid( . ~ Levels, scales = "free" ) +
      labs( title = "Residuals vs Fitted for the cumulative link models" ) -> 
      g1 ;
    
    paste( ExportName,
           "Residuals_vs_Fitted",
           ".png",
           sep = "" ) |>
      ggsave( g1, width = 8, height = 3 ) ;
  }
  
  fun.a <- function( a )
  {
    
    lapply( 1:length( changing.predictors ),
            fun.b,
            a = a ) |>
      rbind.force(
        empty = "" ) ->
      output.a
    
    return( output.a )
  }
  
  fun.a.parallel <- function( a )
  {
    
    furrr::future_map( 1:length( changing.predictors ),
                       fun.b,
                       a = a,
                       .options = furrr::furrr_options(seed = TRUE), .progress = T 
    ) |>
      rbind.force(
        empty = "" ) ->
      output.a
    
    return( output.a )
  }
  
  fun.b <- function( b, a )
  {
    #print( "a : ") ;  print( a ); print( "b : ") ; print(b)
    
    # Prepare base name for graphics
    paste0( ExportName,
            families[a], "_",
            outcomes[[a]],
            "_Model_",
            b,
            "_"
    ) -> BasePlotName ;
    
    # Do job selecting modeling family
    if ( families[a] == "gaussian" )
    {
      Lm.Analysis(  outcome = outcomes[[a]],
                    predictors = c( changing.predictors[[b]],
                                    fixed.predictors ),
                    data = data, 
                    na.omit = na.omit,
                    FULL = FULL, 
                    selected.predictors = changing.predictors[[b]],
                    ANOVA = ANOVA.ANODE ) -> 
        tmp.output
      
      if ( PLOT )
      {
        Lm.Plot( tmp.output$model,
                 BasePlotName )
      }
    }
    
    if ( families[a] %in%  c( "binomial", "poisson", "quasibinomial", "quasipoisson" ) )
    {
      Glm.Analysis(  outcome = outcomes[[a]],
                     predictors = c( changing.predictors[[b]],
                                     fixed.predictors ),
                     family = families[a],
                     data = data, 
                     na.omit = na.omit,
                     FULL = FULL, 
                     selected.predictors = changing.predictors[[b]],
                     ANODE = ANOVA.ANODE ) -> 
        tmp.output
      
      if ( PLOT )
      {
        Glm.Plot( tmp.output$model,
                  BasePlotName )
      }
    }
    
    if ( families[a] == "multinomial" )
    {
      Multinom.Analysis(  outcome = outcomes[[a]],
                          predictors = c( changing.predictors[[b]],
                                          fixed.predictors ),
                          data = data, 
                          HMF.test = HMF.test,
                          na.omit = na.omit,
                          FULL = FULL, 
                          selected.predictors = changing.predictors[[b]],
                          ANODE = ANOVA.ANODE ) -> 
        tmp.output
      
      if ( PLOT )
      {
        Multinom.Plot( tmp.output$model,
                       data = data,
                       BasePlotName )
      }
    }
    
    if ( families[a] == "ordinal" )
    {
      Ordinal.Analysis(  outcome = outcomes[[a]],
                         predictors = c( changing.predictors[[b]],
                                         fixed.predictors ),
                         data = data, 
                         na.omit = na.omit,
                         FULL = FULL, 
                         selected.predictors = changing.predictors[[b]],
                         ANODE = ANOVA.ANODE ) -> 
        tmp.output
      
      if ( PLOT )
      {
        Ordinal.Plot( tmp.output$model,
                      BasePlotName )
      }
    }
    
    # output
    tmp.output$results.tab -> output.b ;
    
    cbind( Outcome = outcomes[[a]], 
           Families = families[a],
           Predictors = String.Contatener( c( changing.predictors[[b]],
                                              fixed.predictors),
                                           separator = "." ),
           output.b ) -> 
      output.b ;
    
    return( output.b )
  }
  
  # Active Packages 
  download.packages( "furrr", "nnet", "MASS", "ordinal",
                     "MuMIn", "car", 
                     "heplots", "lmtest", "mfp", 
                     "moments", "nortest", "dplyr", "tidyr", "magrittr",
                     "ggplot2", "mlogit", "dfidx", "brant", "VisCollin",
                     "mctest", "ggplot2" )
  
  require( ggplot2 )
  
  # NA
  if ( na.omit == TRUE ) { na.omit( data ) -> data } 
  
  # job
  if ( parallel.outcomes )
  {
    furrr::future_map(
      1:length( outcomes  ), 
      fun.a,
      .options = furrr::furrr_options(seed = TRUE), .progress = T 
    ) |>
      rbind.force( 
        empty = "" ) -> 
      output ;
  }
  else
  {
    purrr::map(
      1:length( outcomes  ), 
      fun.a.parallel
    ) |>
      rbind.force( 
        empty = "" ) -> 
      output ;
  }
  
  # end parallel
  future::plan("sequential")
  
  # Output 
  return( output )
}


Multiple.Regressions.weighted <- function(
    data,
    weights,
    outcomes,
    families,
    changing.predictors,
    fixed.predictors = "",
    FULL = TRUE,
    ANOVA.ANODE = TRUE,
    HMF.test = TRUE,
    conf.level = 0.95,
    pvalue.round = 3,
    round = 2,
    PLOT = FALSE,
    ExportName = paste( getwd(),
                        "/",
                        sep = ""),
    parallel.outcomes = TRUE,
    ncores = NULL
)
{
  
  # input quality controls
  if ( !is.data.frame( data ) ) { stop ( "data is not of dataframe type" ) } ;
  if ( any( is.na( data ) ) ) { stop( "data countains NA" ) } ;
  if ( tibble::is_tibble( data ) ) { data.frame( data ) -> data ; }
  if ( !is.numeric( weights ) ) { stop( "weights is not numeric" ) } ;
  if ( length( weights ) != nrow( data ) ) { stop( "weights is not of the same length as data" ) } ;
  if ( !is.list( outcomes ) ) { stop( "outcomes is not a list" ) } ;
  if ( !is.character( unlist( outcomes ) ) ) { stop( "outcomes doesn't countain character" ) } ;
  if ( !is.character( families ) ) { stop( "families is not a vector of character type" ) } ;
  if ( !all( families %in% c( "multinomial", "ordinal", "gaussian", "binomial", "poisson", "quasibinomial", "quasipoisson" ) ) )
  { stop( "families contains a non supported distribution" ) } ;
  if ( !is.list( changing.predictors ) ) { stop( "changing.predictors is not a list" ) } ;
  if ( !is.character( unlist( changing.predictors ) ) ) { stop( "changing.predictors doesn't countain character" ) } ;
  if ( !is.character( fixed.predictors ) ) { stop( "fixed.predictors is not a vector of character type" ) } ;
  if ( !is.logical( FULL ) ) { stop( "FULL is not a logical" ) } ;
  if ( !is.logical( ANOVA.ANODE ) ) { stop( "ANOVA.ANODE is not a logical" ) } ;
  if ( !is.logical( HMF.test ) ) { stop( "HMF.test is not a logical" ) } ;
  if ( !is.numeric( conf.level ) ) { stop( "conf.level is not numeric" ) } ;
  if ( !( is.numeric( pvalue.round ) |
          is.null( pvalue.round ) ) ) { stop( "pvalue.round is neither numeric, neither NULL" );    } ;
  if ( !( is.numeric( round ) |
          is.null( round ) ) ) { stop( "round is neither numeric, neither NULL" );    } ;
  if ( !is.logical( PLOT ) ) { stop( "PLOT is not a logical" ) } ;
  if ( !is.character( ExportName ) ) { stop( "ExportName is not a vector of character type" ) } ;
  if ( !is.logical( parallel.outcomes ) ) { stop( "parallel.outcomes is not a logical" ) } ;
  if ( !is.null(ncores) & !is.numeric(ncores) ) { stop( "ncores is not null nor numeric" ) }
  
  # parallel
  if ( !is.null( ncores ) ) { future::plan( "multisession",  workers = ncores ) }
  
  # Domestic functions
  download.packages <- function( PackagesNames, ... )
  {
    # Get a vector with packages names 
    packages1 <- c( PackagesNames, ... ) ;
    
    # Install packages
    for (a in 1:length( packages1 ) )
    {
      try( find.package( packages1[a]), silent = TRUE ) -> test ;
      
      if ( class( test ) == "try-error" )
      { print( packages1[a] ) ; 
        install.packages(  packages1[a] ) ;
      } 
    }
  } ;
  
  rbind.force <- function( data, ..., keep.col = FALSE, empty = NA )
  {
    # Unify data
    list( data, ... ) -> input ;
    
    # include list elements
    repeat
    {
      if (  !any( unlist( lapply( input, class ) ) == "list" ) ) { break }
      
      which( unlist( lapply( input, class ) ) == "list" )[1] -> a ;
      input[[a]] -> tmp ;
      input[[a]] <- NA ;
      c( input[1:a],  tmp, input[ (a + 1):length( input ) ] ) ->
        input ;
    }
    
    input[ !is.na( input ) ] ->
      input ;
    
    # delete NULL data and transformt vector in data.frame
    for ( a in 1:length( input ) )
    {
      if ( is.null( dim( input[[a]] ) ) )
      {
        if ( is.null( input[[a]] ) )
        {
          input[[a]] <- NA ;
        } else
        {
          data.frame( matrix( input[[a]], nrow = 1 ),
                      stringsAsFactors = FALSE ) -> input[[a]] ;
        }
      }
      
      if ( all( dim( input[[a]] ) == 0 ) )
      {
        input[[a]] <- NA ;
      }
    }
    
    input[ !is.na( input ) ] ->
      input ;
    
    # test data class
    if ( !all( unlist( lapply( input, is.data.frame ) ) |
               unlist( lapply( input, is.matrix ) ) |
               unlist( lapply( input, is.vector ) ) ) )
    { stop( "Some argument are not data.frame, neither vector" ) ;
      ; } ;
    
    # Set primer
    input[[1]] -> output ;
    
    # job in case we keep columns
    if ( keep.col & length( input ) >1 )
    {
      for ( a in 2:length( input ) )
      {
        output -> x ;
        input[[a]] -> y ;
        
        for (a in 1:dim(x)[2]) { x[,a] <- as.character(x[,a])}
        for (a in 1:dim(y)[2]) { y[,a] <- as.character(y[,a])}
        
        x.diff <- setdiff(colnames(x), colnames(y))
        y.diff <- setdiff(colnames(y), colnames(x))
        
        if( dim(x)[1] > 0 ) { x[, c(as.character(y.diff))] <- empty ; }
        if( dim(y)[1] > 0 ) { y[, c(as.character(x.diff))] <- empty ; }
        
        rbind(x, y) -> output ;
      }
    }
    
    # job in case we do not keep columns
    if ( !keep.col & length( input ) >1 )
    {
      for ( a in 2:length( input ) )
      {
        output -> x ;
        input[[a]] -> y ;
        
        colnames(x) <- paste( "X",
                              1:dim( x )[2],
                              sep = "" ) ;
        colnames(y) <- paste( "X",
                              1:dim( y )[2],
                              sep = "" ) ;
        
        for (a in 1:dim(x)[2]) { x[,a] <- as.character(x[,a])}
        for (a in 1:dim(y)[2]) { y[,a] <- as.character(y[,a])}
        
        x.diff <- setdiff(colnames(x), colnames(y))
        y.diff <- setdiff(colnames(y), colnames(x))
        
        if( dim(x)[1] > 0 ) { x[, c(as.character(y.diff))] <- empty ; }
        if( dim(y)[1] > 0 ) { y[, c(as.character(x.diff))] <- empty ; }
        
        rbind(x, y) -> output ;
      }
    }
    
    return( output ) ;
  }
  
  cbind.force <- function( data, ... , keep.row = FALSE, empty = NA )
  {
    # Unify data
    list( data, ... ) -> input ;
    
    # include list elements
    repeat
    {
      if (  !any( unlist( lapply( input, class ) ) == "list" ) ) { break }
      
      which( unlist( lapply( input, class ) ) == "list" )[1] -> a ;
      input[[a]] -> tmp ;
      input[[a]] <- NA ;
      c( input[1:a],  tmp, input[ (a + 1):length( input ) ] ) ->
        input ;
    }
    
    input[ !is.na( input ) ] ->
      input ;
    
    # delete NULL data and transform vector in data.frame
    for ( a in 1:length( input ) )
    {
      if ( is.null( dim( input[[a]] ) ) )
      {
        if ( is.null( input[[a]] ) )
        {
          input[[a]] <- NA ;
        } else
        {
          data.frame( input[[a]],
                      stringsAsFactors = FALSE ) -> input[[a]] ;
          "vector" -> colnames(  input[[a]] ) ;
        }
      }
      
      if ( all( dim( input[[a]] ) == 0 ) )
      {
        input[[a]] <- NA ;
      }
    }
    
    input[ !is.na( input ) ] ->
      input ;
    
    # test data class
    if ( !all( unlist( lapply( input, is.data.frame ) ) |
               unlist( lapply( input, is.matrix ) ) |
               unlist( lapply( input, is.vector ) ) ) )
    { stop( "Some argument are not data.frame, neither vector" ) ;
      ; } ;
    
    # Set primer
    input[[1]] -> output ;
    
    # job in case we keep columns
    if ( keep.row & length( input ) > 1 )
    {
      for ( a in 2:length( input ) )
      {
        output -> x ;
        input[[a]] -> y ;
        
        for (a in 1:dim(x)[2]) { x[,a] <- as.character(x[,a])}
        for (a in 1:dim(y)[2]) { y[,a] <- as.character(y[,a])}
        
        x.diff <- setdiff(rownames(x), rownames(y))
        y.diff <- setdiff(rownames(y), rownames(x))
        
        if( dim(x)[2] > 0 ) { x[ c(as.character(y.diff)), ] <- empty ; }
        if( dim(y)[2] > 0 ) { y[ c(as.character(x.diff)), ] <- empty ; }
        
        cbind(x, y) -> output ;
      }
    }
    
    # job in case we do not keep columns
    if ( !keep.row & length( input ) > 1 )
    {
      for ( a in 2:length( input ) )
      {
        output -> x ;
        input[[a]] -> y ;
        
        if ( dim( x )[1] > 0 )
        {
          rownames(x) <- paste( "X",
                                1:dim( x )[1],
                                sep = "" ) ;
        }
        
        if ( dim( y )[1] > 0 )
        {
          rownames(y) <- paste( "X",
                                1:dim( y )[1],
                                sep = "" ) ;
        }
        
        
        
        for (a in 1:dim(x)[2]) { x[,a] <- as.character(x[,a])}
        for (a in 1:dim(y)[2]) { y[,a] <- as.character(y[,a])}
        
        x.diff <- setdiff(rownames(x), rownames(y))
        y.diff <- setdiff(rownames(y), rownames(x))
        
        if( dim(x)[2] > 0 ) { x[ c(as.character(y.diff)), ] <- empty ; }
        if( dim(y)[2] > 0 ) { y[ c(as.character(x.diff)), ] <- empty ; }
        
        cbind(x, y) -> output ;
      }
    }
    
    return( output ) ;
  } ;
  
  String.Contatener <- function( vector, separator )
  {
    # exclude NA
    na.omit( vector ) -> vector ;
    
    # selection of length for loop
    if ( length( vector ) >= 2)
    {
      # stock fisrt element
      tmp.val1 <- vector[1] ;
      
      # loop to concatenate the nect elements
      for ( a in 2:length( vector ) )
      {
        tmp.val1 <- paste( tmp.val1, vector[a], sep = separator ) ;
      } ;
    }
    else
    {
      tmp.val1 <- vector ;
    } ;
    
    return( tmp.val1 ) ;
  } ;
  
  p.round <- function( data, digits = 3 )
  {
    if (digits == 1)
    { "" -> tmp1 ; } else
    { rep( "0", digits - 1 ) -> tmp1 ; }
    
    "0." -> tmp2 ;
    for( a in 1:length(tmp1) )
    {
      paste( tmp2, tmp1[a], sep = "" ) -> tmp2 ;
    }
    
    paste( tmp2, "1", sep = "" ) -> pval ;
    
    for ( a in 1:length(data) )
    {
      if ( !is.na( data[a] ) )
      {
        if ( data[a] >= as.numeric( pval ) )
        {
          round( data[a], digits = digits ) -> data[a] ;
        }
      }
    }
    
    data[ data < as.numeric( pval ) ] <- paste( "< ", pval, sep = "" ) ;
    
    return( data ) ;
  }
  
  IFELSE <- function( condition, true, false )
  {
    if (condition)
    {
      return( true )
    } else
    {
      return( false )
    }
  }
  
  cohen.f2 <- function( model, pseudo.R2 = FALSE, family )
  {
    attr(terms(model), 'term.labels') -> terms1 ;
    as.character( terms(model) )[2] -> outcome ;
    
    NULL -> f2 ;
    
    if ( !pseudo.R2 )
    {
      for ( a in 1:length(terms1) )
      {
        if ( length(terms1) == 1 )
        {
          stats::update( model, reformulate( "1" ) ) -> model.bis ;
        } else
        {
          stats::update( model, reformulate( terms1[-a] ) ) -> model.bis ;
        }
        
        c( f2,
           (summary( model )$r.squared -  summary( model.bis  )$r.squared ) / (1 - summary( model )$r.squared) ) ->
          f2 ;
      }
    }
    
    if ( pseudo.R2 & any( class( model ) == "glm" ) )
    {
      
      for ( a in 1:length(terms1) )
      {
        if ( length(terms1) == 1 )
        {
          stats::update( model, reformulate( "1", outcome ), family = family )-> model.bis ;
        } else
        {
          stats::update( model, reformulate( terms1[-a], outcome ), family = family ) -> model.bis ;
        }
        
        c( f2,
           (MuMIn::r.squaredLR( model, stats::update( model, reformulate( "1", outcome ), family = family  ) )[1] -  MuMIn::r.squaredLR( model.bis, stats::update( model, reformulate( "1" ), family = family ) )[1]  ) / (1 -  MuMIn::r.squaredLR( model, stats::update( model, reformulate( "1", outcome ), family = family ) )[1] )  ) ->
          f2 ;
      }
    }
    
    if ( pseudo.R2 & all( class( model ) != "glm" ) )
    {
      
      for ( a in 1:length(terms1) )
      {
        if ( length(terms1) == 1 )
        {
          stats::update( model, reformulate( "1", outcome ) )-> model.bis ;
        } else
        {
          stats::update( model, reformulate( terms1[-a], outcome ) ) -> model.bis ;
        }
        
        c( f2,
           (MuMIn::r.squaredLR( model, stats::update( model, reformulate( "1", outcome )  ) )[1] -  MuMIn::r.squaredLR( model.bis, stats::update( model, reformulate( "1" ) ) )[1]  ) / (1 -  MuMIn::r.squaredLR( model, stats::update( model, reformulate( "1", outcome ) ) )[1] )  ) ->
          f2 ;
      }
    }
    
    terms1 -> names( f2 ) ;
    
    return( f2 )
  }
  
  Systematic.FP <- function( output, predictors, family, data, na.omit )
  {
    if( any( grepl( ":", predictors ) ) )
    {
      predictors[ !grepl( ":", predictors ) ] -> predictors ; 
    }
    
    require( mfp )
    
    data |>
      subset( select = predictors ) |>
      dplyr::select_if( is.numeric ) |>
      colnames() ->
      pred.num ;
    
    c( "Predictors", "df.initial", "select", "alpha",
       "df.final", "power1", "power2" ) ->
      return1 ;
    for ( a in pred.num )
    {
      paste( "fp(",
             a,
             ",df = 4, select = 1, scale = TRUE)") ->
        fp ;
      
      if ( na.omit == TRUE ) { na.omit( data ) -> data }
      
      reformulate( c(fp, predictors[ which( predictors != a) ] ), output ) |>
        mfp::mfp( 
          family = family,
          data = data ) ->
        tmp.mfp ;
      
      tmp.mfp$fptable[a,] |>
        as.matrix() |>
        (function(x) c( a, x) )() |>
        (function(x) rbind( return1, x ) )() ->
        return1 ;
    }
    
    NULL -> rownames(return1) ;
    
    return( return1 )
  }
  
  residuals.polr <- function( model )
  {
    factor( model$model[,1] ) -> multinom.var ;
    
    NULL -> disjonctif.table ;
    
    for ( a in 1:nlevels( multinom.var ) )
    {
      as.character( multinom.var ) -> tmp.var ;
      
      paste( levels(multinom.var)[a], "a", sep = "" ) ->
        tmp.var[ tmp.var == levels(multinom.var)[a] ] ;
      0 -> tmp.var[ tmp.var != paste( levels(multinom.var)[a], "a", sep = "" ) ] ;
      1 -> tmp.var[ tmp.var == paste( levels(multinom.var)[a], "a", sep = "" ) ] ;
      cbind( disjonctif.table,
             as.numeric( as.character( tmp.var ) ) ) ->
        disjonctif.table ;
      
      levels(multinom.var)[a] ->
        colnames( disjonctif.table )[ ncol( disjonctif.table ) ] ;
    }
    
    disjonctif.table - model$fitted.values -> output ;
    
    return( output )
  }
  
  Normality.Plot.Unique <- function( vector, name )
  {
    par( mfrow = c( 2, 2), oma = c( 0, 0, 2, 0) )
    
    # Clean missing value
    na.omit( vector ) -> vector ;
    as.numeric( vector ) -> vector ;
    
    # plot histogram
    hist( vector, main = "Histogram", xlab = "Variable", col = "blue" ) ;
    round( moments::kurtosis( vector ), digits = 2 ) -> tmp.val1 ;
    round( moments::skewness( vector ), digits = 2 ) -> tmp.val2 ;
    paste( "Kurtosis: ", tmp.val1, " ; ", "Skewness: ", tmp.val2, sep = "" ) -> tmp.name1 ;
    title( sub = tmp.name1 ) ;
    
    # plot density
    plot( density( vector ),
          main = "Density plot", xlab = "Variable", col = "blue" ) ;
    curve( dnorm( x, mean( vector ), sd( vector ) ), add = TRUE, col = "red", lwd = 2, lty = 2 ) ;
    abline( v = mean( vector ), col = "blue", lwd = 2, lty = 2) ;
    abs( range( vector )[2] - range( vector )[1] ) / 20 -> legend.distance1 ;
    abs( range( density( vector )$y )[2] - range( density( vector )$y )[1] ) / 20 -> legend.distance2 ;
    text( x = mean( vector ) + legend.distance1, y = legend.distance2, expression( mu ), col = "blue" ) ;
    legend( x = "topright", lty = c( 1, 2 ), col = c( "blue", "red" ), c( "Sample", "Normal" ), cex = 0.6 ) ;
    round( moments::jarque.test( vector )$p.value, digits = 3 ) -> tmp.val1 ;
    if ( tmp.val1 < 0.001 ) { tmp.val1 <- "< 0.001"} ;
    paste( "Jarque-Bera test p value: ", tmp.val1 ) -> tmp.name1 ;
    if ( tmp.val1 == "< 0.001" | tmp.val1 < 0.05 )
    { title( sub = tmp.name1, col.sub = "green", font.sub = 2 ) ; }
    else
    { title( sub = tmp.name1 ) ; } ;
    
    # plot ecdf
    plot( ecdf( vector ), main = "Empirical cumulative distribution plot", xlab = "Variable",
          ylab = "Density", col = "blue", ylim = c( -0.2, 1.2 ) )
    plot( add = TRUE, ecdf( rnorm( 10000, mean = mean( vector ), sd = sd( vector ) ) ), col = "red" ) ;
    abline( h = 0.5, lty = 2, lwd = 1, col = "grey80" )
    legend( x = "bottomright", lty = c( 1, 1 ),col = c( "blue", "red" ), c( "Sample", "Normal" ), cex = 0.6 ) ;
    round( nortest::ad.test( vector )$p.value, digits = 3 ) -> tmp.val1 ;
    if ( tmp.val1 < 0.001 ) { tmp.val1 <- "< 0.001"} ;
    paste( "Anderson-Darling test p value: ", tmp.val1, sep = "" ) -> tmp.name1 ;
    if ( tmp.val1 == "< 0.001" | tmp.val1 < 0.05 )
    { title( sub = tmp.name1, col.sub = "green", font.sub = 2 ) ; }
    else
    { title( sub = tmp.name1 ) ; } ;
    
    # plot qq
    qqnorm( vector, col = "blue" ) ;
    qqline( vector, col = "red" ) ;
    legend( x = "bottomright", lty = c( 1 ),col = c( "red" ), c( "Henry's line" ), cex = 0.6 ) ;
    if ( length( vector ) > 5000 )
    {
      "Shapiro-Wilk test not performed (N > 5000 )" -> tmp.name1 ;
      title( sub = tmp.name1 ) ;
    } else
    {
      round( shapiro.test( vector )$p.value, digits = 3 ) -> tmp.val1 ;
      if ( tmp.val1 < 0.001 ) { tmp.val1 <- "< 0.001"} ;
      paste( "Shapiro-Wilk test p value: ", tmp.val1, sep = "" ) -> tmp.name1 ;
      if ( tmp.val1 == "< 0.001" | tmp.val1 < 0.05 )
      { title( sub = tmp.name1, col.sub = "green", font.sub = 2 ) ; }
      else
      { title( sub = tmp.name1 ) ; } ;
    }
    
    # put title
    tmp.name2 <- paste( "Noramlity Study of", name, sep = " " ) ;
    mtext( text =  tmp.name2, outer = TRUE, cex = 1.5 ) ;
  }
  
  Formula.Maker <- function( outcome, fixed.effects = "", interactions = "", random.effects = "",
                             random.interactions = list(""), covariance = TRUE, DeleteTerms = NULL )
  {
    # Cheking inuts
    if ( !all( random.interactions == "" ) )
    {
      if ( length(random.interactions) != length(random.effects) )
      { print( "Missing random interactions arguments" ) ;}
    } ;
    
    # Integration of fixed effects
    if ( !all( fixed.effects == "" ) )
    {
      if ( length( which(fixed.effects == "" ) ) > 0 )
      {
        fixed.effects[-which(fixed.effects == "")] -> Predictors ;
      }
      else
      {
        fixed.effects  -> Predictors ;
      }
    }
    else
    { "1" -> Predictors } ;
    
    # Integration of interactions
    if ( all( interactions != "" ) )
    {
      for ( a in 1:length( interactions ) )
      {
        paste( interactions[[a]][1], ":", interactions[[a]][2], sep = "" ) -> tmp.val1
        c( Predictors, tmp.val1 ) -> Predictors ;
      } ;
    } ;
    
    # Integration of random effects
    if ( all( random.effects != "" ) )
    {
      for ( a in 1:length( random.effects) )
      {
        if ( all( random.interactions == "" ) )
        {
          paste( "(1 | ", random.effects[a], ")", sep = "" ) -> tmp.val1 ;
          c( Predictors, tmp.val1 ) -> Predictors ;
        } ;
      } ;
    } ;
    
    # Integration of random interactions
    if ( any( random.interactions != "" ) )
    {
      if ( covariance )
      {
        for ( a in 1:length(random.effects) )
        {
          if ( all( random.interactions[[a]] != "1" ) )
          {
            "(1" -> tmp.val1 ;
            for ( b in 1:length( random.interactions[[a]] ) )
            {
              if ( random.interactions[[a]][b] != "" )
              {
                paste( tmp.val1, " + ", random.interactions[[a]][b], sep = "" ) -> tmp.val1 ;
              } ;
            } ;
            paste( tmp.val1, " | ", random.effects[a], ")", sep = "" ) -> tmp.val2 ;
            c( Predictors, tmp.val2 ) -> Predictors ;
          }
          if ( all( random.interactions[[a]] == "1" ) )
          {
            paste( "(1", " | ", random.effects[a], ")", sep = "" ) -> tmp.val2 ;
            c( Predictors, tmp.val2 ) -> Predictors ;
          } ;
        } ;
      } ;
      
      if ( !covariance )
      {
        for ( a in 1:length( random.effects) )
        {
          paste( "(1 | ", random.effects[a], ")", sep = "" ) -> tmp.val1 ;
          c( Predictors, tmp.val1 ) -> Predictors ;
          for ( b in 1:length(random.interactions[[a]]) )
          {
            if ( random.interactions[[a]][b] != "" )
            {
              paste( "(", random.interactions[[a]][b], " || ", random.effects[a], ")", sep = "" ) -> tmp.val1 ;
              c( Predictors, tmp.val1 ) -> Predictors ;
            } ;
          } ;
        } ;
      } ;
    } ;
    
    # Deletion of terms
    if ( all( !is.null( DeleteTerms ) ) )
    {
      if ( class(DeleteTerms) == "numeric" )
      {
        Predictors[ -DeleteTerms ] -> Predictors ;
      } ;
      if ( class(DeleteTerms) == "character" )
      {
        Predictors[ !( Predictors %in% DeleteTerms ) ] -> Predictors ;
      } ;
    } ;
    
    # Generation of formula
    reformulate( Predictors, outcome ) -> Formula ;
    
    return( Formula ) ;
  } ;
  
  hmftest.systematic <- function( formula2 , data, weights )
  {
    formula2 |>
      as.character() ->
      formula2.ch ;
    
    if ( grepl( ":", formula2.ch[3]) )
    {
      return( "No hmf test for models with interactions" )
    }
    
    formula2 |>
      as.character() ->
      formula2.ch ;
    
    reformulate( paste0( "0 | ", formula2.ch[3]), formula2.ch[2] ) ->
      formula2.new  ;
    
    dfidx::dfidx( cbind( data, weights = weights), shape = "wide", choice = formula2.ch[2] ) ->
      data.new ;
    
    mlogit::mlogit( formula2.new,
                    data = data.new,
                    weights = data$weights
    ) -> model.new ;
    
    c( "var", "Chisq", "df", "p-value" ) -> output ;
    
    for (a in 2:nlevels( data[, formula2.ch[2] ] ) )
    {
      mlogit::mlogit( formula2.new,
                      data = data.new,
                      weights = data$weights,
                      alt.subset = levels( data[, formula2.ch[2] ] )[-a]
      ) -> model.alt ;
      
      try( mlogit::hmftest( model.new, model.alt ) ) ->
        tmp ;
      
      if (attr( tmp,"class") == "try-error" )
      {
        "" -> output ; 
      } else
      {
        rbind( output, 
               c( levels( data[, formula2.ch[2] ] )[a], 
                  IFELSE( is.null( round ), 
                          tmp$statistic,
                          round( tmp$statistic, round ) ) ,
                  tmp$parameter,
                  IFELSE( is.null( pvalue.round ), 
                          tmp$p.value, p.round( tmp$p.value, pvalue.round ) ) )
        ) -> 
          output ;
      }
    }
    
    return( output )
  }
  
  Multinomial.SubsetLevels <- function( formula2 , data, weights, round )
  {
    formula2 |>
      as.character() ->
      formula2.ch ;
    
    data$weights <- weights
    nnet::multinom( reformulate(as.character(formula2)[3],
                                as.character(formula2)[2] ),
                    data = data,
                    Hess = TRUE,
                    weights = data$weights ) -> m1
    
    cbind( paste0( rownames(summary(m1)$coefficients),
                   ": Base model" ),
           IFELSE( !is.null(round),
                   round( summary(m1)$coefficients,
                          round ),
                   summary(m1)$coefficients )
    ) -> output
    
    if ( nlevels( data[, formula2.ch[2] ] ) > 3 )
    {
      rbind.force( output,
                   rbind.force( lapply( 2:nlevels( data[, formula2.ch[2] ] ),
                                        FUN = function(a)
                                        {
                                          data[ data[, formula2.ch[2] ] !=
                                                  levels( data[, formula2.ch[2] ] )[a],] ->
                                            data2
                                          
                                          factor( data2[, formula2.ch[2] ] ) ->
                                            data2[, formula2.ch[2] ]
                                          
                                          nnet::multinom( reformulate(as.character(formula2)[3],
                                                                      as.character(formula2)[2] ),
                                                          data = data2,
                                                          Hess = TRUE,
                                                          weights = data2$weights ) -> m1
                                          
                                          cbind( paste0( rownames(summary(m1)$coefficients),
                                                         ": -",
                                                         levels( data[, formula2.ch[2] ] )[a] ,
                                                         " model" ),
                                                 IFELSE( !is.null(round),
                                                         round( summary(m1)$coefficients,
                                                                round ),
                                                         summary(m1)$coefficients )
                                          )
                                        }) ), empty = "" ) ->
        output ;
    } else
    {
      rbind.force( output,
                   rind.force( lapply( 2:nlevels( data[, formula2.ch[2] ] ),
                                       FUN = function(a)
                                       {
                                         data[ data[, formula2.ch[2] ] !=
                                                 levels( data[, formula2.ch[2] ] )[a],] ->
                                           data2
                                         
                                         factor( data2[, formula2.ch[2] ] ) ->
                                           data2[, formula2.ch[2] ]
                                         
                                         nnet::multinom( reformulate(as.character(formula2)[3],
                                                                     as.character(formula2)[2] ),
                                                         data = data2,
                                                         Hess = TRUE,
                                                         weights = data2$weights ) -> m1
                                         
                                         c( paste0( levels( factor( data2[, formula2.ch[2] ] ) )[2],
                                                    ": -",
                                                    levels( data[, formula2.ch[2] ] )[a] ,
                                                    " model" ),
                                            IFELSE( !is.null(round),
                                                    round( summary(m1)$coefficients,
                                                           round ),
                                                    summary(m1)$coefficients )
                                         )
                                       }) ), empty = "" ) ->
        output ;
    }
    
    output |>
      data.frame() |>
      dplyr::arrange( X1 ) |>
      t() |>
      (function(x) cbind( c( "Outcome levels ->", m1$coefnames ),
                          x ) )() -> output
    
    return( data.frame(output) )
  }
  
  nominal_test.perso <- function( model, formula1, data.clm, weights )
  {
    lapply( attr( terms( model ),"term.labels"),
            function(a)
            {
              ordinal::clm(  formula1,
                             nominal = reformulate( a ),
                             weights = weights,
                             data = data.clm ) |>
                (function(x) anova( model, x ) )() |>
                data.frame() -> tmp ;
              cbind( Predictors = a, tmp[2,-1] )
            }) |>
      dplyr::bind_rows()
  }
  
  pairs2 <- function( y, X, ExportName, n )
  {
    data.frame(y) |>
      lapply(as.numeric) |>
      data.frame() -> y
    data.frame(X) |>
      lapply(as.numeric) |>
      data.frame() -> X
    
    (ncol(X) / n) |> trunc() -> npairs
    (ncol(X) %% n) -> addpairs
    
    if ( npairs != 0 )
    {
      for (a in 0:(npairs - 1) )
      {
        png( paste( ExportName,
                    "Pair_Graphics",
                    "_", a +1,
                    ".png",
                    sep = "" ) )
        y |>
          cbind(X[, (1 + n * a):(
            n * (a + 1) ) ]) |>
          pairs( cex.labels = 0.8, main = paste( "Pairs graphic", a + 1 ) )
        dev.off() ;
      }
    }
    
    if ( addpairs != 0 )
    {
      png( paste( ExportName,
                  "Pair_Graphics",
                  "_", (npairs + 1),
                  ".png",
                  sep = "" ) )
      y|>
        cbind( subset( X, select = (1 + n * npairs):ncol(X) ) ) |>
        pairs( cex.labels = 0.8, main = paste( "Pairs graphic", npairs + 1 ) )
      dev.off() ;
    }
  }
  
  termplot2.w <- function( model, ExportName )
  {
    ( (ncol( model$model  ) - 2) / 9) |> trunc() -> n ;
    ( (ncol( model$model  ) - 2) %% 9) -> o ;
    
    if ( n != 0 )
    {
      for (a in 1:n )
      {
        png( paste( ExportName,
                    "RegressionsTerms_vs_Predictors_",
                    a,
                    ".png",
                    sep = "" ) )
        layout( matrix( 1:9, ncol=3, byrow=T ) )
        par( oma = c( 0, 0, 2, 0) )
        termplot( model,
                  terms = attr( terms( model ),"term.labels")[((a - 1) * 9 + 1):(a  * 9)],
                  ask = FALSE,
                  partial.resid = TRUE,
                  se = TRUE,
                  smooth = panel.smooth )
        mtext( text =  paste( "Regression terms vs Predictors", a ),
               outer = TRUE, cex = 1.5 ) ;
        dev.off() ;
      }
    }
    
    if ( o != 0 )
    {
      png( paste( ExportName,
                  "RegressionsTerms_vs_Predictors_",
                  n + 1,
                  ".png",
                  sep = "" ) )
      layout( matrix( 1:9, ncol=3, byrow=T ) )
      par( oma = c( 0, 0, 2, 0) )
      termplot( model,
                terms = attr( terms( model ),"term.labels")[(n * 9 + 1):(n * 9 + o)],
                ask = FALSE,
                partial.resid = TRUE,
                se = TRUE,
                smooth = panel.smooth )
      mtext( text =  paste( "Regression terms vs Predictors", n + 1),
             outer = TRUE, cex = 1.5 ) ;
      dev.off() ;
    }
    
  } ;
  
  residualPlots2.w <- function( model, ExportName )
  {
    ( (ncol( model$model  ) - 2) / 9) |> trunc() -> n ;
    ( (ncol( model$model  ) - 2) %% 9) -> o ;
    
    if ( n != 0 )
    {
      for (a in 1:n )
      {
        png( paste( ExportName,
                    "Pearson_Residuals_vs_Independant_Vars",
                    a,
                    ".png",
                    sep = "" ) )
        layout( matrix( 1:9, ncol=3, byrow=T ) )
        par( oma = c( 0, 0, 2, 0) )
        car::residualPlot( model,
                           terms = reformulate( attr( terms( model ),"term.labels")[((a - 1) * 9 + 1):(a  * 9)] ),
                           tests = FALSE,
                           fitted = FALSE,
                           ask = FALSE,
                           type = "rstandard" )
        mtext( text =  paste( "Pearson Residuals vs Independant Vars", a),
               outer = TRUE, cex = 1.5 ) ;
        dev.off() ;
      }
    }
    
    if ( o != 0 )
    {
      png( paste( ExportName,
                  "Pearson_Residuals_vs_Independant_Vars",
                  n + 1,
                  ".png",
                  sep = "" ) )
      layout( matrix( 1:9, ncol=3, byrow=T ) )
      par( oma = c( 0, 0, 2, 0) )
      car::residualPlot( model,
                         terms = reformulate( attr( terms( model ),"term.labels")[(n * 9 + 1):(n * 9 + o)] ),
                         tests = FALSE,
                         fitted = FALSE,
                         ask = FALSE,
                         type = "rstandard" )
      mtext( text =  paste( "Pearson Residuals vs Independant Vars", n + 1),
             outer = TRUE, cex = 1.5 ) ;
      dev.off() ;
    }
  }
  
  avPlots2.w <- function( model, ExportName )
  {
    ( (length( names(model$coefficients) ) - 2) / 9) |> trunc() -> n ;
    ( (length( names(model$coefficients)  ) - 2) %% 9) -> o ;
    
    if ( n != 0 )
    {
      for (a in 1:n )
      {
        png( paste( ExportName,
                    "Added-Variable_Plots",
                    a,
                    ".png",
                    sep = "" ) )
        layout( matrix( 1:9, ncol=3, byrow=T ) )
        par( oma = c( 0, 0, 2, 0) )
        for (b in names(model$coefficients)[-1][((a - 1) * 9 + 1):(a  * 9)])
        {
          car::avPlot( model,
                       variable =  b
          ) ;
        }
        mtext( text =  paste( "Added-Variable Plots", a ),
               outer = TRUE, cex = 1.5 ) ;
        dev.off() ;
      }
    }
    
    if ( o != 0 )
    {
      png( paste( ExportName,
                  "Added-Variable_Plots",
                  n + 1,
                  ".png",
                  sep = "" ) )
      layout( matrix( 1:9, ncol=3, byrow=T ) )
      par( oma = c( 0, 0, 2, 0) )
      for (b in names(model$coefficients)[-1][(n * 9 + 1):(n * 9 + o)])
      {
        car::avPlot( model,
                     variable =  b
        ) ;
      }
      mtext( text =  paste( "Added-Variable Plots", n + 1 ),
             outer = TRUE, cex = 1.5 ) ;
      dev.off() ;
    }
  }
  
  crPlots2.w <- function( model, ExportName )
  {
    ( (ncol( model$model  ) - 2) / 9) |> trunc() -> n ;
    ( (ncol( model$model  ) - 2) %% 9) -> o ;
    
    if ( n != 0 )
    {
      for (a in 1:n )
      {
        png( paste( ExportName,
                    "Component-Residuals_Plots",
                    a,
                    ".png",
                    sep = "" ) )
        layout( matrix( 1:9, ncol=3, byrow=T ) )
        par( oma = c( 0, 0, 2, 0) )
        car::crPlots( model,
                      terms = reformulate( attr( terms( model ),"term.labels")[((a - 1) * 9 + 1):(a  * 9)] ),
                      ask = FALSE, main = "" )
        mtext( text =  paste( "Component-Residuals Plots", a),
               outer = TRUE, cex = 1.5 ) ;
        dev.off() ;
      }
    }
    
    if ( o != 0 )
    {
      png( paste( ExportName,
                  "Component-Residuals_Plots",
                  n + 1,
                  ".png",
                  sep = "" ) )
      layout( matrix( 1:9, ncol=3, byrow=T ) )
      par( oma = c( 0, 0, 2, 0) )
      car::crPlots( model,
                    terms = reformulate( attr( terms( model ),"term.labels")[(n * 9 + 1):(n * 9 + o)] ),
                    ask = FALSE, main = "" )
      mtext( text =  paste( "Component-Residuals Plots", n + 1),
             outer = TRUE, cex = 1.5 ) ;
      dev.off() ;
    }
  }
  
  Lm.Analysis <- function( outcome, predictors,
                           data,
                           na.omit = TRUE,
                           FULL = TRUE,
                           selected.predictors = NULL,
                           ANOVA = FALSE )
  {
    # Formula
    Formula.Maker( outcome, predictors ) ->
      formula ;
    
    # model
    if ( na.omit == TRUE ) { na.omit( data ) -> data }
    
    lm( formula, weights = weights, data = data ) ->
      m1 ;
    
    m1 |>
      (function(x)  list( model = x ) )() ->
      output ;
    
    m1 |> summary() -> summary1 ;
    
    m1 |>
      car::Confint( level = conf.level ) |>
      as.data.frame() |>
      (function(x) IFELSE( is.null( round ),
                           x,
                           round( x, round ) ) )() |>
      (function(x) cbind( Predictors = rownames(x), x ) )() |>
      (function(x) rbind.force( colnames(x), x) )() ->
      confint1 ;
    
    # prepare results
    if (FULL)
    {
      # formula
      "Model:" -> results.tab ;
      
      formula |>
        deparse() |>
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      "" |> (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      # missing data
      c( "Observations deleted due to missingness:",
         dim( data )[1] - dim( m1$model )[1] ) |>
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      "" |> (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      #  slopes and t.tests
      "Model coefficients and t-tests" |>
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      summary1 |>
        coef() |>
        as.data.frame()|>
        (function(x) data.frame( `Std. Error` =  IFELSE( is.null( round ),
                                                         x$`Std. Error`,
                                                         round( x$`Std. Error`, round  ) ),
                                 Df = summary1$df[2],
                                 `t value` =  IFELSE( is.null( round ),
                                                      x$`t value`,
                                                      round( x$`t value`, round ) ),
                                 `Pr(>|t|)` =  IFELSE( is.null( pvalue.round ),
                                                       x$`Pr(>|t|)`,
                                                       p.round( x$`Pr(>|t|)`, pvalue.round ) )  ) )() |>
        (function(x) rbind.force( colnames(x), x) )()  |>
        (function(x)    cbind( confint1, x ) )() |>
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      "" |> (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      c( "Degrees of freedom:", summary1$df[2],
         "Number of Coefficients:", summary1$df[1] ) |>
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      "" |> (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      # Anova
      m1 |>
        car::Anova( type = 3) |>
        as.data.frame() |>
        (function(x) cbind( Predictors = rownames(x), x ) )() |>
        (function(x) data.frame( Predictors = x$Predictors,
                                 `Sum Sq` = IFELSE( is.null( round ),
                                                    x$`Sum Sq`,
                                                    round( x$`Sum Sq`, round ) ),
                                 `Df numerator` = x$Df,
                                 `Df denominator` = c( rep( m1$df.residual,
                                                            times = dim(x)[1] - 1), NA ),
                                 `F value` =  IFELSE( is.null( round ),
                                                      x$`F value`,
                                                      round( x$`F value`, round ) ),
                                 `Pr(>F)` =  IFELSE( is.null( pvalue.round ),
                                                     x$`Pr(>F)`,
                                                     p.round( x$`Pr(>F)`, pvalue.round ) ) ) )() |>
        cbind(  `Cohen's f-squared on R-squared` =  IFELSE( is.null( round ),
                                                            c( NA, cohen.f2( m1 ), NA ),
                                                            c( NA, round( cohen.f2( m1 ), round ), NA  ) ) ) |>
        cbind(  `Partial eta-squared` =  IFELSE( is.null( round ),
                                                 c( NA, heplots::etasq( m1 )[,1] ),
                                                 c( NA, round( heplots::etasq( m1 )[,1], round )  ) ) ) |>
        cbind(  AIC =  IFELSE( is.null( round ),
                               AIC( m1 ),
                               round( AIC( m1 ), round ) ) ) ->
        anova1 ;
      
      # fusion anova and CI
      c( confint1[1,],
         colnames(anova1)[-1] ) |>
        matrix( nrow = 1 ) ->
        tmp.anova ;
      
      for ( a in as.character(anova1$Predictors)[-length(anova1$Predictors)] )
      {
        confint1[grep( a, confint1[,1] ) , ] -> tmp.ci1
        
        anova1[grep( a, anova1[,1] ) , ] -> tmp.anova1
        
        if ( !grepl( ":", a ) )
        {
          if ( length( grep( ":", tmp.ci1[,1] ) ) > 0 )
          {
            tmp.ci1[ -grep( ":", tmp.ci1[,1] ) , ] -> tmp.ci1
            
            tmp.anova1[ -grep( ":",
                               as.character( tmp.anova1[,1] )
            ),  ] ->
              tmp.anova1
          }
        }
        
        if ( grepl( ":", a ) )
        {
          strsplit( a, ":" ) |>
            unlist() ->
            sub.names.interaction
          
          confint1 -> tmp.ci1
          for ( b in sub.names.interaction )
          {
            tmp.ci1[grep( b, tmp.ci1[,1] ) , ] -> tmp.ci1
          }
        }
        
        cbind.force( tmp.ci1,
                     tmp.anova1[, -1 ],
                     empty = "" ) |>
          (function(x) rbind.force( tmp.anova,
                                    x,
                                    empty = "" ) )() ->
          tmp.anova ;
      }
      
      tmp.anova |>
        rbind.force(
          c( "Residuals", "", "", "",
             as.matrix( anova1[dim( anova1 )[1],-1] ) )  ,
          empty = "" ) ->
        tmp.anova ;
      
      "ANOVA (type 3 tests)" |> (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      tmp.anova |>
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      "" |> (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      # Models infos
      c( "Multiple R-squared:",
         IFELSE( is.null( round ),
                 summary1$r.squared,
                 round( summary1$r.squared, round ) ),
         "Adjusted R-squared:",
         IFELSE( is.null( round ),
                 summary1$adj.r.squared,
                 round( summary1$adj.r.squared, round ) ) ) |>
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      c( "AIC:",
         IFELSE( is.null( round ),
                 AIC(m1),
                 round( AIC(m1), round ) ),
         "AICc:",
         IFELSE( is.null( round ),
                 MuMIn::AICc(m1),
                 round( MuMIn::AICc(m1), round ) ) ) |>
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      "" |> (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      # post hoc analysis with no plots
      # Residuals normality
      residuals( m1 ) -> residuals1 ;
      if ( length( residuals1 ) < 5000 )
      { shapiro.test( residuals1 ) -> shapiro.res ; }  else
      { list( "p.value" = NA ) -> shapiro.res ; }
      nortest::ad.test( residuals1 ) -> anderson.res ;
      moments::jarque.test( residuals1 ) -> jarque.res ;
      
      "Normality tests on Residuals" |>
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      c( "Shapiro test p-value:",
         IFELSE( is.null( pvalue.round ),
                 shapiro.res$p.value,
                 p.round( shapiro.res$p.value, pvalue.round ) ),
         "Anderson-Darling test p-value:",
         IFELSE( is.null( pvalue.round ),
                 anderson.res$p.value,
                 p.round( anderson.res$p.value, pvalue.round ) ),
         "Jarque-Bera test p-value:",
         IFELSE( is.null( pvalue.round ),
                 jarque.res$p.value,
                 p.round( jarque.res$p.value, pvalue.round ) ) ) |>
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      "" |> (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      # Residuals homosedasticity
      "Homosedasticity tests on Residuals" |>
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      c( "Score test for Non-Constant Error Variance p-value:",
         IFELSE( is.null( pvalue.round ),
                 car::ncvTest( m1 )$p,
                 p.round( car::ncvTest( m1 )$p, pvalue.round ) ),
         "Breusch-Pagan test p-value:",
         IFELSE( is.null( pvalue.round ),
                 lmtest::bptest(m1)$p.value,
                 p.round( lmtest::bptest(m1)$p.value, pvalue.round ) ) ) |>
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      "" |> (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      # Residuals independancy
      "Independancy tests on Residuals" |>
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      set.seed( 123) ;
      car::durbinWatsonTest( m1 ) -> dw1 ;
      c( "Durbin-Watson statistic (1.5 - 2.5):",
         IFELSE( is.null( round ),
                 dw1$dw,
                 round( car::durbinWatsonTest( m1 )$p, round ) ),
         "Durbin-Watson test p-value:",
         IFELSE( is.null( pvalue.round ),
                 dw1$p,
                 p.round( car::durbinWatsonTest( m1 )$p, pvalue.round ) ) ) |>
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      "" |> (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      #  Multicollinearity
      if ( length( attr( terms(m1),"term.labels") ) > 1 )
      {
        c( "Multicollinearity check" ) |>
          (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
        
        c( "(generalized) Variance Inflation Factors:" ) |>
          (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
        
        car::vif( m1 ) |>
          (function(x) IFELSE( is.null( round ),
                               x,
                               round( x, round ) ) )() |>
          as.data.frame() |>
          (function(x) cbind( Predictors = rownames(x), x ) )() ->
          tmp.vif ;
        
        if ( ncol( tmp.vif ) == 2 ) { "VIF" -> colnames( tmp.vif )[2] }
        
        tmp.vif |>
          (function(x) rbind.force( colnames(x), x) )() |>
          (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
        
        "" |> (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
        
        # besley
        attr( terms( m1 ),"term.labels" ) -> Vars
        subset( data,
                select = Vars[
                  !( Vars  %in% Vars[ grep( ":", Vars ) ] ) ] ) |>
          dplyr::select_if( is.numeric ) ->
          data2
        
        VisCollin::colldiag( mod = lm(
          reformulate( colnames(data2),
                       as.character(formula)[2] ),
          weights = weights,
          data = data),
          scale = FALSE,
          center = FALSE, add.intercept = T ) ->
          besley
        
        "Belsley criteria (computed on numeric predictors only):" |> (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
        data.frame( capture.output(besley) ) |>
          (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
        "" |> (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
        
        # other criteria
        if ( ncol(data2) > 1 )
        {
          "Other criteron on numeric predictors only" |> (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
          "===================================" |> (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
          
          # omcdiag( data2,
          #           m1$fitted.values
          #  )  |>
          #    capture.output() |>
          #    data.frame() |>
          #    (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
          
          # imcdiag( data2,
          #          m1$fitted.values
          #  )  |>
          #   capture.output() |>
          #    data.frame() |>
          #    (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
          #  "" |>  (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
        }
        
      }
      
      
      #  Linearity and non-addititvity check
      c(  "Linearity and non-addititvity check" ) |>
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      c( "Curvature test and Tukey's test for non-additivity:" ) |>
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      car::residualPlot( m1, plot = FALSE ) |>
        (function(x)  IFELSE( is.null( pvalue.round ), 
                              x[2],
                              p.round( x[2], pvalue.round ) ) )() |>
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      "Best Fractional Polynomial for each numeric predictor:" |>
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      formula |> as.character() -> formula1 ;
      
      Systematic.FP( output = formula1[2],
                     predictors = attr( terms(m1), 'term.labels'),
                     family = "gaussian",
                     data = data,
                     na.omit = na.omit ) |>
        as.data.frame() |>
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      "" |> (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      # Observation with major influence
      c( "Observation with major influence" ) |>
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      c( "Number of observations",
         "with a Cook distance",
         "over 4 / N:",
         sum( cooks.distance( m1 ) > 4 / nrow( data ) )
      ) |>
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      "" |> (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      c( "Bonferroni Outlier test" ) |>
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      car::outlierTest( m1) |>
        capture.output() |>
        matrix( ncol = 1) |>
        as.data.frame() |>
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      "" |> (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      "/////////////////////////////////////////" |>
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
    }
    
    if ( !FULL & ANOVA )
    {
      # Anova
      m1 |>
        car::Anova( type = 3) |>
        as.data.frame() |>
        (function(x) cbind( Predictors = rownames(x), x ) )() |>
        (function(x)  data.frame( Predictors = x$Predictors,
                                  `Sum Sq` = IFELSE( is.null( round ),
                                                     x$`Sum Sq`,
                                                     round( x$`Sum Sq`, round ) ),
                                  `Df numerator` = x$Df,
                                  `Df denominator` = c( rep( m1$df.residual,
                                                             times = dim(x)[1] - 1), NA ),
                                  `F value` =  IFELSE( is.null( round ),
                                                       x$`F value`,
                                                       round( x$`F value`, round ) ),
                                  `Pr(>F)` =  IFELSE( is.null( pvalue.round ),
                                                      x$`Pr(>F)`,
                                                      p.round( x$`Pr(>F)`, pvalue.round ) ) ) )() |>
        cbind(  `Cohen's f-squared on R-squared` =  IFELSE( is.null( round ),
                                                            c( NA, cohen.f2( m1 ), NA ),
                                                            c( NA, round( cohen.f2( m1 ), round ), NA  ) ) ) |>
        cbind(  `Partial eta-squared` =  IFELSE( is.null( round ),
                                                 c( NA, heplots::etasq( m1 )[,1] ),
                                                 c( NA, round( heplots::etasq( m1 )[,1], round )  ) ) ) |>
        cbind(  AIC =  IFELSE( is.null( round ),
                               AIC( m1 ),
                               round( AIC( m1 ), round ) ) ) ->
        anova1 ;
      
      # fusion anova and CI
      c( confint1[1,],
         colnames(anova1)[-1] ) |>
        matrix( nrow = 1 ) ->
        tmp.anova ;
      
      for ( a in as.character(anova1$Predictors)[-length(anova1$Predictors)] )
      {
        confint1[grep( a, confint1[,1] ) , ] -> tmp.ci1
        
        anova1[grep( a, anova1[,1] ) , ] -> tmp.anova1
        
        if ( !grepl( ":", a ) )
        {
          if ( length( grep( ":", tmp.ci1[,1] ) ) > 0 )
          {
            tmp.ci1[ -grep( ":", tmp.ci1[,1] ) , ] -> tmp.ci1
            
            tmp.anova1[ -grep( ":",
                               as.character( tmp.anova1[,1] )
            ),  ] ->
              tmp.anova1
          }
        }
        
        if ( grepl( ":", a ) )
        {
          strsplit( a, ":" ) |>
            unlist() ->
            sub.names.interaction
          
          confint1 -> tmp.ci1
          for ( b in sub.names.interaction )
          {
            tmp.ci1[grep( b, tmp.ci1[,1] ) , ] -> tmp.ci1
          }
        }
        
        cbind.force( tmp.ci1,
                     tmp.anova1[, -1 ],
                     empty = "" ) |>
          (function(x) rbind.force( tmp.anova,
                                    x,
                                    empty = "" ) )() ->
          tmp.anova ;
      }
      
      tmp.anova |>
        rbind.force(
          c( "Residuals", "", "", "",
             as.matrix( anova1[dim( anova1 )[1],-1] ) )  ,
          empty = "" ) ->
        tmp.anova ;
      
      # Extraction
      lapply( 1:length(selected.predictors),
              function(a){
                tmp.anova[ grep( selected.predictors[a],  tmp.anova[,1] ), ] } ) |>
        (function(x) rbind.force( tmp.anova[1,], x, empty = "" ) )() |>
        unique() ->
        results.tab ;
    }
    
    
    if ( !FULL & !ANOVA )
    {
      # Compute output
      
      summary1 |>
        coef() |>
        as.data.frame()|>
        (function(x) data.frame( `Std. Error` =  IFELSE( is.null( round ),
                                                         x$`Std. Error`,
                                                         round( x$`Std. Error`, round ) ),
                                 Df = summary1$df[2],
                                 `t value` =  IFELSE( is.null( round ),
                                                      x$`t value`,
                                                      round( x$`t value`, round ) ),
                                 `Pr(>|t|)` =  IFELSE( is.null( pvalue.round ),
                                                       x$`Pr(>|t|)`,
                                                       p.round( x$`Pr(>|t|)`, pvalue.round ) ) ) )() |>
        (function(x) rbind.force( colnames(x), x) )()  |>
        (function(x)   cbind( confint1, x ) )()  ->
        tmp.student ;
      
      # Extraction
      lapply( 1:length(selected.predictors),
              function(a){
                tmp.student[ grep( selected.predictors[a],  tmp.student[,1] ), ] } ) |>
        (function(x) rbind.force( tmp.student[1,], x, empty = "" ) )() |>
        unique() ->
        results.tab ;
    }
    
    
    # output
    NULL -> rownames( results.tab ) ;
    NULL -> colnames( results.tab ) ;
    
    c( output, list( results.tab = results.tab ) ) ->
      output ;
    
    return( output )
  }
  
  Glm.Analysis <- function( outcome, predictors,
                            family,
                            data,
                            na.omit = TRUE,
                            FULL = TRUE,
                            selected.predictors = NULL,
                            ANODE = FALSE )
  {
    # Formula
    if ( length( outcome ) == 2 )
    { paste( "cbind(", outcome[1], ",", outcome[2], ")" ) -> outcome ;
      as.formula( paste(outcome,
                        " ~ ",
                        as.character( reformulate( predictors ) )[2] )
      ) ->
        formula ;
    } else
    {
      Formula.Maker( outcome, predictors ) ->
        formula ;
    }
    
    # model
    if ( na.omit == TRUE ) { na.omit( data ) -> data }
    
    glm( formula, family = family, weights = weights, data = data ) ->
      m1 ;
    
    m1 |>
      (function(x)  list( model = x ) )() ->
      output ;
    
    m1 |> summary() -> summary1 ;
    
    m1 |>
      car::Confint( level = conf.level ) |>
      exp() |>
      (function(x) IFELSE( is.null( round ),
                           x,
                           round( x, round ) ) )() |>
      as.data.frame() |>
      (function(x) cbind( Predictors = rownames(x), x ) )() |>
      (function(x)  rbind.force( c( colnames(x)[1],
                                    paste( "exp of",
                                           colnames(x)[-1] ) ),
                                 x ) )() ->
      confint1 ;
    
    # prepare results
    if (FULL)
    {
      # formula
      "Model:" -> results.tab ;
      
      formula |>
        deparse() |>
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      "" |> (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      # missing data
      c( "Observations deleted due to missingness:",
         dim( data )[1] - dim( m1$model )[1] ) |>
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      "" |> (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      #  slopes and t.tests
      "Model coefficients and t-tests" |>
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      summary1 |>
        coef() |>
        as.data.frame() |>
        (function(x) data.frame( `Std. Error` =  IFELSE( is.null( round ),
                                                         x$`Std. Error`,
                                                         round( x$`Std. Error`, round ) ),
                                 `--` = "",
                                 `z value` =  IFELSE( is.null( round ),
                                                      x$`z value`,
                                                      round( x$`z value`, round ) ),
                                 `Pr(>|z|)` =  IFELSE( is.null( pvalue.round ),
                                                       x$`Pr(>|z|)`,
                                                       p.round( x$`Pr(>|z|)`, pvalue.round ) ) ) )() |>
        (function(x) rbind.force( colnames(x), x) )()  |>
        (function(x)   cbind( confint1, x ) )() |>
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      "" |> (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      c( "Degrees of freedom:", summary1$df[2],
         "Number of Coefficients:", summary1$df[1] ) |>
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      "" |> (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      # Anova
      m1 |>
        car::Anova(  type = 3) |>
        as.data.frame() |>
        (function(x) cbind( Predictors = rownames(x), x ) )() |>
        (function(x) data.frame( Predictors = x$Predictors,
                                 `LR Chisq` =  IFELSE( is.null( round ),
                                                       x$`LR Chisq`,
                                                       round( x$`LR Chisq`, round ) ),
                                 `Chisq Df` = x$Df,
                                 `Residual Df` = m1$df.residual,
                                 `--` = "",
                                 `Pr(>Chisq)` =  IFELSE( is.null( pvalue.round ),
                                                         x$`Pr(>Chisq)`,
                                                         p.round( x$`Pr(>Chisq)`, pvalue.round ) ) ) )() |>
        cbind(   `Cohen's f-squared on pseudo-R-squared` =  IFELSE( is.null( round ),
                                                                    cohen.f2( m1, TRUE, family ),
                                                                    round( cohen.f2( m1, TRUE, family ),
                                                                           round ) ) ) |>
        cbind(
          `--` = "",
          AIC = IFELSE( is.null( round ),
                        AIC( m1 ),
                        round( AIC( m1 ), round ) )) ->
        anova1 ;
      
      # fusion anova and CI
      c( confint1[1,],
         colnames(anova1)[-1] ) |>
        matrix(  nrow = 1 ) ->
        tmp.anova ;
      
      for ( a in as.character(anova1$Predictors) )
      {
        confint1[grep( a, confint1[,1] ) , ] -> tmp.ci1
        
        anova1[grep( a, anova1[,1] ) , ] -> tmp.anova1
        
        if ( !grepl( ":", a ) )
        {
          if ( length( grep( ":", tmp.ci1[,1] ) ) > 0 )
          {
            tmp.ci1[ -grep( ":", tmp.ci1[,1] ) , ] -> tmp.ci1
            
            tmp.anova1[ -grep( ":",
                               as.character( tmp.anova1[,1] )
            ),  ] ->
              tmp.anova1
          }
        }
        
        if ( grepl( ":", a ) )
        {
          strsplit( a, ":" ) |>
            unlist() ->
            sub.names.interaction
          
          confint1 -> tmp.ci1
          for ( b in sub.names.interaction )
          {
            tmp.ci1[grep( b, tmp.ci1[,1] ) , ] -> tmp.ci1
          }
        }
        
        cbind.force( tmp.ci1,
                     tmp.anova1[, -1 ],
                     empty = "" ) |>
          (function(x) rbind.force( tmp.anova,
                                    x,
                                    empty = "" ) )() ->
          tmp.anova ;
      }
      
      "ANODE (type 3 tests)" |>
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      tmp.anova |>
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      "" |> (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      # Models infos
      c( "Multiple Cox an Snell pseuod-R-squared:",
         IFELSE( is.null( round ),
                 MuMIn::r.squaredLR( m1, stats::update( m1, reformulate( "1" ) ) )[1],
                 round( MuMIn::r.squaredLR( m1, stats::update( m1, reformulate( "1" ) ) )[1],
                        round ) ),
         "Nagelkerke Adjusted pseudo-R-squared:",
         IFELSE( is.null( round ),
                 attr( MuMIn::r.squaredLR( m1, stats::update( m1, reformulate( "1" ) ) ),
                       "adj.r.squared"),
                 round( attr( MuMIn::r.squaredLR( m1, stats::update( m1, reformulate( "1" ) ) ),
                              "adj.r.squared"),
                        round ) ) ) |>
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      c( "AIC:",
         IFELSE( is.null( round ),
                 AIC(m1),
                 round( AIC(m1), round ) ),
         "AICc:",
         IFELSE( is.null( round ),
                 MuMIn::AICc(m1),
                 round( MuMIn::AICc(m1), round ) ) ) |>
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      "" |> (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      # post hoc analysis with no plots
      
      # Dispersion
      c( "Dispersion:",
         IFELSE( is.null( round ),
                 summary( m1 )$dispersion ,
                 round(  summary( m1 )$dispersion , round ) ) ) |>
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      "" |> (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      #  Multicollinearity
      if ( length( attr( terms(m1),"term.labels") ) > 1 )
      {
        c( "Multicollinearity check" ) |>
          (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
        
        c( "(generalized) Variance Inflation Factors:" ) |>
          (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
        
        car::vif( m1 ) |>
          (function(x) IFELSE( is.null( round ),
                               x,
                               round( x, round ) ) )() |>
          as.data.frame() |>
          (function(x) cbind( Predictors = rownames(x), x ) )() ->
          tmp.vif ;
        
        if ( ncol( tmp.vif ) == 2 ) { "VIF" -> colnames( tmp.vif )[2] }
        
        tmp.vif |>
          (function(x) rbind.force( colnames(x), x) )() |>
          (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
        
        "" |> (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
        
        # besley
        attr( terms( m1 ),"term.labels" ) -> Vars
        subset( data,
                select = Vars[
                  !( Vars  %in% Vars[ grep( ":", Vars ) ] ) ] ) |>
          dplyr::select_if( is.numeric ) ->
          data2
        
        VisCollin::colldiag( mod = glm(
          reformulate( colnames(data2),
                       as.character(formula)[2] ),
          family = family,
          data = data),
          scale = FALSE,
          center = FALSE, add.intercept = T ) ->
          besley
        
        "Belsley criteria (computed on numeric predictors only):" |> (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
        data.frame( besley$condindx, besley$pi) |>
          (function(x) rbind( colnames(x), x ) )() |>
          (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
        "" |> (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
        
        
      }
      
      #  Linearity and non-addititvity check
      c(  "Linearity and non-addititvity check" ) |>
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab
      
      "Best Fractional Polynomial for each numeric predictor:" |>
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      formula |> as.character() -> formula1 ;
      
      Systematic.FP( output = formula1[2],
                     predictors = attr( terms(m1), 'term.labels'),
                     family = family,
                     data = data,
                     na.omit = na.omit ) |>
        as.data.frame() |>
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      "" |> (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      # Observation with major influence
      c( "Observation with major influence" ) |>
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      c( "Number of observations",
         "with a Cook distance",
         "over 4 / N:",
         sum( cooks.distance( m1 ) > 4 / nrow( data ) )
      ) |>
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      "" |> (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      car::outlierTest( m1) |>
        capture.output() |>
        matrix(  ncol = 1) |>
        as.data.frame() |>
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      "" |> (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      "/////////////////////////////////////////////////////" |>
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
    }
    
    
    if ( !FULL & ANODE )
    {
      # Anova
      m1 |>
        car::Anova( type = 3) |>
        as.data.frame() |>
        (function(x) cbind( Predictors = rownames(x), x ) )() |>
        (function(x) data.frame( Predictors = x$Predictors,
                                 `LR Chisq` =  IFELSE( is.null( round ),
                                                       x$`LR Chisq`,
                                                       round( x$`LR Chisq`, round ) ),
                                 `Chisq Df` = x$Df,
                                 `Residual Df` = m1$df.residual,
                                 `--` = "",
                                 `Pr(>Chisq)` =  IFELSE( is.null( pvalue.round ),
                                                         x$`Pr(>Chisq)`,
                                                         p.round( x$`Pr(>Chisq)`, pvalue.round ) ) ) )() |>
        cbind(   `Cohen's f-squared on pseudo-R-squared` =  IFELSE( is.null( round ),
                                                                    cohen.f2( m1, TRUE, family ),
                                                                    round( cohen.f2( m1, TRUE, family ),
                                                                           round ) ) ) |>
        cbind( 
          `--` = "",
          AIC = IFELSE( is.null( round ),
                        AIC( m1 ),
                        round( AIC( m1 ), round ) )) ->
        anova1 ;
      
      # fusion anova and CI
      c( confint1[1,],
         colnames(anova1)[-1] ) |>
        matrix(  nrow = 1 ) ->
        tmp.anova ;
      
      for ( a in as.character(anova1$Predictors) )
      {
        confint1[grep( a, confint1[,1] ) , ] -> tmp.ci1
        
        anova1[grep( a, anova1[,1] ) , ] -> tmp.anova1
        
        if ( !grepl( ":", a ) )
        {
          if ( length( grep( ":", tmp.ci1[,1] ) ) > 0 )
          {
            tmp.ci1[ -grep( ":", tmp.ci1[,1] ) , ] -> tmp.ci1
            
            tmp.anova1[ -grep( ":",
                               as.character( tmp.anova1[,1] )
            ),  ] ->
              tmp.anova1
          }
        }
        
        if ( grepl( ":", a ) )
        {
          strsplit( a, ":" ) |>
            unlist() ->
            sub.names.interaction
          
          confint1 -> tmp.ci1
          for ( b in sub.names.interaction )
          {
            tmp.ci1[grep( b, tmp.ci1[,1] ) , ] -> tmp.ci1
          }
        }
        
        cbind.force( tmp.ci1,
                     tmp.anova1[, -1 ],
                     empty = "" ) |>
          (function(x) rbind.force( tmp.anova,
                                    x,
                                    empty = "" ) )() ->
          tmp.anova ;
      }
      
      # Extraction
      lapply( 1:length(selected.predictors),
              function(a){
                tmp.anova[ grep( selected.predictors[a],  tmp.anova[,1] ), ] } ) |>
        (function(x)  rbind.force( tmp.anova[1,], x, empty = "" ) )() |>
        unique() ->
        results.tab ;
    }
    
    
    if ( !FULL & !ANODE )
    {
      # Compute output
      summary1 |>
        coef() |>
        as.data.frame() |>
        (function(x) data.frame( `Std. Error` =  IFELSE( is.null( round ),
                                                         x$`Std. Error`,
                                                         round( x$`Std. Error`, round ) ),
                                 `--` = "",
                                 `z value` =  IFELSE( is.null( round ),
                                                      x$`z value`,
                                                      round( x$`z value`, round ) ),
                                 `Pr(>|z|)` =  IFELSE( is.null( pvalue.round ),
                                                       x$`Pr(>|z|)`,
                                                       p.round( x$`Pr(>|z|)`, pvalue.round ) ) ) )() |>
        (function(x) rbind.force( colnames(x), x) )()  |>
        (function(x) cbind( confint1, x ) )() ->
        tmp.student ;
      
      # Extraction
      lapply( 1:length(selected.predictors),
              function(a){
                tmp.student[ grep( selected.predictors[a],  tmp.student[,1] ), ] } ) |>
        (function(x) rbind.force( tmp.student[1,], x, empty = "" ) )() |>
        unique() ->
        results.tab ;
    }
    
    
    # output
    NULL -> rownames( results.tab ) ;
    NULL -> colnames( results.tab ) ;
    
    c( output, list( results.tab = results.tab ) ) ->
      output ;
    
    return( output )
  }
  
  Multinom.Analysis <- function( outcome, predictors,
                                 data,
                                 HMF.test = TRUE,
                                 na.omit = TRUE,
                                 FULL = TRUE,
                                 selected.predictors = NULL,
                                 ANODE = FALSE )
  {
    # Formula
    Formula.Maker( outcome, predictors ) ->
      formula ;
    
    # model
    if ( na.omit == TRUE ) { na.omit( data ) -> data }
    
    nnet::multinom( reformulate(as.character(formula)[3], as.character(formula)[2]),
                    data = data, weights = weights, Hess = TRUE ) ->
      m1 ;
    
    m1 |>
      (function(x) list( model = x ) )() ->
      output ;
    
    m1 |> summary() -> summary1 ;
    
    summary1$coefficients |>
      (function(x) cbind( Predictors = rownames(x), x) )() |>
      as.data.frame() |>
      tidyr::gather( key = Predic, value = "Estimate", -Predictors ) ->
      Estimates ;
    
    summary1$standard.errors |>
      (function(x) cbind( Predictors = rownames(x), x) )() |>
      as.data.frame() |>
      tidyr::gather( key = Predic, value = "SE", -Predictors ) ->
      SEs ;
    
    merge( Estimates, SEs ) |>
      dplyr::mutate( Estimate = as.numeric( Estimate ), 
                     SE = as.numeric( SE ) ) |> 
      dplyr::transmute( Predictors = paste( Predictors, "|", Predic ),
                        Estimate = Estimate,
                        lb = Estimate - qnorm( (1 - conf.level) / 2, lower.tail = FALSE ) * SE,
                        ub = Estimate + qnorm( (1 - conf.level) / 2, lower.tail = FALSE ) * SE
      ) -> ci ;
    
    c( paste( (1 - conf.level) / 2 * 100, "%" ),
       paste( (1 -(1 - conf.level) / 2 ) * 100, "%" )  ) ->
      colnames( ci )[3:4] ;
    ci[,1] -> rownames( ci ) ;
    
    ci[,-1] |>
      exp() |>
      (function(x) IFELSE( is.null( round ),
                           x,
                           round( x, round ) ) )() |>
      as.data.frame() |>
      (function(x) cbind( Predictors = rownames(x), x ) )()  ->
      confint1 ;
    
    paste( "exp of",
           colnames(confint1)[-1] ) ->
      colnames(confint1)[-1] ;
    
    
    # prepare results
    if (FULL)
    {
      # formula
      "Model:" -> results.tab ;
      
      formula |>
        deparse() |>
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      "" |> (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      # missing data
      c( "Observations deleted due to missingness:",
         dim( data )[1] - dim( m1$residuals )[1] ) |>
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      "" |> (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      #  slopes and t.tests
      "Model coefficients and t-tests" |>
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      abs(summary1$coefficients /  summary1$standard.errors) |>
        pnorm(  lower.tail = FALSE )  |>
        (function(x) as.matrix(as.matrix(x) * 2) )()  |>
        (function(x)  IFELSE( is.null( pvalue.round ),
                              x,
                              p.round( x, pvalue.round ) ) )() |>
        (function(x) cbind( rownames(x), x) )() |>
        as.data.frame() |>
        tidyr::gather( key = V2, value = `Pr(>|z|)`, -V1 )  |>
        dplyr::mutate( 
          Predictors = paste( V1, "|", V2 ) ) |>
        dplyr::select(  Predictors, `Pr(>|z|)` ) ->
        P ;
      
      (summary1$coefficients /  summary1$standard.errors) |>
        (function(x) IFELSE( is.null( round ),
                             x,
                             round( x, round ) ) )() |>
        (function(x) cbind( rownames(x), x) )() |>
        as.data.frame() |>
        tidyr::gather( key = V2, value = `z value`, -V1 )  |>
        dplyr::mutate( 
          Predictors = paste( V1, "|", V2 ) ) |>
        dplyr::select(  Predictors, `z value` ) ->
        Z ;
      
      
      summary1$standard.errors |>
        (function(x) IFELSE( is.null( round ),
                             x,
                             round( x, round ) ) )() |>
        (function(x) cbind( rownames(x), x) )() |>
        as.data.frame() |>
        tidyr::gather( key = V2, value = `Std. Error`, -V1 ) |>
        dplyr::mutate( 
          Predictors = paste( V1, "|", V2 ) ) |>
        dplyr::select(  Predictors, `Std. Error` ) ->
        SE1 ;
      
      merge( confint1, SE1) |>
        merge(   Z  ) |>
        dplyr::mutate( `--` = "" ) |>
        merge(  P )|>
        (function(x) rbind.force( colnames(x), x) )()  |>
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      "" |> (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      c( "Number of Coefficients:", dim(summary1$standard.errors)[1] * dim(summary1$standard.errors)[2] ) |>
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      "" |> (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      # Anova
      m1 |>
        car::Anova(  type = 3) |>
        as.data.frame() |>
        (function(x) cbind( Predictors = rownames(x), x ) )() |>
        (function(x) data.frame( Predictors = x$Predictors,
                                 `LR Chisq` =  IFELSE( is.null( round ),
                                                       x$`LR Chisq`,
                                                       round( x$`LR Chisq`, round ) ),
                                 `Chisq Df` = x$Df,
                                 `Residual Df` = dim( m1$residuals)[1] - dim(summary1$standard.errors)[1] * dim(summary1$standard.errors)[2] ,
                                 `--` = "",
                                 `Pr(>Chisq)` =  IFELSE( is.null( pvalue.round ),
                                                         x$`Pr(>Chisq)`,
                                                         p.round( x$`Pr(>Chisq)`, pvalue.round ) ) ) )() |>
        cbind(   `Cohen's f-squared on pseudo-R-squared` =  IFELSE( is.null( round ),
                                                                    cohen.f2( m1, TRUE ),
                                                                    round( cohen.f2( m1, TRUE ),
                                                                           round ) ) ) |>
        cbind( 
          `--` = "",
          AIC = IFELSE( is.null( round ),
                        AIC( m1 ),
                        round( AIC( m1 ), round ) )) ->
        anova1 ;
      
      # fusion anova and CI
      c( colnames( confint1 ),
         colnames(anova1)[-1] ) |>
        matrix(  nrow = 1 ) ->
        tmp.anova ;
      
      for ( a in as.character(anova1$Predictors) )
      {
        confint1[grep( a, confint1[,1] ) , ] -> tmp.ci1
        
        anova1[grep( a, anova1[,1] ) , ] -> tmp.anova1
        
        if ( !grepl( ":", a ) )
        {
          if ( length( grep( ":", tmp.ci1[,1] ) ) > 0 )
          {
            tmp.ci1[ -grep( ":", tmp.ci1[,1] ) , ] -> tmp.ci1
            
            tmp.anova1[ -grep( ":",
                               as.character( tmp.anova1[,1] )
            ),  ] ->
              tmp.anova1
          }
        }
        
        if ( grepl( ":", a ) )
        {
          strsplit( a, ":" ) |>
            unlist() ->
            sub.names.interaction
          
          confint1 -> tmp.ci1
          for ( b in sub.names.interaction )
          {
            tmp.ci1[grep( b, tmp.ci1[,1] ) , ] -> tmp.ci1
          }
        }
        
        cbind.force( tmp.ci1,
                     tmp.anova1[, -1 ],
                     empty = "" ) |>
          (function(x)  rbind.force( tmp.anova,
                                     x,
                                     empty = "" ) )() ->
          tmp.anova ;
      }
      
      "ANODE (type 3 tests)" |>
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      tmp.anova |>
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      "" |> (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      # Models infos
      c( "Multiple Cox an Snell pseuod-R-squared:",
         IFELSE( is.null( round ),
                 MuMIn::r.squaredLR( m1, stats::update( m1, reformulate( "1" ) ) )[1],
                 round( MuMIn::r.squaredLR( m1, stats::update( m1, reformulate( "1" ) ) )[1],
                        round ) ),
         "Nagelkerke Adjusted pseudo-R-squared:",
         IFELSE( is.null( round ),
                 attr( MuMIn::r.squaredLR( m1, stats::update( m1, reformulate( "1" ) ) ),
                       "adj.r.squared"),
                 round( attr( MuMIn::r.squaredLR( m1, stats::update( m1, reformulate( "1" ) ) ),
                              "adj.r.squared"),
                        round ) ) ) |>
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      c( "AIC:",
         IFELSE( is.null( round ),
                 AIC(m1),
                 round( AIC(m1), round ) ),
         "AICc:",
         IFELSE( is.null( round ),
                 MuMIn::AICc(m1),
                 round( MuMIn::AICc(m1), round ) ) ) |>
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      "" |> (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      # post hoc analysis with no plots
      
      #  Multicollinearity
      c( "Multicollinearity check" ) |>
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      c( "(generalized) Variance Inflation Factors:", "No intercept include for computations: vifs may not be sensible" ) |>
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      if ( length( attr( terms( formula ),"term.labels" ) ) == 1 )
      {
        data.frame( "no possible because just 1 predictor" ) -> tmp.mc ;
      } else
      {
        "" -> tmp.mc
        # vif
        car::vif( m1 ) |>
          (function(x) IFELSE( is.null( round ),
                               x,
                               round( x, round ) ) )() |>
          as.data.frame() |>
          (function(x) cbind( Predictors = rownames(x), x ) )() ->
          tmp.vif ;
        
        if ( ncol( tmp.vif ) == 2 ) { "VIF" -> colnames( tmp.vif )[2] }
        
        tmp.vif |>
          (function(x) rbind.force( colnames(x), x) )() |>
          (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
        "" |> (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
        
        # besley
        attr( terms( m1 ),"term.labels" ) -> Vars
        subset( data,
                select = Vars[
                  !( Vars  %in% Vars[ grep( ":", Vars ) ] ) ] ) |>
          dplyr::select_if( is.numeric ) ->
          data2
        
        VisCollin::colldiag( mod = nnet::multinom(
          reformulate( colnames(data2),
                       as.character(formula)[2] ),
          data = data,
          weights = weights,
          model = T ),
          scale = FALSE,
          center = FALSE, add.intercept = T ) ->
          besley
        
        "Belsley criteria (computed on numeric predictors only):" |> (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
        data.frame( besley$condindx, besley$pi ) |>
          (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
        "" |> (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
        
        # other criteria
        if ( ncol(data2) > 1 )
        {
          "Other criteron:" |> (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
          
          # for ( i in 1:ncol(m1$fitted.values))
          #  {
          #    paste0( "On fitted OR, model: ", i ) |>
          #      (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
          
          #omcdiag( data2,
          #            m1$fitted.values[,i]
          #    )  |>
          #     capture.output() |>
          #    data.frame() |>
          #   (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
          
          #  imcdiag( data2,
          #           m1$fitted.values[,i]
          #  )  |>
          #    capture.output() |>
          #    data.frame() |>
          #    (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
          #  "" |>  (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
          #  }
        }
        
      }
      
      tmp.mc |>
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      "" |> (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      # Independence of Irrelevant Alternatives assumption : Hauslab-McFadden test
      c( "Independence of Irrelevant Alternatives assumption" ) |>
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      if ( HMF.test )
      {
        c( "Hauslab-McFadden test:" ) |>
          (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
        
        hmftest.systematic( formula, data, weights = weights ) |>
          data.frame() |>
          (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
        
        "" |> (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      }
      
      c( "Substracting each levels of outcome:" ) |>
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      Multinomial.SubsetLevels( formula, data,  weights, round ) |>
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      "" |> (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      "/////////////////////////////////////////////////////" |>
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
    }
    
    if ( !FULL & ANODE )
    {
      # Anova
      m1 |>
        car::Anova(  type = 3) |>
        as.data.frame() |>
        (function(x) cbind( Predictors = rownames(x), x ) )() |>
        (function(x) data.fr( Predictors = x$Predictors,
                              `LR Chisq` =  IFELSE( is.null( round ),
                                                    x$`LR Chisq`,
                                                    round( x$`LR Chisq`, round ) ),
                              `Chisq Df` = x$Df,
                              `Residual Df` = dim( m1$residuals)[1] - dim(summary1$standard.errors)[1] * dim(summary1$standard.errors)[2] ,
                              `--` = "",
                              `Pr(>Chisq)` =  IFELSE( is.null( pvalue.round ),
                                                      x$`Pr(>Chisq)`,
                                                      p.round( x$`Pr(>Chisq)`, pvalue.round ) ) ) )() |>
        cbind(   `Cohen's f-squared on pseudo-R-squared` =  IFELSE( is.null( round ),
                                                                    cohen.f2( m1, TRUE ),
                                                                    round( cohen.f2( m1, TRUE ),
                                                                           round ) ) ) |>
        cbind( 
          `--` = "",
          AIC = IFELSE( is.null( round ),
                        AIC( m1 ),
                        round( AIC( m1 ), round ) )) ->
        anova1 ;
      
      # fusion anova and CI
      c( colnames( confint1 ),
         colnames(anova1)[-1] ) |>
        matrix(  nrow = 1 ) ->
        tmp.anova ;
      
      for ( a in as.character(anova1$Predictors) )
      {
        confint1[grep( a, confint1[,1] ) , ] -> tmp.ci1
        
        anova1[grep( a, anova1[,1] ) , ] -> tmp.anova1
        
        if ( !grepl( ":", a ) )
        {
          if ( length( grep( ":", tmp.ci1[,1] ) ) > 0 )
          {
            tmp.ci1[ -grep( ":", tmp.ci1[,1] ) , ] -> tmp.ci1
            
            tmp.anova1[ -grep( ":",
                               as.character( tmp.anova1[,1] )
            ),  ] ->
              tmp.anova1
          }
        }
        
        if ( grepl( ":", a ) )
        {
          strsplit( a, ":" ) |>
            unlist() ->
            sub.names.interaction
          
          confint1 -> tmp.ci1
          for ( b in sub.names.interaction )
          {
            tmp.ci1[grep( b, tmp.ci1[,1] ) , ] -> tmp.ci1
          }
        }
        
        cbind.force( tmp.ci1,
                     tmp.anova1[, -1 ],
                     empty = "" ) |>
          (function(x) rbind.force( tmp.anova,
                                    x,
                                    empty = "" ) )() ->
          tmp.anova ;
      }
      
      # Extraction
      lapply( 1:length(selected.predictors),
              function(a){
                tmp.anova[ grep( selected.predictors[a],  tmp.anova[,1] ), ] } ) |>
        (function(x) rbind.force( tmp.anova[1,], x, empty = "" ) )() |>
        unique() ->
        results.tab ;
    }
    
    
    if ( !FULL & !ANODE )
    {
      #  slopes and t.tests
      abs(summary1$coefficients /  summary1$standard.errors) |>
        pnorm(  lower.tail = FALSE )  |>
        as.matrix(as.matrix() * 2)  |>
        (function(x) IFELSE( is.null( pvalue.round ),
                             x,
                             p.round( x, pvalue.round ) ) )() |>
        (function(x) cbind( rownames(x), x) )() |>
        as.data.frame() |>
        tidyr::gather( key = V2, value = `Pr(>|z|)`, -V1 )  |>
        dplyr::mutate( 
          Predictors = paste( V1, "|", V2 ) ) |>
        dplyr::select(  Predictors, `Pr(>|z|)` ) ->
        P ;
      
      (summary1$coefficients /  summary1$standard.errors) |>
        (function(x) IFELSE( is.null( round ),
                             x,
                             round( x, round ) ) )() |>
        (function(x) cbind( rownames(x), x) )() |>
        as.data.frame() |>
        tidyr::gather( key = V2, value = `z value`, -V1 )  |>
        dplyr::mutate( 
          Predictors = paste( V1, "|", V2 ) ) |>
        dplyr::select(  Predictors, `z value` ) ->
        Z ;
      
      
      summary1$standard.errors |>
        (function(x) IFELSE( is.null( round ),
                             x,
                             round( x, round ) ) )() |>
        (function(x) cbind( rownames(x), x) )() |>
        as.data.frame() |>
        tidyr::gather( key = V2, value = `Std. Error`, -V1 ) |>
        dplyr::mutate( 
          Predictors = paste( V1, "|", V2 ) ) |>
        dplyr::select(  Predictors, `Std. Error` ) ->
        SE1 ;
      
      merge( confint1, SE1) |>
        merge(   Z  ) |>
        dplyr::mutate( `--` = "" ) |>
        merge(  P )|>
        (function(x) rbind.force( colnames(x), x) )()    ->
        tmp.student ;
      
      # Extraction
      lapply( 1:length(selected.predictors),
              function(a){
                tmp.student[ grep( selected.predictors[a],  tmp.student[,1] ), ] } ) |>
        (function(x) rbind.force( tmp.student[1,], x, empty = "" ) )() |>
        unique() ->
        results.tab ;
    }
    
    
    # output
    NULL -> rownames( results.tab ) ;
    NULL -> colnames( results.tab ) ;
    
    c( output, list( results.tab = results.tab ) ) ->
      output ;
    
    return( output )
  }
  
  Ordinal.Analysis <- function( outcome, predictors,
                                data,
                                na.omit = TRUE,
                                FULL = TRUE,
                                selected.predictors = NULL,
                                ANODE = FALSE )
  {
    # Formula
    Formula.Maker( outcome, predictors ) ->
      formula ;
    
    # model
    formula -> formula1 ;
    
    data -> data.clm ;
    
    if ( na.omit == TRUE ) { na.omit( data ) -> data }
    
    MASS::polr( formula1, data = data, weights = weights, Hess = TRUE ) ->
      m1 ;
    
    try( ordinal::clm( formula1, data = data.clm, weights = weights ), silent = T ) -> clm1 ;
    
    m1 |> summary() -> summary1 ;
    
    summary1$coefficients |>
      as.data.frame() |>
      (function(x)  data.frame( Predictors = rownames(x),
                                Estimate = x$Value,
                                lb = x$Value - qnorm( (1 - conf.level) / 2, lower.tail = FALSE ) * x$`Std. Error`,
                                ub = x$Value + qnorm( (1 - conf.level) / 2, lower.tail = FALSE ) * x$`Std. Error`
      ) )() -> ci ;
    
    c( paste( (1 - conf.level) / 2 * 100, "%" ),
       paste( (1 -(1 - conf.level) / 2 ) * 100, "%" )  ) ->
      colnames( ci )[3:4] ;
    ci[,1] -> rownames( ci ) ;
    
    ci[,-1] |>
      exp() |>
      (function(x)  IFELSE( is.null( round ),
                            x,
                            round( x, round ) ) )() |>
      as.data.frame() |>
      (function(x) cbind( Predictors = rownames(x), x ) )() |>
      (function(x) rbind.force( c( colnames(x)[1],
                                   paste( "exp of",
                                          colnames(x)[-1] ) ),
                                x ) )() ->
      confint1 ;
    
    # prepare results
    if (FULL)
    {
      # formula
      "Model:" -> results.tab ;
      
      formula |>
        deparse() |>
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      "" |> (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      # missing data
      c( "Observations deleted due to missingness:",
         dim( data )[1] - dim( m1$model )[1] ) |>
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      "" |> (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      #  slopes and t.tests
      "Model coefficients and t-tests" |>
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      summary1 |>
        coef() |>
        as.data.frame() |>
        (function(x) data.frame( `Std. Error` =  IFELSE( is.null( round ),
                                                         x$`Std. Error`,
                                                         round( x$`Std. Error`, round ) ),
                                 `--` = "",
                                 `z value` =  IFELSE( is.null( round ),
                                                      x$Value / x$`Std. Error`,
                                                      round( x$Value / x$`Std. Error`, round ) ),
                                 `Pr(>|z|)` =  IFELSE( is.null( pvalue.round ),
                                                       pnorm( abs( x$Value / x$`Std. Error` ),
                                                              lower.tail = FALSE ) * 2,
                                                       p.round( pnorm( abs( x$Value / x$`Std. Error` ),
                                                                       lower.tail = FALSE ) * 2,
                                                                pvalue.round ) ) ) )() |>
        (function(x) rbind.force( colnames(x), x) )()  |>
        (function(x)   cbind( confint1, x ) )()  |>
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      "" |> (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      c( "Degrees of freedom:", summary1$df.residual,
         "Number of Coefficients:", length(coef(m1)) + length(m1$zeta) ) |>
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      "" |> (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      # Anova
      m1 |>
        car::Anova(  type = 3) |>
        as.data.frame() |>
        (function(x) cbind( Predictors = rownames(x), x ) )() |>
        (function(x) data.frame( Predictors = x$Predictors,
                                 `LR Chisq` =  IFELSE( is.null( round ),
                                                       x$`LR Chisq`,
                                                       round( x$`LR Chisq`, round ) ),
                                 `Chisq Df` = x$Df,
                                 `Residual Df` = m1$df.residual,
                                 `--` = "",
                                 `Pr(>Chisq)` =  IFELSE( is.null( pvalue.round ),
                                                         x$`Pr(>Chisq)`,
                                                         p.round( x$`Pr(>Chisq)`, pvalue.round ) ) ) )() |>
        cbind(   `Cohen's f-squared on pseudo-R-squared` =  IFELSE( is.null( round ),
                                                                    cohen.f2( m1, TRUE ),
                                                                    round( cohen.f2( m1, TRUE ),
                                                                           round ) ) ) |>
        cbind( 
          `--` = "",
          AIC = IFELSE( is.null( round ),
                        AIC( m1 ),
                        round( AIC( m1 ), round ) )) ->
        anova1 ;
      
      # fusion anova and CI
      c( confint1[1,],
         colnames(anova1)[-1] ) |>
        matrix(  nrow = 1 ) ->
        tmp.anova ;
      
      for ( a in as.character(anova1$Predictors) )
      {
        confint1[grep( a, confint1[,1] ) , ] -> tmp.ci1
        
        anova1[grep( a, anova1[,1] ) , ] -> tmp.anova1
        
        if ( !grepl( ":", a ) )
        {
          if ( length( grep( ":", tmp.ci1[,1] ) ) > 0 )
          {
            tmp.ci1[ -grep( ":", tmp.ci1[,1] ) , ] -> tmp.ci1
            
            tmp.anova1[ -grep( ":",
                               as.character( tmp.anova1[,1] )
            ),  ] ->
              tmp.anova1
          }
        }
        
        if ( grepl( ":", a ) )
        {
          strsplit( a, ":" ) |>
            unlist() ->
            sub.names.interaction
          
          confint1 -> tmp.ci1
          for ( b in sub.names.interaction )
          {
            tmp.ci1[grep( b, tmp.ci1[,1] ) , ] -> tmp.ci1
          }
        }
        
        cbind.force( tmp.ci1,
                     tmp.anova1[, -1 ],
                     empty = "" ) |>
          (function(x) rbind.force( tmp.anova,
                                    x,
                                    empty = "" ) )() ->
          tmp.anova ;
      }
      
      "ANODE (type 3 tests)" |>
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      tmp.anova |>
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      "" |> (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      # Models infos
      c( "Multiple Cox an Snell pseuod-R-squared:",
         IFELSE( is.null( round ),
                 MuMIn::r.squaredLR( m1, stats::update( m1, reformulate( "1" ) ) )[1],
                 round( MuMIn::r.squaredLR( m1, stats::update( m1, reformulate( "1" ) ) )[1],
                        round ) ),
         "Nagelkerke Adjusted pseudo-R-squared:",
         IFELSE( is.null( round ),
                 attr( MuMIn::r.squaredLR( m1, stats::update( m1, reformulate( "1" ) ) ),
                       "adj.r.squared"),
                 round( attr( MuMIn::r.squaredLR( m1, stats::update( m1, reformulate( "1" ) ) ),
                              "adj.r.squared"),
                        round ) ) ) |>
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      c( "AIC:",
         IFELSE( is.null( round ),
                 AIC(m1),
                 round( AIC(m1), round ) ),
         "AICc:",
         IFELSE( is.null( round ),
                 MuMIn::AICc(m1),
                 round( MuMIn::AICc(m1), round ) ) ) |>
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      "" |> (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      # post hoc analysis with no plots
      
      #  Multicollinearity
      c( "Multicollinearity check" ) |>
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      c( "(generalized) Variance Inflation Factors:", "No intercept: vifs may not be sensible" ) |>
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      if ( length( attr( terms( formula ),"term.labels" ) ) == 1 )
      {
        data.frame( "no possible because just 1 predictor" ) -> tmp.mc ;
      } else
      {
        "" -> tmp.mc
        # vif
        car::vif( m1 ) |>
          (function(x) IFELSE( is.null( round ),
                               x,
                               round( x, round )  ) )() |>
          as.data.frame() |>
          (function(x) cbind( Predictors = rownames(x), x ) )() ->
          tmp.vif ;
        
        if ( ncol( tmp.vif ) == 2 ) { "VIF" -> colnames( tmp.vif )[2] }
        
        tmp.vif |>
          (function(x) rbind.force( colnames(x), x) )() |>
          (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
        "" |> (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
        
        # besley
        attr( terms( m1 ),"term.labels" ) -> Vars
        subset( data,
                select = Vars[
                  !( Vars  %in% Vars[ grep( ":", Vars ) ] ) ] ) |>
          dplyr::select_if( is.numeric ) ->
          data2
        
        VisCollin::colldiag( mod = MASS::polr(
          reformulate( colnames(data2),
                       as.character(formula)[2] ),
          data = data ),
          scale = FALSE,
          center = FALSE, add.intercept = T ) ->
          besley
        
        "Belsley criteria (computed on numeric predictors only):" |> (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
        data.frame( besley$condindx, besley$pi) |>
          (function(x) rbind( colnames(x), x ) )() |>
          (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
        "" |> (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
        
      }
      
      tmp.mc |>
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      "" |> (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      # Proportional odds assumptions
      c( "Proportional odds assumption" ) |>
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      c( "Nominal test:" ) |>
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      if (attr( clm1,"class") == "try-error" )
      {
        "Nominal test not computable" -> output ; 
      } else
      { nominal_test.perso( clm1, formula1, data.clm, weights ) |>
          setNames(  c( "Predictors", "Df", "logLik", "AIC", "LRT", "Pr(>Chi)" ) ) |>
          (function(x) data.frame( "logLik" = IFELSE( is.null(round),
                                                      x[,"logLik"],
                                                      round( x[,"logLik"], round) ),
                                   "AIC" = IFELSE( is.null(round),
                                                   x[,"AIC"],
                                                   round( x[,"AIC"], round) ),
                                   "LRT" = IFELSE( is.null(round),
                                                   x[,"LRT"],
                                                   round( x[,"LRT"], round) ),
                                   "Pr(>Chi)" = IFELSE( is.null( pvalue.round ),
                                                        x[,"Pr(>Chi)"],
                                                        p.round( x[,"Pr(>Chi)"], pvalue.round ) ) )
          )() |>
          (function(x) rbind( colnames(x), x ) )() |>
          (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      }
      
      "" |> (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      "/////////////////////////////////////////////////////" |>
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
    }
    
    if ( !FULL & ANODE )
    {
      # Anova
      m1 |>
        car::Anova(  type = 3) |>
        as.data.frame() |>
        (function(x) cbind( Predictors = rownames(x), x ) )() |>
        (function(x) data.frame( Predictors = x$Predictors,
                                 `LR Chisq` =  IFELSE( is.null( round ),
                                                       x$`LR Chisq`,
                                                       round( x$`LR Chisq`, round ) ),
                                 `Chisq Df` = x$Df,
                                 `Residual Df` = m1$df.residual,
                                 `--` = "",
                                 `Pr(>Chisq)` =  IFELSE( is.null( pvalue.round ),
                                                         x$`Pr(>Chisq)`,
                                                         p.round( x$`Pr(>Chisq)`, pvalue.round ) ) ) )() |>
        cbind(   `Cohen's f-squared on pseudo-R-squared` =  IFELSE( is.null( round ),
                                                                    cohen.f2( m1, TRUE ),
                                                                    round( cohen.f2( m1, TRUE ),
                                                                           round ) ) ) |>
        cbind( 
          `--` = "",
          AIC = IFELSE( is.null( round ),
                        AIC( m1 ),
                        round( AIC( m1 ), round ) )) ->
        anova1 ;
      
      # fusion anova and CI
      c( confint1[1,],
         colnames(anova1)[-1] ) |>
        matrix(  nrow = 1 ) ->
        tmp.anova ;
      
      for ( a in as.character(anova1$Predictors) )
      {
        confint1[grep( a, confint1[,1] ) , ] -> tmp.ci1
        
        anova1[grep( a, anova1[,1] ) , ] -> tmp.anova1
        
        if ( !grepl( ":", a ) )
        {
          if ( length( grep( ":", tmp.ci1[,1] ) ) > 0 )
          {
            tmp.ci1[ -grep( ":", tmp.ci1[,1] ) , ] -> tmp.ci1
            
            tmp.anova1[ -grep( ":",
                               as.character( tmp.anova1[,1] )
            ),  ] ->
              tmp.anova1
          }
        }
        
        if ( grepl( ":", a ) )
        {
          strsplit( a, ":" ) |>
            unlist() ->
            sub.names.interaction
          
          confint1 -> tmp.ci1
          for ( b in sub.names.interaction )
          {
            tmp.ci1[grep( b, tmp.ci1[,1] ) , ] -> tmp.ci1
          }
        }
        
        cbind.force( tmp.ci1,
                     tmp.anova1[, -1 ],
                     empty = "" ) |>
          (function(x)  rbind.force( tmp.anova,
                                     x,
                                     empty = "" ) )() ->
          tmp.anova ;
      }
      
      # Extraction
      lapply( 1:length(selected.predictors),
              function(a){
                tmp.anova[ grep( selected.predictors[a],  tmp.anova[,1] ), ] } ) |>
        (function(x) rbind.force( tmp.anova[1,], x, empty = "" ) )() |>
        unique() ->
        results.tab ;
    }
    
    if ( !FULL & !ANODE )
    {
      # Compute output
      summary1 |>
        coef() |>
        as.data.frame() |>
        (function(x) data.frame( `Std. Error` =  IFELSE( is.null( round ),
                                                         x$`Std. Error`,
                                                         round( x$`Std. Error`, round ) ),
                                 `--` = "",
                                 `z value` =  IFELSE( is.null( round ),
                                                      x$Value / x$`Std. Error`,
                                                      round( x$Value / x$`Std. Error`, round ) ),
                                 `Pr(>|z|)` =  IFELSE( is.null( pvalue.round ),
                                                       pnorm( abs( x$Value / x$`Std. Error` ),
                                                              lower.tail = FALSE ) * 2,
                                                       p.round( pnorm( abs( x$Value / x$`Std. Error` ),
                                                                       lower.tail = FALSE ) * 2,
                                                                pvalue.round ) ) ) )() |>
        (function(x) rbind.force( colnames(x), x) )()  |>
        (function(x)  cbind( confint1, x ) )()  ->
        tmp.student ;
      
      # Extraction
      lapply( 1:length(selected.predictors),
              function(a){
                tmp.student[ grep( selected.predictors[a],  tmp.student[,1] ), ]
              } ) |>
        (function(x)  rbind.force( tmp.student[1,], x, empty = "" ) )() |>
        unique() ->
        results.tab ;
    }
    
    
    # output
    NULL -> rownames( results.tab ) ;
    NULL -> colnames( results.tab ) ;
    
    list( model = m1, results.tab = results.tab  ) ->
      output ;
    
    return( output )
  }
  
  Lm.Plot <- function( model, ExportName )
  {
    # Pair graphics on variables
    pairs2( subset( model$model, select = 1),
            subset( model$model, select = -1),
            ExportName, 3 )
    
    # Terms plot
    if ( length( attr( terms(model),"term.labels") ) < 7 &
         all( !grepl( ":", attr( terms(model),"term.labels") ) ) )
    {
      termplot2.w(model, ExportName )
    }
    
    # Normality Study
    png( paste( ExportName,
                "Normality_Study_of_Studendized_Residuals",
                ".png",
                sep = "" ) )
    MASS::studres( model ) |> Normality.Plot.Unique(  "Studendized Residuals") ;
    dev.off() ;
    
    # Residuals vs IV
    residualPlots2.w( model, ExportName ) ;
    
    # Added variables plot
    avPlots2.w( model, ExportName ) ;
    
    # Residuals vs Fitted
    png( paste( ExportName,
                "Residuals_vs_Fitted",
                ".png",
                sep = "" ),
         width = 270,
         height = 600 )
    par( mfrow = c( 3, 1), oma = c( 0, 0, 2, 0) )
    plot( model , c(1), ask = FALSE, sub.caption = "")
    car::residualPlot( model, type = "rstandard", col.quad = "red",
                       ylab = "Standardized reisudals",
                       main = "Standardized residual vs Fitted")
    plot( model , c(3), ask = FALSE, sub.caption = "")
    mtext( text =  "Residuals vs Fitted Graphics",
           outer = TRUE, cex = 1.5 ) ;
    dev.off() ;
    
    # Component + residuals  plot
    if ( all( !grepl( ":", attr( terms(model),"term.labels") ) ) )
    {
      crPlots2.w( model, ExportName )
    }
    
    #  Cook's distance and Leverage graphics
    png( paste( ExportName,
                "Cooksdistance_and_Leverage_Graphics",
                ".png",
                sep = "" ),
         width = 270,
         height = 600 )
    par( mfrow = c( 3, 1), oma = c( 0, 0, 2, 0) )
    plot( model , c(5:6), ask = FALSE, sub.caption = "")
    dotchart( sort( sort( cooks.distance( model ), decreasing = T )[1:15] ),
              main = "Top 15 Cook's distances",
              xlab = "Cook distance",
              sub = paste( "cutoff:",
                           round( 4 / (length( cooks.distance( model ) ) ), 2 ) ) )
    abline( v = 4 / (nrow( model$model ) ),
            col = "red" )
    mtext( text =  "Cook's distance and Leverage Graphics",
           outer = TRUE, cex = 1.2 ) ;
    dev.off() ;
    
    # Influences graphics
    png( paste( ExportName,
                "Influence_Plots",
                ".png",
                sep = "" ) )
    car::infIndexPlot( model, main =  "Influence Index Plot" )
    dev.off() ;
  }
  
  Glm.Plot <- function( model, ExportName )
  {
    # Pair graphics on variables
    data.frame( model$fitted.values ) |>
      magrittr::set_colnames( paste( "fitted.LogOR",
                                     as.character( terms(model) )[2],
                                     sep = ".")  ) |>
      pairs2( 
        subset( model$model, select = -1),
        ExportName, 7 )
    
    # Terms plot
    if ( length( attr( terms(model),"term.labels") ) < 7 &
         all( !grepl( ":", attr( terms(model),"term.labels") ) ) )
    {
      termplot2.w(model, ExportName )
    }
    
    # Added variables plot
    model |> avPlots2.w( ExportName ) ;
    
    # Component + residuals  plot
    if ( all( !grepl( ":", attr( terms(model),"term.labels") ) ) )
    {
      crPlots2.w( model, ExportName  )
    }
    
    # Residuals vs Fitted
    png( paste( ExportName,
                "Residuals_vs_Fitted",
                ".png",
                sep = "" ),
         width = 270,
         height = 600 )
    par( mfrow = c( 3, 1), oma = c( 0, 0, 2, 0) )
    plot( model , c(1), ask = FALSE, sub.caption = "")
    car::residualPlot( model, col.quad = "red")
    plot( model$fitted.values,
          sqrt( abs( residuals( model, type = "pearson" ) ) ),
          ylab = "sqrt( | Pearson's reisduals | )",
          xlab =  "Fitted values",
          main = "Scale-Location"
    )
    car::loessLine( model$fitted.values,
                    sqrt( abs( residuals( model, type = "pearson" ) ) ),
                    col = "red" )
    mtext( text =  "Residuals vs Fitted Graphics",
           outer = TRUE, cex = 1.5 ) ;
    dev.off() ;
    
    #  Cook's distance and Leverage graphics
    png( paste( ExportName,
                "Cooksdistance_and_Leverage_Graphics",
                ".png",
                sep = "" ),
         width = 270,
         height = 600 )
    par( mfrow = c( 3, 1), oma = c( 0, 0, 2, 0) )
    plot( model , c(5:6), ask = FALSE, sub.caption = "")
    dotchart( sort( sort( cooks.distance( model ), decreasing = T )[1:15] ),
              main = "Top 15 Cook's distances",
              xlab = "Cook distance",
              sub = paste( "cutoff:",
                           round( 4 / (length( cooks.distance( model ) ) ), 2 ) ) )
    abline( v = 4 / (length( cooks.distance( model ) ) ),
            col = "red" )
    mtext( text =  "Cook's distance and Leverage Graphics",
           outer = TRUE, cex = 1.2 ) ;
    dev.off() ;
    
    # Influences graphics
    png( paste( ExportName,
                "Influence_Plots",
                ".png",
                sep = "" ) )
    car::infIndexPlot( model )
    dev.off() ;
  }
  
  Multinom.Plot <- function( model, data, ExportName )
  {
    # Pair graphics on variables
    attr( terms( model ),"term.labels" ) -> Vars
    
    data.frame( model$fitted.values ) |>
      (function(x) magrittr::set_colnames( x, paste( "fitted.LogOR",
                                                     colnames(x),
                                                     sep = ".")  ) )() |>
      pairs2(
        data.frame(
          subset( data,
                  select = Vars[
                    !( Vars  %in% Vars[ grep( ":", Vars ) ] ) ] )),
        ExportName, 2 )
    
    # Residuals vs Fitted
    model$fitted.values |>
      as.data.frame() |>
      tidyr::gather( key = Levels, value = Fitted  ) ->
      Fitted1 ;
    
    model$residuals |>
      as.data.frame() |>
      tidyr::gather( key = levels1, value = Residuals  ) |>
      dplyr::select( -levels1 ) ->
      Resid1 ;
    
    cbind( Fitted1, Resid1 ) |>
      ggplot() +
      geom_point( aes( x = Fitted, y = Residuals ) ) +
      facet_grid( . ~ Levels, scales = "free" ) +
      labs( title = "Residuals vs Fitted for cumulative link models" ) ->
      g1 ;
    
    paste( ExportName,
           "Residuals_vs_Fitted",
           ".png",
           sep = "" ) |>
      ggsave( g1, width = 8, height = 3 ) ;
  }
  
  Ordinal.Plot <- function( model, ExportName )
  {
    # Pair graphics on variables
    data.frame( model$fitted.values ) |>
      (function(x) magrittr::set_colnames( x, paste( "fitted.LogOR",
                                                     colnames(x),
                                                     sep = ".")  ) )() |>
      pairs2(
        subset( model$model, select = -1),
        ExportName, 2 )
    
    # Residuals vs Fitted
    model$fitted.values |>
      as.data.frame() |>
      tidyr::gather( key = Levels, value = Fitted  ) ->
      Fitted1 ;
    
    model |>
      residuals.polr() |>
      as.data.frame() |>
      tidyr::gather( key = levels1, value = Residuals  ) |>
      dplyr::select( -levels1 ) ->
      Resid1 ;
    
    cbind( Fitted1, Resid1 ) |>
      ggplot() +
      geom_point( aes( x = Fitted, y = Residuals ) ) +
      facet_grid( . ~ Levels, scales = "free" ) +
      labs( title = "Residuals vs Fitted for the cumulative link models" ) ->
      g1 ;
    
    paste( ExportName,
           "Residuals_vs_Fitted",
           ".png",
           sep = "" ) |>
      ggsave( g1, width = 8, height = 3 ) ;
  }
  
  fun.a <- function( a )
  {
    
    lapply( 1:length( changing.predictors ),
            fun.b,
            a = a
    ) |>
      rbind.force(
        empty = "" ) ->
      output.a
    
    return( output.a )
  }
  
  fun.a.parallel <- function( a )
  {
    
    furrr::future_map( 1:length( changing.predictors ),
                       fun.b,
                       a = a,
                       .options = furrr::furrr_options(seed = TRUE), .progress = T 
    ) |>
      rbind.force(
        empty = "" ) ->
      output.a
    
    return( output.a )
  }
  
  fun.b <- function( b, a )
  {
    # print( "a : ") ;  print( a ); print( "b : ") ; print(b)
    # Prepare base name for graphics
    paste0( ExportName,
            families[a], "_",
            outcomes[[a]],
            "_Model_",
            b,
            "_"
    ) -> BasePlotName ;
    
    # Do job selecting modeling family
    if ( families[a] == "gaussian" )
    {
      Lm.Analysis(  outcome = outcomes[[a]],
                    predictors = c( changing.predictors[[b]],
                                    fixed.predictors ),
                    data = data,
                    na.omit = na.omit,
                    FULL = FULL,
                    selected.predictors = changing.predictors[[b]],
                    ANOVA = ANOVA.ANODE ) ->
        tmp.output
      
      if ( PLOT )
      {
        Lm.Plot( tmp.output$model,
                 BasePlotName )
      }
    }
    
    if ( families[a] %in%  c( "binomial", "poisson", "quasibinomial", "quasipoisson" ) )
    {
      Glm.Analysis(  outcome = outcomes[[a]],
                     predictors = c( changing.predictors[[b]],
                                     fixed.predictors ),
                     family = families[a],
                     data = data,
                     na.omit = na.omit,
                     FULL = FULL,
                     selected.predictors = changing.predictors[[b]],
                     ANODE = ANOVA.ANODE ) ->
        tmp.output
      
      if ( PLOT )
      {
        Glm.Plot( tmp.output$model,
                  BasePlotName )
      }
    }
    
    if ( families[a] == "multinomial" )
    {
      Multinom.Analysis(  outcome = outcomes[[a]],
                          predictors = c( changing.predictors[[b]],
                                          fixed.predictors ),
                          data = data,
                          HMF.test = HMF.test,
                          na.omit = na.omit,
                          FULL = FULL,
                          selected.predictors = changing.predictors[[b]],
                          ANODE = ANOVA.ANODE ) ->
        tmp.output
      
      if ( PLOT )
      {
        Multinom.Plot( tmp.output$model,
                       data = data,
                       BasePlotName )
      }
    }
    
    if ( families[a] == "ordinal" )
    {
      Ordinal.Analysis(  outcome = outcomes[[a]],
                         predictors = c( changing.predictors[[b]],
                                         fixed.predictors ),
                         data = data,
                         na.omit = na.omit,
                         FULL = FULL,
                         selected.predictors = changing.predictors[[b]],
                         ANODE = ANOVA.ANODE ) ->
        tmp.output
      
      if ( PLOT )
      {
        Ordinal.Plot( tmp.output$model,
                      BasePlotName )
      }
    }
    
    # output
    tmp.output$results.tab -> output.b ;
    
    cbind( Outcome = outcomes[[a]],
           Families = families[a],
           Predictors = String.Contatener( c( changing.predictors[[b]],
                                              fixed.predictors),
                                           separator = "." ),
           output.b ) ->
      output.b ;
    
    return( output.b )
  }
  
  # Active Packages
  download.packages( "furrr", "nnet", "MASS", "ordinal",
                     "MuMIn", "car",
                     "heplots", "lmtest", "mfp",
                     "moments", "nortest", "dplyr", "tidyr", "magrittr",
                     "ggplot2", "mlogit", "dfidx", "brant", "VisCollin",
                     "mctest", "ggplot2" )
  
  require( ggplot2 )
  
  # NA 
  if ( na.omit == TRUE ) { na.omit( cbind( data, weights ) ) -> data ;
    data[, "weights"] -> weights ; 
    data[ , 1:(ncol(data)- 1)] -> data ; 
  }
  
  
  # job
  if ( parallel.outcomes )
  {
    furrr::future_map(
      1:length( outcomes  ), 
      fun.a,
      .options = furrr::furrr_options(seed = TRUE), .progress = T 
    ) |>
      rbind.force( 
        empty = "" ) -> 
      output ;
  }
  else
  {
    purrr::map(
      1:length( outcomes  ), 
      fun.a.parallel
    ) |>
      rbind.force( 
        empty = "" ) -> 
      output ;
  }
  
  # end parallel
  future::plan("sequential")
  
  # Output
  return( output )
}

# 1.4.2 Function to test difference with references 
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

UnivariateVsReferences <- function(
    x,
    references,
    na.rm = TRUE,
    Continuity.correct = TRUE,
    multinomial.exact = FALSE,
    nsim = 2000,
    pvalue.round = 3,
    round = 2,
    ncores = NULL
)
{
  
  # Input condition
  #================
  if ( !is.data.frame( x ) ) { stop( "x is not a data.frame" ) ; } 
  if ( tibble::is_tibble( x ) ) { data.frame( x ) -> x ; } 
  if ( !is.list( references ) ) { stop( "references is not a list" ) ; } 
  if ( !is.logical( na.rm ) ) { stop( "na.rm is not TRUE or FALSE" ) ; } 
  if ( !is.logical( Continuity.correct ) ) { stop( "Continuity.correct is not TRUE or FALSE" ) ; } 
  if ( !is.logical( multinomial.exact ) ) { stop( "multinomial.exact is not TRUE or FALSE" ) ; } 
  if ( !is.numeric( pvalue.round ) & !is.null( pvalue.round) ) { stop( "pvalue.round is neither numeric, neither NULL" ) ; } 
  if ( !is.numeric( round ) & !is.null( round) ) { stop( "round is neither numeric, neither NULL" ) ; } 
  if ( !is.null(ncores) & !is.numeric(ncores) ) { stop( "ncores is not null nor numeric" ) }
  
  # parallel
  if ( !is.null( ncores ) ) { future::plan( "multisession",  workers = ncores ) }
  
  # Domestic functions
  #===================
  download.packages <- function( PackagesNames, ... )
  {
    # Get a vector with packages names 
    packages1 <- c( PackagesNames, ... ) ;
    
    # Install packages
    for (a in 1:length( packages1 ) )
    {
      try( find.package( packages1[a]), silent = TRUE ) -> test ;
      
      if ( class( test ) == "try-error" )
      { print( packages1[a] ) ; 
        install.packages(  packages1[a] ) ;
      } 
    }
  } ;
  
  rbind.force <- function( data, ..., keep.col = FALSE, empty = "" ) 
  {
    # Unify data
    list( data, ... ) -> input ;
    
    # include list elements
    repeat 
    {
      if (  !any( unlist( lapply( input, class ) ) == "list" ) ) { break }  
      
      which( unlist( lapply( input, class ) ) == "list" )[1] -> a ;
      input[[a]] -> tmp ;
      input[[a]] <- NA ;
      c( input[1:a],  tmp, input[ (a + 1):length( input ) ] ) -> 
        input ;
    }
    
    input[ !is.na( input ) ] ->
      input ;
    
    # delete NULL data and transformt vector in data.frame
    for ( a in 1:length( input ) )
    {
      if ( is.null( dim( input[[a]] ) ) )
      {
        if ( is.null( input[[a]] ) )
        {
          input[[a]] <- NA ;
        } else
        {
          data.frame( matrix( input[[a]], nrow = 1 ),
                      stringsAsFactors = FALSE ) -> input[[a]] ; 
        }
      }
      
      if ( all( dim( input[[a]] ) == 0 ) )
      {
        input[[a]] <- NA ;
      }
    }
    
    input[ !is.na( input ) ] ->
      input ;
    
    # test data class
    if ( !all( unlist( lapply( input, is.data.frame ) ) |
               unlist( lapply( input, is.matrix ) ) |
               unlist( lapply( input, is.vector ) ) ) )
    { stop( "Some argument are not data.frame, neither vector" ) ;
      ; } ;
    
    # Set primer
    input[[1]] -> output ; 
    
    # job in case we keep columns 
    if ( keep.col & length( input ) >1 )
    {
      for ( a in 2:length( input ) )
      { 
        output -> x ;
        input[[a]] -> y ; 
        
        for (a in 1:dim(x)[2]) { x[,a] <- as.character(x[,a])}
        for (a in 1:dim(y)[2]) { y[,a] <- as.character(y[,a])}
        
        x.diff <- setdiff(colnames(x), colnames(y))
        y.diff <- setdiff(colnames(y), colnames(x))
        
        if( dim(x)[1] > 0 ) { x[, c(as.character(y.diff))] <- empty ; }
        if( dim(y)[1] > 0 ) { y[, c(as.character(x.diff))] <- empty ; }
        
        rbind(x, y) -> output ;
      } 
    }
    
    # job in case we do not keep columns
    if ( !keep.col & length( input ) >1 )
    {
      for ( a in 2:length( input ) )
      { 
        output -> x ;
        input[[a]] -> y ; 
        
        colnames(x) <- paste( "X",
                              1:dim( x )[2], 
                              sep = "" ) ;
        colnames(y) <- paste( "X",
                              1:dim( y )[2], 
                              sep = "" ) ;
        
        for (a in 1:dim(x)[2]) { x[,a] <- as.character(x[,a])}
        for (a in 1:dim(y)[2]) { y[,a] <- as.character(y[,a])}
        
        x.diff <- setdiff(colnames(x), colnames(y))
        y.diff <- setdiff(colnames(y), colnames(x))
        
        if( dim(x)[1] > 0 ) { x[, c(as.character(y.diff))] <- empty ; }
        if( dim(y)[1] > 0 ) { y[, c(as.character(x.diff))] <- empty ; }
        
        rbind(x, y) -> output ;
      } 
    }
    
    return( output ) ;
  } 
  
  p.round <- function( data, digits = 3 )
  {
    if (digits == 1)
    { "" -> tmp1 ; } else 
    { rep( "0", digits - 1 ) -> tmp1 ; }
    
    "0." -> tmp2 ;
    for( a in 1:length(tmp1) )
    {
      paste( tmp2, tmp1[a], sep = "" ) -> tmp2 ;
    }
    
    paste( tmp2, "1", sep = "" ) -> pval ;
    
    for ( a in 1:length(data) )
    {
      if ( !is.na( data[a] ) )
      {
        if ( data[a] >= as.numeric( pval ) )
        {
          round( data[a], digits = digits ) -> data[a] ;
        }
      }
    }
    
    data[ data < as.numeric( pval ) ] <- paste( "< ", pval, sep = "" ) ;
    
    return( data ) ;
  }
  
  quiet <- function(f) 
  {
    sink( tempfile() )
    on.exit( sink() )
    invisible( force(f) )
  }
  
  check.references <- function( x, references )
  {
    fun.check <- function( a )
    {
      NULL -> output.check ; 
      
      if ( is.numeric( x[,a] ) )
      { 
        length( references[[a]] ) == 2 & 
          is.numeric( references[[a]] ) -> 
          output.check ; 
      }
      
      if ( is.factor( x[,a] ) )
      { 
        length( references[[a]] ) == nlevels( 
          factor( na.omit( x[,a] ) ) ) & 
          is.numeric( references[[a]] ) -> 
          output.check ; 
      } 
      
      if ( is.null( output.check ) )
      { all( is.na( references[[a]]  ) ) ->  output.check ; }
      
      if ( !output.check )
      { cat( paste0( "Error in references for: ", colnames(x)[a], "\n" ) ) }
      
      return( output.check )
    }
    
    purrr::map_lgl( 1:ncol(x), fun.check ) |>
      all()
  }
  
  fun.a <- function( a )
  {
    #print(a) ;
    # fusion of var
    x[,a]  -> variable ;
    references[[a]] -> ref ;
    
    # clean NA
    if ( na.rm )
    {
      na.omit( variable ) -> variable ;
      
      if ( is.factor( x[,a] ) ) { factor( variable ) -> variable ; }
    }
    
    # primer
    NULL -> output.a
    
    # job
    # factor
    if ( is.factor( variable ) &
         length( variable ) > 4 &
         nlevels( variable ) > 1 &
         all( table( variable ) > 2 )
    )
    {
      # calculate
      quiet(
        EMT::multinomial.test( 
          as.numeric( ftable( variable ) ), 
          ref, 
          MonteCarlo = !multinomial.exact, ntrial = nsim,
        ) ) ->
        multinom1 ; 
      
      chisq.test( ftable( variable ), p = ref ) ->
        chisq1 ; 
      
      DescTools::GTest( ftable( variable ), p = ref ) -> 
        gtest1 ; 
      
      if ( nlevels( variable ) == 2 )
      {
        prop.test(
          x = ftable( variable )[1], 
          n = length( variable ), 
          p = ref[1],
          correct = Continuity.correct 
        ) -> 
          prop1 ;
        
        binom.test( ftable( variable), p = ref[1] ) ->
          binom1 ;
      } else
      {
        list( 
          method = "Not applicable",
          statistic = NA,
          parameter = NA,
          p.value = NA
        ) ->
          prop1 ;
        
        list( 
          method = "Not applicable",
          statistic = NA,
          parameter = NA,
          p.value = NA
        ) ->
          binom1 ;
      }
      
      # fusion
      c(
        "factor",
        colnames( x )[a],
        purrr::reduce( paste0( "p = ", 1:length(ref), " ", ref, " ; " ), 
                paste ), 
        min(chisq1$expected),
        multinom1$p.value,
        multinom1$id,
        chisq1$method,
        chisq1$statistic,
        chisq1$parameter,
        chisq1$p.value,
        gtest1$method,
        gtest1$statistic,
        gtest1$parameter,
        gtest1$p.value,
        multinom1$id,
        multinom1$p.value,
        prop1$method,
        Continuity.correct,
        prop1$statistic,
        prop1$parameter,
        prop1$p.value,
        binom1$method,
        binom1$p.value
      ) |>
        setNames(  titles.factor )  -> 
        output.a ;
      
      # round
      if( !is.null( round ) )
      {
        for ( round.a in c( 
          "Chi-squared test statistic",
          "Chi-squared test degree of freedom",
          "G-test statistic",
          "G-test degree of freedom",
          "Proportions test statistic",
          "Proportions test degree of freedom"
        ) )
        {
          round( as.numeric( as.character( output.a[ round.a ] ) ), 
                 digits = round ) ->
            output.a[ round.a ] ; 
        }
      }
      
      if( !is.null( pvalue.round ) )
      {
        for ( pround.a in c( 
          names( output.a )[ grep( "p-value", names( output.a ) ) ]
        ) )
        {
          p.round( as.numeric( output.a[ which( names( output.a ) == 
                                                  pround.a ) ] ),
                   digits = pvalue.round ) ->
            output.a[ which( names( output.a ) == pround.a ) ] ; 
        }
      }
      
    }
    
    # numeric
    if ( is.numeric( variable ) &
         length( variable ) > 4 &
         nlevels( factor( variable ) ) > 2 
    )
    {
      # calculate
      if ( length( variable ) < 5000 ) 
      { shapiro.test( variable ) -> shapiro ; }  else
      { list( "p.value" = NA ) -> shapiro ; }
      nortest::ad.test( variable) -> anderson ;
      moments::jarque.test( as.vector( variable ) ) -> jarque ;
      if ( any( c( shapiro$p.value, anderson$p.value, jarque$p.value ) < 0.05 ) ) 
      { FALSE -> normal ; } else { TRUE -> normal } 
      
      
      wilcox.test( variable, mu = ref[1], correct = Continuity.correct ) ->
        wilcox1; 
      
      t.test( variable,  mu = ref[1] ) -> 
        ttest1 ;
      
      asympTest::asymp.test( variable, reference = ref[1], parameter = "mean" ) ->
        asymMean1
      
      DescTools::SignTest( variable, mu = ref[1] ) ->
        sign1 ;
      
      DescTools::VarTest( variable, sigma.squared = ref[2] ) ->
        vartest1 ;
      
      if ( length(vartest1$p.value) == 0 ) { "Not computable" -> vartest1$p.value }
      
      asympTest::asymp.test( variable, reference = ref[2], parameter = "var" ) ->
        asymVar1 ;
      
      # fusion
      c(
        "numeric",
        colnames( x )[a],
        paste0( "m = ", ref[1], " ; var = ", ref[2] ),
        normal,
        asymMean1$p.value,
        asymMean1$method,
        ttest1$method,
        ttest1$statistic,
        ttest1$parameter,
        ttest1$p.value,
        wilcox1$method,
        Continuity.correct,
        wilcox1$statistic,
        wilcox1$p.value,
        sign1$method,
        sign1$statistic,
        sign1$parameter,
        sign1$p.value,
        asymMean1$method,
        asymMean1$statistic,
        asymMean1$p.value,
        vartest1$method,
        vartest1$statistic,
        vartest1$parameter,
        vartest1$p.value,
        asymVar1$method,
        asymVar1$statistic,
        asymVar1$p.value,
        shapiro$p.value,
        anderson$p.value,
        jarque$p.value
      )  |>
        setNames(  titles.numeric )  -> 
        output.a ;
      
      # round
      if( !is.null( round ) )
      {
        for ( round.a in c(  
          "T-test statistic",
          "T-test parameter",
          "Wilcoxon signed rank test statistic",
          "Sign test statistic",
          "Sign test number of differences",
          "Asymptotic mean test statistic",
          "Chi-Square test on variance statistic",
          "Chi-Square test on variance degree of freedom",
          "Asymptotic variance test statistic"
        ) )
        {
          round( as.numeric( as.character( output.a[ round.a ] ) ), 
                 digits = round ) ->
            output.a[ round.a ] ; 
        }
      }
      
      if( !is.null( pvalue.round ) )
      {
        for ( pround.a in c( 
          names( output.a )[ grep( "p-value", names( output.a ) ) ]
        ) )
        {
          p.round( as.numeric( output.a[ which( names( output.a ) == 
                                                  pround.a ) ] ),
                   digits = pvalue.round ) ->
            output.a[ which( names( output.a ) == pround.a ) ] ; 
        }
      }
      
    }
    
    # other
    if ( is.null( output.a ) )
    {
      !is.numeric( variable ) & !is.factor( variable ) -> Num.Fact ;
      length( variable ) < 5 -> Less5 ;
      
      if ( is.factor( variable ) )
      {
        nlevels( variable ) > 1 -> f.less2lvls ;
        all( table( variable ) > 2 ) -> f.less3var ;
      } else
      {
        NA -> f.less2lvls ;
        NA -> f.less3var ;
      }
      
      if ( is.numeric( variable ) )
      {
        nlevels( factor( variable ) ) > 2  -> n.less3 ;
      } else
      {
        NA -> n.less3 ;
      }
      
      c(
        "other",
        colnames( x )[a],
        class( variable ), 
        Num.Fact,
        Less5,
        f.less2lvls,
        f.less3var,
        n.less3
      ) -> 
        output.a ;
    }
    
    # output
    return( output.a )
  }
  
  # Prepare titles 
  #===============
  c(
    "class",
    "Var",
    "References",
    "Normality",
    "p-value",
    "Method",
    "T-test method",
    "T-test statistic",
    "T-test parameter",
    "T-test p-value",
    "Wilcoxon signed rank test method",
    "Continuity correction",
    "Wilcoxon signed rank test statistic",
    "Wilcoxon signed rank test p-value",
    "Sign test method",
    "Sign test statistic",
    "Sign test number of differences",
    "Sign test p-value",
    "Asymptotic mean test method",
    "Asymptotic mean test statistic",
    "Asymptotic mean test p-value",
    "Chi-Square test on variance method",
    "Chi-Square test on variance statistic",
    "Chi-Square test on variance degree of freedom",
    "Chi-Square test on variance p-value",
    "Asymptotic variance test method",
    "Asymptotic variance test statistic",
    "Asymptotic variance test p-value",
    "Shapiro p-value",
    "Anderson-Darling p-value",
    "Jarque-Bera p-value"
  ) -> titles.numeric ; 
  
  c(
    "class",
    "Var",
    "References",
    "Minimal expected number",
    "p-value",
    "Method",
    "Chi-squared test method",
    "Chi-squared test statistic",
    "Chi-squared test degree of freedom",
    "Chi-squared test p-value",
    "G-test method",
    "G-test statistic",
    "G-test degree of freedom",
    "G-test p-value",
    "Exact Multinomial test method",
    "Exact Multinomial test p-value",
    "Proportions test method",
    "Continuity correction",
    "Proportions test statistic",
    "Proportions test degree of freedom",
    "Proportions test p-value",
    "Exact binomial test method",
    "Exact binomial test p-value"
  ) -> titles.factor ; 
  
  c(
    "class",
    "Var",
    "Class",
    "Not factor or numeric",
    "Less than 5 observations",
    "Factor: less than 2 levels",
    "Factor: less than 3 observations by levels",
    "Numeric: less than 3 different observations"
  ) -> titles.other ; 
  
  # Load packages 
  #==============
  download.packages(  "furrr", "dplyr", "DescTools", "EMT", "asympTest",
                      "moments", "nortest", "purrr" )
  
  # Job
  #====
  # Check references
  cat( "references must be in this form: references = list( c( m, var ), NA, c( p1, p2, ..., pi ), c( m, var ), c( p1, p2 ), ... )\n\n")
  
  if ( !check.references( x, references ) ) 
  { stop( "references are not ok") ; }
  
  # calculate
  furrr::future_map( 
    1:ncol( x ), 
    fun.a, 
    .options = furrr::furrr_options(seed = TRUE), .progress = T 
  ) |> 
    rbind.force() ->
    output ;
  
  # prepare output
  rbind.force( 
    titles.numeric,
    output[ grep( "numeric", output[,1] ), ],
    titles.factor,
    output[ grepl( "factor", output[,1] ), ],
    titles.other,
    output[ grepl( "other", output[,1] ), ]
  ) |>
    (function(x) setNames(x,
                          c("class",
                            "Var",
                            "References",
                            paste0( "col", 4:ncol(x) ) )
    ) )() ->
    output ;
  
  # end parallel
  future::plan("sequential")
  
  # Output
  #=======
  
  return( output )
}
# 1.4.3 Bivariate analysis paired data
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Bivariate.Analysis.Repeated.OnTimes <- function( data, 
                                                 group, 
                                                 identifier,
                                                 na.rm = TRUE,
                                                 conf.level = 0.95,
                                                 binom.ci.method = "exact",
                                                 Continuity.correct = TRUE,
                                                 nsim = 10000, 
                                                 seed = 123,
                                                 pvalue.round = 3,
                                                 round = 2,
                                                 ncores = NULL )

{ 
  # Conditions for input
  if ( !is.data.frame( data ) ) { stop( "data is not a data.frame" );  } ;
  if ( !is.character( group ) ) { stop( "groups is not character" );   } ;
  if ( !is.character( identifier ) ) { stop( "identifier is not character" );   } ;
  if ( !is.logical( na.rm ) ) { stop( "na.rm is not TRUE or FALSE" );   } ;
  if ( !is.numeric( conf.level ) ) { stop( "conf.level is not numeric" );   } ;
  if ( !is.character( binom.ci.method ) ) { stop( "binom.ci.method is not character" );   } ;
  if ( !is.logical( Continuity.correct ) ) { stop( "Continuity.correct is not TRUE or FALSE" );   } ;
  if ( !is.double( nsim ) ) { stop( "nsim is not double" );   } ;
  if ( !is.double( seed ) ) { stop( "seed is not double" );   } ;
  if ( !( is.numeric( pvalue.round ) | 
          is.null( pvalue.round ) ) ) { stop( "pvalue.round is neither numeric, neither NULL" );    } ;
  if ( !( is.numeric( round ) | 
          is.null( round ) ) ) { stop( "round is neither numeric, neither NULL" );    } ;
  if ( !is.null(ncores) & !is.numeric(ncores) ) { stop( "ncores is not null nor numeric" ) }
  
  if ( !(group %in% colnames( data ) ) ) { stop(  "group is not in data"  );   } ;
  if ( !(identifier %in% colnames( data ) ) ) { stop(  "identifier is not in data"  );   } ;
  
  # parallel
  if ( !is.null( ncores ) ) { future::plan( "multisession",  workers = ncores ) }
  
  
  # function definition
  download.packages <- function( PackagesNames, ... )
  {
    # Get a vector with packages names 
    packages1 <- c( PackagesNames, ... ) ;
    
    # Install packages
    for (a in 1:length( packages1 ) )
    {
      try( find.package( packages1[a]), silent = TRUE ) -> test ;
      
      if ( class( test ) == "try-error" )
      { print( packages1[a] ) ; 
        install.packages(  packages1[a] ) ;
      } 
    }
  } ;
  
  rbind.force <- function( data, ..., keep.col = FALSE, empty = NA ) 
  {
    # Unify data
    list( data, ... ) -> input ;
    
    # include list elements
    repeat 
    {
      if (  !any( unlist( lapply( input, class ) ) == "list" ) ) { break }  
      
      which( unlist( lapply( input, class ) ) == "list" )[1] -> a ;
      input[[a]] -> tmp ;
      input[[a]] <- NA ;
      c( input[1:a],  tmp, input[ (a + 1):length( input ) ] ) -> 
        input ;
    }
    
    input[ !is.na( input ) ] ->
      input ;
    
    # delete NULL data and transformt vector in data.frame
    for ( a in 1:length( input ) )
    {
      if ( is.null( dim( input[[a]] ) ) )
      {
        if ( is.null( input[[a]] ) )
        {
          input[[a]] <- NA ;
        } else
        {
          data.frame( matrix( input[[a]], nrow = 1 ),
                      stringsAsFactors = FALSE ) -> input[[a]] ; 
        }
      }
      
      if ( all( dim( input[[a]] ) == 0 ) )
      {
        input[[a]] <- NA ;
      }
    }
    
    input[ !is.na( input ) ] ->
      input ;
    
    # test data class
    if ( !all( unlist( lapply( input, is.data.frame ) ) |
               unlist( lapply( input, is.matrix ) ) |
               unlist( lapply( input, is.vector ) ) ) )
    { stop( "Some argument are not data.frame, neither vector" ) ;
      ; } ;
    
    # Set primer
    input[[1]] -> output ; 
    
    # job in case we keep columns 
    if ( keep.col & length( input ) >1 )
    {
      for ( a in 2:length( input ) )
      { 
        output -> x ;
        input[[a]] -> y ; 
        
        for (a in 1:dim(x)[2]) { x[,a] <- as.character(x[,a])}
        for (a in 1:dim(y)[2]) { y[,a] <- as.character(y[,a])}
        
        x.diff <- setdiff(colnames(x), colnames(y))
        y.diff <- setdiff(colnames(y), colnames(x))
        
        if( dim(x)[1] > 0 ) { x[, c(as.character(y.diff))] <- empty ; }
        if( dim(y)[1] > 0 ) { y[, c(as.character(x.diff))] <- empty ; }
        
        rbind(x, y) -> output ;
      } 
    }
    
    # job in case we do not keep columns
    if ( !keep.col & length( input ) >1 )
    {
      for ( a in 2:length( input ) )
      { 
        output -> x ;
        input[[a]] -> y ; 
        
        colnames(x) <- paste( "X",
                              1:dim( x )[2], 
                              sep = "" ) ;
        colnames(y) <- paste( "X",
                              1:dim( y )[2], 
                              sep = "" ) ;
        
        for (a in 1:dim(x)[2]) { x[,a] <- as.character(x[,a])}
        for (a in 1:dim(y)[2]) { y[,a] <- as.character(y[,a])}
        
        x.diff <- setdiff(colnames(x), colnames(y))
        y.diff <- setdiff(colnames(y), colnames(x))
        
        if( dim(x)[1] > 0 ) { x[, c(as.character(y.diff))] <- empty ; }
        if( dim(y)[1] > 0 ) { y[, c(as.character(x.diff))] <- empty ; }
        
        rbind(x, y) -> output ;
      } 
    }
    
    return( output ) ;
  } 
  
  cbind.force <- function( data, ... , keep.row = FALSE, empty = NA ) 
  {
    # Unify data
    list( data, ... ) -> input ;
    
    # include list elements
    repeat 
    {
      if (  !any( unlist( lapply( input, class ) ) == "list" ) ) { break }  
      
      which( unlist( lapply( input, class ) ) == "list" )[1] -> a ;
      input[[a]] -> tmp ;
      input[[a]] <- NA ;
      c( input[1:a],  tmp, input[ (a + 1):length( input ) ] ) -> 
        input ;
    }
    
    input[ !is.na( input ) ] ->
      input ;
    
    # delete NULL data and transform vector in data.frame
    for ( a in 1:length( input ) )
    {
      if ( is.null( dim( input[[a]] ) ) )
      {
        if ( is.null( input[[a]] ) )
        {
          input[[a]] <- NA ;
        } else
        {
          data.frame( input[[a]],
                      stringsAsFactors = FALSE ) -> input[[a]] ; 
          "vector" -> colnames(  input[[a]] ) ;
        }
      }
      
      if ( all( dim( input[[a]] ) == 0 ) )
      {
        input[[a]] <- NA ;
      }
    }
    
    input[ !is.na( input ) ] ->
      input ;
    
    # test data class
    if ( !all( unlist( lapply( input, is.data.frame ) ) |
               unlist( lapply( input, is.matrix ) ) |
               unlist( lapply( input, is.vector ) ) ) )
    { stop( "Some argument are not data.frame, neither vector" ) ;
      ; } ;
    
    # Set primer
    input[[1]] -> output ; 
    
    # job in case we keep columns 
    if ( keep.row & length( input ) > 1 )
    {
      for ( a in 2:length( input ) )
      { 
        output -> x ;
        input[[a]] -> y ; 
        
        for (a in 1:dim(x)[2]) { x[,a] <- as.character(x[,a])}
        for (a in 1:dim(y)[2]) { y[,a] <- as.character(y[,a])}
        
        x.diff <- setdiff(rownames(x), rownames(y))
        y.diff <- setdiff(rownames(y), rownames(x))
        
        if( dim(x)[2] > 0 ) { x[ c(as.character(y.diff)), ] <- empty ; }
        if( dim(y)[2] > 0 ) { y[ c(as.character(x.diff)), ] <- empty ; }
        
        cbind(x, y) -> output ;
      } 
    }
    
    # job in case we do not keep columns
    if ( !keep.row & length( input ) > 1 )
    {
      for ( a in 2:length( input ) )
      { 
        output -> x ;
        input[[a]] -> y ; 
        
        rownames(x) <- paste( "X",
                              1:dim( x )[1], 
                              sep = "" ) ;
        rownames(y) <- paste( "X",
                              1:dim( y )[1], 
                              sep = "" ) ;
        
        for (a in 1:dim(x)[2]) { x[,a] <- as.character(x[,a])}
        for (a in 1:dim(y)[2]) { y[,a] <- as.character(y[,a])}
        
        x.diff <- setdiff(rownames(x), rownames(y))
        y.diff <- setdiff(rownames(y), rownames(x))
        
        if( dim(x)[2] > 0 ) { x[ c(as.character(y.diff)), ] <- empty ; }
        if( dim(y)[2] > 0 ) { y[ c(as.character(x.diff)), ] <- empty ; }
        
        cbind(x, y) -> output ;
      } 
    }
    
    return( output ) ;
  } 
  
  p.round <- function( data, digits = 3 )
  {
    if (digits == 1)
    { "" -> tmp1 ; } else 
    { rep( "0", digits - 1 ) -> tmp1 ; }
    
    "0." -> tmp2 ;
    for( a in 1:length(tmp1) )
    {
      paste( tmp2, tmp1[a], sep = "" ) -> tmp2 ;
    }
    
    paste( tmp2, "1", sep = "" ) -> pval ;
    
    for ( a in 1:length(data) )
    {
      if ( !is.na( data[a] ) )
      {
        if ( data[a] >= as.numeric( pval ) )
        {
          round( data[a], digits = digits ) -> data[a] ;
        }
      }
    }
    
    data[ data < as.numeric( pval ) ] <- paste( "< ", pval, sep = "" ) ;
    
    return( data ) ;
  }
  
  ConfusionTable.Analysis <- function( x, y, name.x = "", name.y = "",
                                       na.rm = TRUE, conf.level = conf.level,
                                       binom.ci.method = "exact",
                                       pvalue.round = pvalue.round, round = round  )
  {
    # Input condition
    if ( !is.factor( x ) ) { stop( "x is not a factor" );   } ;
    if ( !is.factor( y ) ) { stop( "y is not a factor" );   } ;
    if ( !is.character( name.x ) ) { stop( "name.x is not a factor" );   } ;
    if ( !is.character( name.y ) ) { stop( "name.y is not a factor" );   } ;
    if ( !is.logical( na.rm ) ) { stop( "na.rm is not TRUE or FALSE" );    } ;
    if ( !is.numeric( conf.level ) ) { stop( "conf.level is not numeric" );    } ;
    if ( !is.character( binom.ci.method ) ) { stop( "binom.ci.method is not a factor" );   } ;
    if ( !( is.numeric( pvalue.round ) | 
            is.null( pvalue.round ) ) ) { stop( "pvalue.round is neither numeric, neither NULL" );    } ;
    if ( !( is.numeric( round ) | 
            is.null( round ) ) ) { stop( "round is neither numeric, neither NULL" );    } ;
    
    # Domestic functions 
    ConfusionTable.Unique <- function( Reference, Prediction, 
                                       name.reference, name.prediction, 
                                       p.value )
    {
      # prepare
      table( Prediction, Reference ) -> ct ;
      
      ct[1,1] -> TP ;
      ct[2,2] -> TN ;
      ct[1,2] -> FP ;
      ct[2,1] -> FN ;
      
      TP + FN -> RP ;
      FP + TN -> RN ;
      TP + FP -> PP ;
      FN + TP -> PN ;
      
      
      TP / RP -> Se ;
      TN / RN -> Sp ;
      TP / PP -> PPV ;
      TP / PN -> NPV ;
      
      binom::binom.confint( TP, RP, 
                            conf.level = conf.level, 
                            methods = binom.ci.method )[5:6] -> 
        Se.CI ;
      binom::binom.confint( TN, RN, 
                            conf.level = conf.level, 
                            methods = binom.ci.method )[5:6] -> 
        Sp.CI ;
      binom::binom.confint( TP, PP, 
                            conf.level = conf.level, 
                            methods = binom.ci.method )[5:6] ->
        PPV.CI ;
      binom::binom.confint( TP, PN, 
                            conf.level = conf.level, 
                            methods = binom.ci.method )[5:6] -> 
        NPV.CI ;
      
      FN / RP -> FNR ;
      FP / RN -> FPR ;
      FP / PP -> FDR ;
      FN / PN -> FOR ;
      
      RP / sum( ct )  -> Pre ;
      (TP + TN) / sum( ct ) -> Acc ;
      
      Se / FPR -> PLR ;
      FNR / Sp -> NLR ;
      PLR / NLR -> DOR ;
      
      2 * TP / (2 * TP + FP + FN) -> F1 ;
      (TP * TN - FP * FN) / sqrt( (TP + FP) * (TP + FN) * (TN + FP) * (TN + FN) ) -> 
        MCC ;
      Se + Sp - 1 -> Informed ;
      PPV + NPV - 1 -> Marked ;
      
      # stock
      c( name.reference, name.prediction,
         colnames( ct )[1], colnames( ct )[2],
         Se * 100, Sp * 100, PPV * 100, NPV * 100, 
         p.value, 
         RP, RN, PP, PN,
         TP, TN, FP, FN, 
         Se * 100, Se.CI[1] * 100, Se.CI[2] * 100,
         Sp * 100, Sp.CI[1] * 100, Sp.CI[2] * 100,
         PPV * 100, PPV.CI[1] * 100, PPV.CI[2] * 100,
         NPV * 100, NPV.CI[1] * 100, NPV.CI[2] * 100,
         binom.ci.method,
         FNR * 100, FPR * 100, FDR * 100, FOR * 100,
         Pre * 100, Acc * 100,
         PLR, NLR, DOR, 
         F1, MCC, 
         Informed, Marked
      ) ->
        output ;
      
      unlist( output ) -> output ;
      
      # return 
      return( output )
    }
    
    # Load packages
    #active.packages( "coin", "binom" ) ;
    
    # Names
    if ( name.x == "" ) { name.x <- deparse( substitute( x ) ) ; }
    if ( name.y == "" ) { name.y <- deparse( substitute( y ) ) ; }
    
    # NA
    if ( na.rm ) 
    {
      na.omit( data.frame( x, y ) ) -> df ;
      df$x -> x ;
      df$y -> y ;
    } 
    
    # Format
    factor( x ) -> x ;
    factor( y ) -> y ;
    if ( nlevels( x ) != 2 ) { stop( "x has not 2 levels" );   } ;
    if ( nlevels( y ) != 2 ) { stop( "y has not 2 levels" );   } ;
    
    relevel( x, ref = levels( x )[2] ) -> xbis ;
    relevel( y, ref = levels( y )[2] ) -> ybis ;
    
    # Test
    coin::pvalue( coin::mh_test( table( x, y ), 
                                 distribution = exact() ) ) -> 
      p.value ;
    
    # Case 1
    ConfusionTable.Unique( Reference = x, 
                           Prediction = y, 
                           name.reference = name.x, 
                           name.prediction = name.y, 
                           p.value = p.value ) -> 
      case1 ;
    
    # Case 2
    ConfusionTable.Unique( Reference = y, 
                           Prediction = x, 
                           name.reference = name.y, 
                           name.prediction = name.x, 
                           p.value = p.value ) -> 
      case2 ;
    
    # Case 3
    ConfusionTable.Unique( Reference = xbis, 
                           Prediction = ybis, 
                           name.reference = name.x, 
                           name.prediction = name.y, 
                           p.value = p.value ) -> 
      case3 ;
    
    # Case 4
    ConfusionTable.Unique( Reference = ybis, 
                           Prediction = xbis, 
                           name.reference = name.y, 
                           name.prediction = name.x, 
                           p.value = p.value ) -> 
      case4 ;
    
    # fusion
    data.frame( rbind( case1, case2, case3, case4 ) ) ->
      output ;
    
    c( "Reference Condition", "Predicted Condition", "Positive", "Negative",
       "Sensitivity (%)", "Specificity (%)", 
       "Positive predictive value (%)", "Negative predictive value (%)",
       "Exact Marginal Homogeneity Test p-value",
       "Reference positive (n)", "Reference negative (n)", 
       "Prediction positive (n)", "Prediction negative (n)",
       "True positive (n)", "True negative (n)", 
       "False positive (n)", "False negative (n)",
       "Sensitivity (power, recall, hit rate, true positive rate) (%)", 
       "Se CI lb", "Se CI ub", 
       "Specificity (true negative rate) (%)",
       "Sp CI lb", "Sp CI ub", 
       "Predictive positive value (precision) (%)",
       "PPV CI lb", "PPV CI ub", 
       "Negative predictive value (%)",
       "NPV CI lb", "NPV CI ub", 
       "CI binomial method",
       "False negative rate (beta type II error,miss rate) (%)",
       "False positive rate (alpha type I error, fall-out) (%)",
       "False discovery rate (%)",
       "False omission rate (%)",
       "Prevalence (%)", 
       "Accuracy (%)",
       "Positive likelihood ratio", "Negative likelihood ratio",
       "Diagnostic odds ratio",
       "F1 score",
       "Matthews correlation coefficient (MCC)",
       "Informedness (bookmaker informedness)",
       "Markedness"
    ) -> 
      colnames( output ) ;
    
    NULL -> rownames( output ) ;
    
    # Round 
    if( !is.null( round ) )
    {
      for ( a in c(  "Sensitivity (%)", "Specificity (%)", 
                     "Positive predictive value (%)", "Negative predictive value (%)",
                     "Sensitivity (power, recall, hit rate, true positive rate) (%)", 
                     "Se CI lb", "Se CI ub", 
                     "Specificity (true negative rate) (%)",
                     "Sp CI lb", "Sp CI ub", 
                     "Predictive positive value (precision) (%)",
                     "PPV CI lb", "PPV CI ub", 
                     "Negative predictive value (%)",
                     "NPV CI lb", "NPV CI ub", 
                     "False negative rate (beta type II error,miss rate) (%)",
                     "False positive rate (alpha type I error, fall-out) (%)",
                     "False discovery rate (%)",
                     "False omission rate (%)",
                     "Prevalence (%)", 
                     "Accuracy (%)",
                     "Positive likelihood ratio", "Negative likelihood ratio",
                     "Diagnostic odds ratio",
                     "F1 score",
                     "Matthews correlation coefficient (MCC)",
                     "Informedness (bookmaker informedness)",
                     "Markedness"
      ) )
      {
        round( as.numeric( as.character( output[, a ] ) ), digits = round ) ->
          output[, a ] ; 
      }
    }
    
    if( !is.null( pvalue.round ) )
    {
      round( as.numeric( as.character( output[, "Exact Marginal Homogeneity Test p-value" ] ) ), 
             digits = pvalue.round ) ->
        output[, "Exact Marginal Homogeneity Test p-value" ] ; 
    }
    
    return( output )
  }
  
  fun.bivariate.r <- function( var, group, identifier,
                               Confusion.Table = TRUE,
                               No.Test.Details = TRUE,
                               name.var,
                               name.group,
                               nsim = nsim, 
                               seed = 123,
                               Continuity.correct = TRUE,
                               pvalue.round = pvalue.round,
                               round = round )
    
  {
    # domestic function
    CramersV <- function( cont.table )
    {
      chisq.test( cont.table )$statistic -> X2 ;
      
      ( X2 / ( sum( cont.table )  * ( min( nrow( cont.table ), ncol( cont.table ) ) - 1 ) ) 
      ) -> V2 ;
      
      sqrt( V2 ) -> V
      "Cramer's V"-> names( V ) ;
      
      return( V )   
    } 
    
    eta.squared <- function( x, y )
    {
      if ( !is.factor( x ) ) { stop( "x is not factor" );  } ;
      if ( !is.numeric( y ) ) { stop( "y is not numeric" );  } ;
      
      means <- tapply( y, INDEX = x, FUN = mean ) ;
      samples <- tapply( y, INDEX = x, FUN = length ) ;
      varinter <- sum( samples * ( means - mean( y ) )^2 ) / length( y ) ;
      vartot <- var( y ) ;
      
      return( varinter / vartot ) ;
    };
    
    r.pb <- function( x, y )
    {
      if ( !is.factor( x ) ) { stop( "x is not factor" );  } ;
      if ( !is.numeric( y ) ) { stop( "y is not numeric" );  } ;
      
      sd <- sqrt( sum( (y - mean(y) )^2 ) / (length(y) - 1) ) ;
      means <- tapply( y, INDEX = x, FUN = mean ) ;
      lengths <- tapply( y, INDEX = x, FUN = length ) ;
      
      ( (means[2] - means[1]) / sd ) * sqrt( (lengths[1] * lengths[2]) / 
                                               (length(y) * (length(y) - 1)) )
    }
    
    CohenD <- function( x, y )
    {
      if ( !is.factor( x ) ) { stop( "x is not factor" );  } ;
      if ( !is.numeric( y ) ) { stop( "y is not numeric" );  } ;
      
      SCEs <- tapply( y, INDEX = x, FUN = function(a){sum( (a - mean(a) )^2 ) / (length(a) - 1) } ) ;
      lengths <- tapply( y, INDEX = x, FUN = length ) ;
      
      means <- tapply( y, INDEX = x, FUN = mean ) ;
      
      s <- sqrt( ( (lengths[1] - 1) * SCEs[1] + (lengths[2] - 1) * SCEs[2] ) / 
                   (lengths[1] + lengths[2] - 2) ) ;
      
      (means[2] - means[1]) / s
    }
    
    HedgeGstar <- function( x, y )
    {
      if ( !is.factor( x ) ) { stop( "x is not factor" );   } ;
      if ( !is.numeric( y ) ) { stop( "y is not numeric" );   } ;
      
      SCEs <- tapply( y, INDEX = x, FUN = function(a){sum( (a - mean(a) )^2 ) / (length(a) - 1) } ) ;
      lengths <- tapply( y, INDEX = x, FUN = length ) ;
      means <- tapply( y, INDEX = x, FUN = mean ) ;
      
      s <- sqrt( ( (lengths[1] - 1) * SCEs[1] + (lengths[2] - 1) * SCEs[2] ) / 
                   (lengths[1] + lengths[2] - 2) ) ;
      
      (means[2] - means[1]) / s -> g
      
      (1 - (3 / (4 * (lengths[1] + lengths[2]) - 9) ) ) * g 
    }
    
    CliffDelta2 <- function( x, y )
    {
      if ( !is.numeric( x ) ) { stop( "x is not numeric" );  } ;
      if ( !is.factor( y ) ) { stop( "y is not factor" );  } ;
      
      wilcox.test( x ~ y )$statistic -> W ;
      
      2 * W / ( length(x) * length(y) ) - 1 
    }
    
    RankBiserialCor2 <- function( x, y )
    {
      if ( !is.numeric( x ) ) { stop( "x is not numeric" );  } ;
      if ( !is.factor( y ) ) { stop( "y is not factor" );  } ;
      
      wilcox.test( x ~ y )$statistic -> W ;
      
      1 - 2 * W / ( length(x) * length(y) )
    }
    
    Chance.Corrected.Measure.Of.Effect.Size <- function( var, group, identifier )
    {
      # prepare matrix
      as.numeric( var ) - 1 -> var.num ;
      data.frame( var = var.num, group = group, identifier = identifier ) |>
        tidyr::spread(  key = group, value = var ) |>
        dplyr::select(  -identifier ) |>
        as.matrix() -> 
        matrix1 ;
      
      # prepare dimension
      dim( matrix1 )[2] -> k ;
      dim( matrix1 )[1] -> b ; 
      0 -> res ;
      
      # job
      for ( i in 1:k )
      {
        for ( j in 1:(b - 1) )
        {
          for ( l in (j + 1):b )
          {
            res + abs( matrix1[j,i] - matrix1[l,i] ) ->
              res ;
          }
        }
      }
      
      1 / (k * choose( b, 2 ) ) * res -> 
        delta ;
      
      rowSums( matrix1 ) / k  -> 
        pi ;
      
      0 -> spi ;
      0 -> spi2 ;
      
      for ( i in 1:b )
      {
        spi + pi[i] -> spi ;
        spi2 + pi[i] * (1 - pi[i]) -> spi2 ; 
      }
      
      2 / (b * (b - 1)) * (spi *(b - spi) -spi2) ->  mudelta ;
      
      1 - delta / mudelta -> output ;
      
      # output
      return( unname( output ) )
    }
    
    
    # data 
    data.frame( var = var, 
                group = factor( group ), 
                identifier = factor( identifier ),
                stringsAsFactors = FALSE ) ->
      df ;
    
    # seed
    set.seed( seed ) ;
    
    # primer
    NULL -> output ;
    
    # Two factors of two levels
    if ( is.factor( var ) &
         nlevels( df$var ) > 1 &
         nlevels( df$group ) > 1 &
         all( table( df$var, df$group ) > 2 ) )
    {
      # compute 
      if ( nlevels( df$group ) == 2 )
      {
        table( df[ df[, "group"] == levels( df$group )[1], "var" ], 
               df[ df[, "group"] == levels( df$group )[2], "var" ]  ) ->
          table1 ;
        table1[1,2] + table1[2,1] -> effectif ;
        
        if ( nlevels( df$var ) == 2 ) 
        { Continuity.correct -> correction } else
        { FALSE -> correction } 
        
        mcnemar.test( table1, correct = correction ) -> mcnemar ;
        
        CramersV( table1 ) -> V ;
        pwr::ES.w2( prop.table( table1 ) ) -> omega ;
      } else
      {
        NA -> effectif ;
        
        "-" -> correction ;
        
        list( method = "Test not possible",
              statistic = NA,
              parameter = NA,
              p.value = NA
        ) ->
          mcnemar ;
        
        NA -> V ;
        NA -> omega ;
      }
      
      if ( nlevels( df$var ) == 2 )
      {
        DescTools::CochranQTest(  var ~ group | identifier, data = df ) -> q.cochran ;
        
        q.cochran$statistic / ( nlevels(df$identifier) * (nlevels(df$group) - 1) ) ->
          eta.squared.Q ;
        Chance.Corrected.Measure.Of.Effect.Size( df$var, df$group, df$identifier ) -> 
          R ;
      } else
      {
        list( method = "Test not possible",
              statistic = NA,
              parameter = NA,
              p.value = NA
        ) ->
          q.cochran ;
        
        NA -> eta.squared.Q ;
        NA -> R ;
      }
      
      coin::mh_test( var ~ group | identifier,
                     data = df,    
                     distribution = coin::approximate( nresample = nsim ) ) -> mh ;
      if ( is.nan( coin::statistic( mh ) ) ) { NA -> mh.p ; } else { coin::pvalue( mh ) -> mh.p ; } 
      
      # fusion
      c( "factor",
         name.var,
         name.group,
         nrow( df ), 
         nrow( data ) - nrow( df ),
         mh.p,
         paste0( mh@method,
                 ": MonteCarlo approximation based on ",
                 nsim,
                 " simulations"
         ),
         effectif,
         mcnemar$method,
         correction,
         mcnemar$statistic,
         mcnemar$parameter,
         mcnemar$p.value,
         q.cochran$method,
         q.cochran$statistic,
         q.cochran$parameter,
         q.cochran$p.value,
         mh@method,
         mh@distribution@name,
         nsim,
         coin::statistic( mh ),
         mh.p,
         eta.squared.Q,
         R,
         V,
         omega
      ) -> 
        output ;
      
      c( "factor", 
         "var", "group", 
         "N", "Missing",
         "p-value",
         "Method",
         "Sum of no matches cells",
         "McNemar method",
         "Continuity correction",
         "McNemar's Chi-squared",
         "McNemar's Degree of freedom",
         "McNemar's p-value",
         "Cochran's Q method",
         "Cochran's Q statistic Q",
         "Cochran's Q Degree of freedom",
         "Cochran's Q p-value",
         "Marginal homogeneity method",
         "Marginal homogeneity's distribution",
         "Marginal homogeneity's number of simulation",
         "Marginal homogeneity's statistic",
         "Marginal homogeneity's p-value",
         "Eta squared Q",
         "Chance-corrected measure of effect size R",
         "Cramer's V",
         "Cohen's omega"
      ) -> 
        names( output ) ;
      
      # Round 
      if( !is.null( round ) )
      {
        for ( round.a in c(
          "Sum of no matches cells",
          "McNemar's Chi-squared",
          "McNemar's Degree of freedom",
          "Cochran's Q statistic Q",
          "Cochran's Q Degree of freedom",
          "Marginal homogeneity's statistic",
          "Cramer's V",
          "Cohen's omega",
          "Eta squared Q",
          "Chance-corrected measure of effect size R"
        ) )
        {
          round( as.numeric( as.character( output[ round.a ] ) ), 
                 digits = round ) ->
            output[ round.a ] ; 
        }
      }
      
      if( !is.null( pvalue.round ) )
      {
        for ( round.a in c( 
          "p-value",
          "McNemar's p-value",
          "Cochran's Q p-value",
          "Marginal homogeneity's p-value"
        ) )
        {
          p.round( as.numeric( output[ which( names( output ) == 
                                                round.a ) ] ),
                   digits = pvalue.round ) ->
            output[ which( names( output ) == round.a ) ] ; 
        }
      }
      
    }
    
    # Confusion table
    if ( Confusion.Table )
    {
      if ( is.factor( var ) &
           nlevels( var ) == 2 &
           nlevels( df$group ) == 2 &
           all( table( df$var, df$group ) > 2 ) )
      {
        ConfusionTable.Analysis( df[ df[, "group"] == levels( df$group )[1], "var" ], 
                                 df[ df[, "group"] == levels( df$group )[2], "var" ], 
                                 name.x = levels( df$group )[1], 
                                 name.y = levels( df$group )[2],
                                 na.rm = na.rm, conf.level = conf.level,
                                 binom.ci.method = binom.ci.method,
                                 pvalue.round = pvalue.round, 
                                 round = round  ) ->
          tmp.output ;
        
        cbind( "tabconfusion", 
               name.var,
               name.group,
               nrow( df ), 
               nrow( data ) - nrow( df ),
               tmp.output 
        ) -> tmp.output ;
        
        rbind.force( output, tmp.output ) -> output ; 
      }
    }
    
    # One factor and one numeric
    if ( is.numeric( var ) &
         nlevels( factor( df$var ) ) > 3 &
         all( table( df$group ) > 4 ) &
         nlevels( df$group ) > 1 
    )
    {
      # compute
      aov( var ~ group + Error( identifier/group ), data = df ) -> aov1 ;
      proj( aov1 )[[3]][, "Residuals"] -> residuals1 ;
      if ( length( residuals1 ) < 5000 ) 
      { shapiro.test( residuals1 ) -> shapiro ; }  else
      { list( "p.value" = NA ) -> shapiro ; }
      nortest::ad.test( residuals1) -> anderson ;
      moments::jarque.test( residuals1 ) -> jarque ;
      if ( any( c( shapiro$p.value, anderson$p.value, jarque$p.value ) < 0.05 ) ) 
      { FALSE -> normal } else { TRUE -> normal } 
      
      NULL -> tab ;
      for ( i in 1:nlevels( df$group ) )
      {
        cbind( tab, 
               df[ df[, "group"] == levels( df$group )[i], "var" ] ) ->
          tab ;
      }
      lm( tab ~ 1 ) ->
        m1 ;
      car::Anova( m1, type = 3, 
                  idata = data.frame( group = as.factor( levels( df$group ) ) ), 
                  idesign = ~  group , 
                  multivariate = FALSE ) -> 
        ANOVA ; 
      summary( ANOVA, multivariate = FALSE ) -> aov.tab ;
      if ( is.na( aov.tab$sphericity.tests[2] ) )
      {
        "-" -> sphericity ;
      } else
      {
        if (  aov.tab$sphericity.tests[2] > 0.05 )
        { TRUE -> sphericity } else { FALSE -> sphericity }
      }
      
      friedman.test( var ~ group | identifier, data = df ) -> friedman ;
      quade.test( var ~ group | identifier, data = df ) -> quade ;
      
      
      df |> tidyr::spread(  key = group, value = var ) |> 
        dplyr::select(  -identifier ) |> 
        (function(x) lapply( x, function(a,b) { na.omit( a == b ) }, b = x) )() |>
        cbind.force() |> 
        data.frame( stringsAsFactors = FALSE) |>
        lapply(  all) |> 
        unlist() |>
        sum() -> Nb.Identical ;
      if ( nlevels( df$group ) == Nb.Identical )
      {
        heplots::etasq( ANOVA )[2,1] -> eta2 ;
        coin::symmetry_test(  var ~ group | identifier, 
                              data = df,
                              distribution = coin::approximate( nresample = nsim ) ) -> sm ;
        coin::pvalue( sm ) -> sm.p ;
      } else
      {
        NA -> eta2 ;
        
        setClass( "coin1", slots = c( name = "character" ) )
        setClass( "coin2", slots = c( teststatistic = "numeric" ) )
        setClass( "coin", slots = c( method = "character", 
                                     distribution = "coin1",
                                     statistic = "coin2" ) )
        new( "coin", method = "Test not possible" ) -> sm ;
        "-" -> sm@distribution@name ;
        as.numeric(NA) -> sm@statistic@teststatistic ;
        NA -> sm.p ;
      }
      
      
      if ( sphericity != "-" )
      {
        if ( normal & sphericity ) 
        {
          aov.tab$univariate.tests[2,6] ->  p.final ;
          "Univariate Type III Repeated-Measures ANOVA Assuming Sphericity" -> 
            method.final ; 
        }
        if ( normal & !sphericity ) 
        {
          aov.tab$pval.adjustments[2] -> p.final ;
          "Univariate Type III Repeated-Measures ANOVA with Greenhouse-Geisser Correction for Departure from Sphericity" -> 
            method.final ;
        }
      } else
      {
        if ( normal ) 
        {
          aov.tab$univariate.tests[2,6] ->  p.final ;
          "Univariate Type III Repeated-Measures ANOVA" -> 
            method.final ; 
        }
      }
      if ( !normal ) 
      {
        sm.p -> p.final ;
        paste0( sm@method,
                ": MonteCarlo approximation based on ",
                nsim,
                " simulations"
        ) -> method.final ;
      }
      
      
      if ( nlevels( df$group ) == 2 &
           !all( na.omit( 
             df$var[ df$group == levels( df$group )[1] ]  == 
             df$var[ df$group == levels( df$group )[2] ] 
           ) ) &
           nlevels( factor( 
             df$var[ df$group == levels( df$group )[1] ] 
           ) ) > 3 &
           nlevels( factor( 
             df$var[ df$group == levels( df$group )[2] ]
           ) ) > 3 )
      {
        df$var[ df$group == levels( df$group )[2] ] - df$var[ df$group == levels( df$group )[1] ] ->
          dif1 ;
        if ( length( dif1 ) < 5000 ) 
        { shapiro.test( dif1 ) -> shapiro1 ; }  else
        { list( "p.value" = NA ) -> shapiro1 ; }
        nortest::ad.test( dif1) -> anderson1 ;
        moments::jarque.test( dif1 ) -> jarque1 ;
        if ( any( c( shapiro1$p.value, anderson1$p.value, jarque1$p.value ) < 0.05 ) ) 
        { FALSE -> normal } else { TRUE -> normal } 
        
        t.test( df$var ~ df$group, paired = TRUE ) -> student ;
        wilcox.test( df$var ~ df$group, 
                     paired = TRUE, 
                     correct = Continuity.correct ) -> wilcoxon ;
        paste( levels( df$group )[1], "->", levels( df$group )[2]) -> direction;
        r.pb( df$group, df$var ) -> rpb ;
        CohenD( df$group, df$var ) -> cohend ;
        HedgeGstar( df$group, df$var ) -> hedgegstar ;
        RankBiserialCor2( df$var, df$group ) ->  rbc ;
        CliffDelta2( df$var, df$group ) -> cliff ;
        
        if ( normal  ) 
        {
          student$p.value -> p.final ; 
          student$method -> method.final
        } else
        {
          wilcoxon$p.value -> p.final ; 
          wilcoxon$method -> method.final
        }
      } else
      {
        list( "p.value" = NA ) -> shapiro1 ; 
        list( "p.value" = NA ) -> anderson1 ; 
        list( "p.value" = NA ) -> jarque1 ; 
        
        list(
          method = "Test not possible because: more than two levels or all values equal in two groups or less than four different possible values in one of groups",
          statistic = NA,
          parameter = NA,
          p.value = NA
        ) -> student ;
        list(
          method = "Test not possible",
          statistic = NA,
          p.value = NA
        ) -> wilcoxon ;
        
        "" -> direction;
        NA -> rpb ;
        NA -> cohend ;
        NA -> hedgegstar ;
        NA -> rbc ;
        NA -> cliff ;
      }
      
      
      # fusion
      c( "mix",
         name.var,
         name.group,
         nrow( df ), 
         nrow( data ) - nrow( df ),
         p.final,
         method.final,
         normal,
         sphericity,
         "Univariate Type III Repeated-Measures ANOVA Assuming Sphericity",
         aov.tab$univariate.tests[2,5],         
         aov.tab$univariate.tests[2,2],
         aov.tab$univariate.tests[2,4],
         aov.tab$univariate.tests[2,6],
         "Univariate Type III Repeated-Measures ANOVA with Greenhouse-Geisser Correction for Departure from Sphericity",
         aov.tab$pval.adjustments[1],
         aov.tab$pval.adjustments[2],
         "Univariate Type III Repeated-Measures ANOVA with Huynh-Feldt Correction for Departure from Sphericity",
         aov.tab$pval.adjustments[3],
         aov.tab$pval.adjustments[4],
         friedman$method,
         friedman$statistic,
         friedman$parameter,
         friedman$p.value,
         quade$method,
         quade$statistic,
         quade$parameter[1],
         quade$parameter[2],
         quade$p.value,
         sm@method,
         sm@distribution@name,
         nsim,
         sm@statistic@teststatistic,
         sm.p,
         student$method,
         student$statistic,
         student$parameter,
         student$p.value,
         wilcoxon$method,
         Continuity.correct,
         wilcoxon$statistic,
         wilcoxon$p.value,
         eta2,
         direction,
         rpb,
         cohend,
         hedgegstar,
         rbc,
         cliff,
         aov.tab$sphericity.tests[2],
         shapiro$p.value, 
         anderson$p.value,
         jarque$p.value,
         shapiro1$p.value, 
         anderson1$p.value,
         jarque1$p.value
      ) -> 
        output ;
      
      c( "mix",
         "var", "group", 
         "N", "Missing",
         "p-value",
         "Method",
         "Normality",
         "Sperecity",
         "Anova method",
         "ANOVA F statistic",
         "ANOVA Degree of freedom numerator",
         "ANOVA Degree of freedom denominator",
         "ANOVA p-value",
         "Greenhouse-Geisser method",
         "Greenhouse-Geisser epsilon",
         "Greenhouse-Geisser p-value",
         "Huynh-Feldt method",
         "Huynh-Feldt epsilon",
         "Huynh-Feldt p-value",
         "Friedman method",
         "Friedman chi-squared",
         "Friedman degree of freedom",
         "Friedman p-value",
         "Quade method",
         "Quade F statistic",
         "Quade degree of freedom numerator",
         "Quade degree of freedom denominator",
         "Quade p-value",
         "Symetry method",
         "Symetry's distribution",
         "Symetry's number of simulation ",
         "Symetry's statistic",
         "Symetry's p-value",
         "T method",
         "T ratio",
         "T degree of freedom",
         "T p-value",
         "Wilcoxon method",
         "Continuity correction",
         "Wilcoxon statistic",
         "Wilcoxon p-value",
         "Partial eta-squared",
         "Direction for size effects",
         "Point biserial correlation coefficient r.pb",
         "Cohen's d",
         "Hedge's g*",
         "Rank biserial correlation",
         "Cliff's delta",
         "Mauchly p-value",
         "Anova residuals Shapiro p-value",
         "Anova residuals Anderson-Darling p-value",
         "Anova residuals Jarque-Bera p-value",
         "Difference Shapiro p-value",
         "Difference Anderson-Darling p-value",
         "Difference Jarque-Bera p-value"
      ) -> names( output ) ;
      
      # Round 
      if( !is.null( round ) )
      {
        for ( round.a in c(
          "ANOVA F statistic",
          "ANOVA Degree of freedom numerator",
          "ANOVA Degree of freedom denominator",
          "Greenhouse-Geisser epsilon",
          "Huynh-Feldt epsilon",
          "Friedman chi-squared",
          "Friedman degree of freedom",
          "Quade F statistic",
          "Quade degree of freedom numerator",
          "Quade degree of freedom denominator",
          "Symetry's statistic",
          "T ratio",
          "T degree of freedom",
          "Wilcoxon statistic",
          "Partial eta-squared",
          "Direction for size effects",
          "Point biserial correlation coefficient r.pb",
          "Cohen's d",
          "Hedge's g*",
          "Rank biserial correlation",
          "Cliff's delta"
        ) )
        {
          round( as.numeric( as.character( output[ round.a ] ) ), 
                 digits = round ) ->
            output[ round.a ] ; 
        }
      }
      
      if( !is.null( pvalue.round ) )
      {
        for ( round.a in c( 
          "p-value",
          "ANOVA p-value",
          "Greenhouse-Geisser p-value",
          "Huynh-Feldt p-value",
          "Friedman p-value",
          "Quade p-value",
          "Symetry's p-value",
          "T p-value",
          "Wilcoxon p-value",
          "Mauchly p-value",
          "Anova residuals Shapiro p-value",
          "Anova residuals Anderson-Darling p-value",
          "Anova residuals Jarque-Bera p-value",
          "Difference Shapiro p-value",
          "Difference Anderson-Darling p-value",
          "Difference Jarque-Bera p-value"
        ) )
        {
          p.round( as.numeric( output[ which( names( output ) == 
                                                round.a ) ] ),
                   digits = pvalue.round ) ->
            output[ which( names( output ) == round.a ) ] ; 
        }
      }
    }
    
    # No test possible
    if ( is.null( output ) )
    {
      if ( No.Test.Details )
      {
        # tests
        !( is.factor( df$var ) |
             is.numeric( df$var ) ) -> notnumfact ;
        
        if ( is.factor( var ) )
        {
          !( nlevels( df$var ) > 1 ) -> isfactor.var ;
          !all( table( df$var, df$group ) > 2 ) -> contingencytab3 ;
        } else
        {
          "-" -> isfactor.var ;
          "-" -> contingencytab3 ;
        }
        
        !( nlevels( df$group ) > 1 ) -> isfactor.group
        
        if ( is.numeric( var ) )
        {
          !( nlevels( factor( df$var ) ) > 3 ) -> less4numeric.var
          !all( table( df$group ) > 4 ) -> less5 ;
        } else
        {
          "-" -> less4numeric.var ;
          "-" -> less5 ;
        }
        
        # fusion
        c( "other", 
           name.var,
           name.group,
           nrow( df ), 
           nrow( data ) - nrow( df ),
           class( df$var ),
           "No test because:",
           notnumfact, 
           isfactor.var,
           isfactor.group,
           less4numeric.var,
           contingencytab3,
           less5
        ) -> output
        
        c( "other", 
           "var", "group", 
           "N", "Missing",
           "class var",
           "No test because:", 
           "Is not factor or numeric",
           "Just 1 level for factor (var)",
           "Just 1 level for factor (group)",
           "Less than 4 different values for numeric (var)", 
           "Less than 3 observations for each cells (factor)",
           "Less than 5 observations by level (numeric)"
        ) -> 
          names( output ) 
      } else
      {
        c(
          "other", 
          name.var,
          name.group,
          nrow( df ), 
          nrow( data ) - nrow( df ),
          "Test not possible because: var is not factor or numeric, just 1 level for group or var, less than 4 different values for var numeric, less than 5 values per group for var, less than 3 observations for each cells" ) -> 
          output ;
      }
      
    }
    
    return( output ) ;
  }
  
  fun.a <- function( a, data.vars, data.group, data.identifier, group )
  {
    print( a ) ; print( colnames(data.vars)[a] ) ;
    
    # Prepara data
    data.frame( var = data.vars[,a], 
                group = factor( data.group ), 
                identifier = factor( data.identifier ),
                stringsAsFactors =FALSE ) ->
      df ;
    
    # NA
    if ( na.rm )
    {
      na.omit( df ) -> df ;
      
      if ( any( table( df$identifier ) < 
                max( table( df$identifier ) ) ) )
      {
        subset( df, !( identifier %in% 
                         levels( df$identifier )[ 
                           which( table( df$identifier ) < 
                                    max( table( df$identifier ) ) ) ] ) ) ->
          df ;
        
        if ( is.factor( df$var ) ) { factor( df$var ) -> df$var }
      }
    } else
    {
      if ( any( is.na( df ) ) ) { stop( "data coutains NA." ) ;  }  
    }
    
    # bi
    fun.bivariate.r( df$var, 
                     df$group,
                     df$identifier,
                     name.var = colnames(data.vars)[a],
                     name.group = group, 
                     nsim = nsim, 
                     seed = seed,
                     Continuity.correct = Continuity.correct,
                     pvalue.round = pvalue.round,
                     round = round ) ->
      output.a ; 
    
    # output
    return( output.a )
  }
  
  # Load packages
  download.packages( "furrr",  "pwr", "moments", "nortest", "binom",
                     "coin", "DescTools", "afex", "heplots", "dplyr", "tidyr" ) ;
  
  # prepare data
  #=============
  data[, which( !( colnames( data ) %in% group ) ) ] -> 
    data.vars ;
  
  data.vars[, which( !( colnames( data.vars ) %in% identifier ) ) ] -> 
    data.vars ; 
  
  data[, which( colnames( data ) %in% group ) ] -> 
    data.group ;
  
  data[, which( colnames( data ) %in% identifier ) ] -> 
    data.identifier ;
  
  # Job
  
  #pbmcapply::pbmc
  furrr::future_map( 
    1:dim( data.vars )[2], 
    fun.a,
    data.vars = data.vars, 
    data.group = data.group, 
    data.identifier = data.identifier, 
    group = group,
    .options = furrr::furrr_options( seed = seed ), .progress = T 
  ) |>
    rbind.force(  empty = "" ) -> 
    output
  
  # prepare output
  c( 
    "class", 
    "var", "group", 
    "N", "Missing",
    "p-value",
    "Method",
    "Sum of no matches cells",
    "McNemar method",
    "Continuity correction",
    "McNemar's Chi-squared",
    "McNemar's Degree of freedom",
    "McNemar's p-value",
    "Cochran's Q method",
    "Cochran's Q statistic Q",
    "Cochran's Q Degree of freedom",
    "Cochran's Q p-value",
    "Marginal homogeneity method",
    "Marginal homogeneity's distribution",
    "Marginal homogeneity's number of simulation",
    "Marginal homogeneity's statistic",
    "Marginal homogeneity's p-value",
    "Eta squared Q",
    "Chance-corrected measure of effect size R",
    "Cramer's V",
    "Cohen's omega"
  ) -> titles.factor
  
  c(
    "class",
    "var", "group", 
    "N", "Missing",
    "Reference Condition", "Predicted Condition", "Positive", "Negative",
    "Sensitivity (%)", "Specificity (%)", 
    "Positive predictive value (%)", "Negative predictive value (%)",
    "Exact Marginal Homogeneity Test p-value",
    "Reference positive (n)", "Reference negative (n)", 
    "Prediction positive (n)", "Prediction negative (n)",
    "True positive (n)", "True negative (n)", 
    "False positive (n)", "False negative (n)",
    "Sensitivity (power, recall, hit rate, true positive rate) (%)", 
    "Se CI lb", "Se CI ub", 
    "Specificity (true negative rate) (%)",
    "Sp CI lb", "Sp CI ub", 
    "Predictive positive value (precision) (%)",
    "PPV CI lb", "PPV CI ub", 
    "Negative predictive value (%)",
    "NPV CI lb", "NPV CI ub", 
    "CI binomial method",
    "False negative rate (beta type II error,miss rate) (%)",
    "False positive rate (alpha type I error, fall-out) (%)",
    "False discovery rate (%)",
    "False omission rate (%)",
    "Prevalence (%)", 
    "Accuracy (%)",
    "Positive likelihood ratio", "Negative likelihood ratio",
    "Diagnostic odds ratio",
    "F1 score",
    "Matthews correlation coefficient (MCC)",
    "Informedness (bookmaker informedness)",
    "Markedness"
  ) -> titles.confusiontab ; 
  
  c(
    "class",
    "var", "group", 
    "N", "Missing",
    "p-value",
    "Method",
    "Normality",
    "Sperecity",
    "Anova method",
    "ANOVA F statistic",
    "ANOVA Degree of freedom numerator",
    "ANOVA Degree of freedom denominator",
    "ANOVA p-value",
    "Greenhouse-Geisser method",
    "Greenhouse-Geisser epsilon",
    "Greenhouse-Geisser p-value",
    "Huynh-Feldt method",
    "Huynh-Feldt epsilon",
    "Huynh-Feldt p-value",
    "Friedman method",
    "Friedman chi-squared",
    "Friedman degree of freedom",
    "Friedman p-value",
    "Quade method",
    "Quade F statistic",
    "Quade degree of freedom numerator",
    "Quade degree of freedom denominator",
    "Quade p-value",
    "Symetry method",
    "Symetry's distribution",
    "Symetry's number of simulation ",
    "Symetry's statistic",
    "Symetry's p-value",
    "T method",
    "T ratio",
    "T degree of freedom",
    "T p-value",
    "Wilcoxon method",
    "Continuity correction",
    "Wilcoxon statistic",
    "Wilcoxon p-value",
    "Partial eta-squared",
    "Direction for size effects",
    "Point biserial correlation coefficient r.pb",
    "Cohen's d",
    "Hedge's g*",
    "Rank biserial correlation",
    "Cliff's delta",
    "Mauchly p-value",
    "Anova residuals Shapiro p-value",
    "Anova residuals Anderson-Darling p-value",
    "Anova residuals Jarque-Bera p-value",
    "Difference Shapiro p-value",
    "Difference Anderson-Darling p-value",
    "Difference Jarque-Bera p-value"
  ) -> titles.mix ;
  
  c( "class", 
     "var", "group", 
     "N", "Missing",
     "class var",
     "No test because:", 
     "Is not factor or numeric",
     "Just 1 level for factor (var)",
     "Just 1 level for factor (group)",
     "Less than 4 different values for numeric (var)", 
     "Less than 3 observations for each cells (factor)",
     "Less than 5 observations by level (numeric)"
  ) -> titles.other
  
  NULL -> output.tmp
  for ( i in levels( factor( output[,1] ) ) )
  {
    if ( grepl( "factor", i ) )
    {
      rbind.force( output.tmp,
                   titles.factor,
                   output[ output[,1] == i, ],
                   empty = "" ) ->
        output.tmp ; 
    }
    
    if ( grepl( "mix", i ) )
    {
      rbind.force( output.tmp,
                   titles.mix,
                   output[ output[,1] == i, ],
                   empty = "" ) ->
        output.tmp ; 
    }
    
    if ( grepl( "tabconfusion", i ) )
    {
      rbind.force( output.tmp,
                   titles.confusiontab,
                   output[ output[,1] == i, ],
                   empty = "" ) ->
        output.tmp ; 
    }
    
    if ( grepl( "other", i ) )
    {
      rbind.force( output.tmp,
                   titles.other,
                   output[ output[,1] == i, ],
                   empty = "" ) ->
        output.tmp ; 
    }
    
  }
  output.tmp -> output
  
  c( "Class", "var", "group", "N", "Missing",
     paste( rep( "col", length( 6:ncol( output ) ) ), 
            6:ncol( output ), sep = "" ) ) ->         
    colnames( output ) ;
  
  # end parallel
  future::plan("sequential")
  
  return( output ) ;
} 

# 1.4.4 Uni and BI variate analysis paired data
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

UniAndBiVariate.Analysis.OnGroups.Repeated.OnTimes  <- function( 
    data, 
    group, 
    identifier,
    na.rm = TRUE,
    conf.level = 0.95, 
    binom.ci.method = "exact",
    boot.ci.method = "bca",
    nsim = 10000, 
    seed = 123,
    Continuity.correct = TRUE,
    pvalue.round = 3,
    round = 2,
    ncores = NULL )

{ 
  # Conditions for input
  if ( !is.data.frame( data ) ) { stop( "data is not a data.frame" );   } ;
  if ( !is.character( group ) ) { stop( "groups is not character" );   } ;
  if ( !is.character( identifier ) ) { stop( "identifier is not character" );   } ;
  if ( !is.logical( na.rm ) ) { stop( "na.rm is not TRUE or FALSE" );    } ;
  if ( !is.numeric( conf.level ) ) { stop( "conf.level is not numeric" );    } ;
  if ( !is.character( binom.ci.method ) ) 
  { stop( "binom.ci.method is not character" );    } ;
  if ( !binom.ci.method %in% c("exact", "ac", "asymptotic", "wilson", "prop.test", "bayes", "logit", "cloglog", "probit") ) 
  { stop( "binom.ci.method is not in exact, ac, asymptotic, wilson, prop.test, bayes, logit, cloglog, probit, see binom::binnom.confint()" );    } ;
  if ( !is.character( boot.ci.method ) ) 
  { stop( "boot.ci.method is not character" );    } ;
  if ( !boot.ci.method %in% c("norm", "basic", "stud", "perc", "bca") ) 
  { stop( "boot.ci.method is not in norm, basic, stud, perc, bca, see boot::boot.ci()" );    } ;
  if ( !is.numeric( nsim ) ) { stop( "nsim is not numeric" ) } 
  else { if ( nsim != round( nsim ) ) { stop( "nsim is not integer" ) } }
  if ( !is.numeric( seed ) ) { stop( "nsim is not numeric" ) } 
  else { if ( seed != round( seed ) ) { stop( "seed is not integer" ) } }
  if ( !is.logical( Continuity.correct ) ) { stop( "Continuity.correct is not TRUE or FALSE" );    } ;
  if ( !( is.numeric( pvalue.round ) | 
          is.null( pvalue.round ) ) ) { stop( "pvalue.round is neither numeric, neither NULL" );    } ;
  if ( !( is.numeric( round ) | 
          is.null( round ) ) ) { stop( "round is neither numeric, neither NULL" );    } ;
  if ( !is.null(ncores) & !is.numeric(ncores) ) { stop( "ncores is not null nor numeric" ) }
  
  # parallel
  if ( !is.null( ncores ) ) { future::plan( "multisession",  workers = ncores ) }
  
  # function definition
  download.packages <- function( PackagesNames, ... )
  {
    # Get a vector with packages names 
    packages1 <- c( PackagesNames, ... ) ;
    
    # Install packages
    for (a in 1:length( packages1 ) )
    {
      try( find.package( packages1[a]), silent = TRUE ) -> test ;
      
      if ( class( test ) == "try-error" )
      { print( packages1[a] ) ; 
        install.packages(  packages1[a] ) ;
      } 
    }
  } ;
  
  p.round <- function( data, digits = 3 )
  {
    if (digits == 1)
    { "" -> tmp1 ; } else 
    { rep( "0", digits - 1 ) -> tmp1 ; }
    
    "0." -> tmp2 ;
    for( a in 1:length(tmp1) )
    {
      paste( tmp2, tmp1[a], sep = "" ) -> tmp2 ;
    }
    
    paste( tmp2, "1", sep = "" ) -> pval ;
    
    for ( a in 1:length(data) )
    {
      if ( !is.na( data[a] ) )
      {
        if ( data[a] >= as.numeric( pval ) )
        {
          round( data[a], digits = digits ) -> data[a] ;
        }
      }
    }
    
    data[ data < as.numeric( pval ) ] <- paste( "< ", pval, sep = "" ) ;
    
    return( data ) ;
  }
  
  rbind.force <- function( data, ..., keep.col = FALSE, empty = NA ) 
  {
    # Unify data
    list( data, ... ) -> input ;
    
    # include list elements
    repeat 
    {
      if (  !any( unlist( lapply( input, class ) ) == "list" ) ) { break }  
      
      which( unlist( lapply( input, class ) ) == "list" )[1] -> a ;
      input[[a]] -> tmp ;
      input[[a]] <- NA ;
      c( input[1:a],  tmp, input[ (a + 1):length( input ) ] ) -> 
        input ;
    }
    
    input[ !is.na( input ) ] ->
      input ;
    
    # delete NULL data and transformt vector in data.frame
    for ( a in 1:length( input ) )
    {
      if ( is.null( dim( input[[a]] ) ) )
      {
        if ( is.null( input[[a]] ) )
        {
          input[[a]] <- NA ;
        } else
        {
          data.frame( matrix( input[[a]], nrow = 1 ),
                      stringsAsFactors = FALSE ) -> input[[a]] ; 
        }
      }
      
      if ( all( dim( input[[a]] ) == 0 ) )
      {
        input[[a]] <- NA ;
      }
    }
    
    input[ !is.na( input ) ] ->
      input ;
    
    # test data class
    if ( !all( unlist( lapply( input, is.data.frame ) ) |
               unlist( lapply( input, is.matrix ) ) |
               unlist( lapply( input, is.vector ) ) ) )
    { stop( "Some argument are not data.frame, neither vector" ) ;
      ; } ;
    
    # Set primer
    input[[1]] -> output ; 
    
    # job in case we keep columns 
    if ( keep.col & length( input ) >1 )
    {
      for ( a in 2:length( input ) )
      { 
        output -> x ;
        input[[a]] -> y ; 
        
        for (a in 1:dim(x)[2]) { x[,a] <- as.character(x[,a])}
        for (a in 1:dim(y)[2]) { y[,a] <- as.character(y[,a])}
        
        x.diff <- setdiff(colnames(x), colnames(y))
        y.diff <- setdiff(colnames(y), colnames(x))
        
        if( dim(x)[1] > 0 ) { x[, c(as.character(y.diff))] <- empty ; }
        if( dim(y)[1] > 0 ) { y[, c(as.character(x.diff))] <- empty ; }
        
        rbind(x, y) -> output ;
      } 
    }
    
    # job in case we do not keep columns
    if ( !keep.col & length( input ) >1 )
    {
      for ( a in 2:length( input ) )
      { 
        output -> x ;
        input[[a]] -> y ; 
        
        colnames(x) <- paste( "X",
                              1:dim( x )[2], 
                              sep = "" ) ;
        colnames(y) <- paste( "X",
                              1:dim( y )[2], 
                              sep = "" ) ;
        
        for (a in 1:dim(x)[2]) { x[,a] <- as.character(x[,a])}
        for (a in 1:dim(y)[2]) { y[,a] <- as.character(y[,a])}
        
        x.diff <- setdiff(colnames(x), colnames(y))
        y.diff <- setdiff(colnames(y), colnames(x))
        
        if( dim(x)[1] > 0 ) { x[, c(as.character(y.diff))] <- empty ; }
        if( dim(y)[1] > 0 ) { y[, c(as.character(x.diff))] <- empty ; }
        
        rbind(x, y) -> output ;
      } 
    }
    
    return( output ) ;
  } 
  
  cbind.force <- function( data, ... , keep.row = FALSE, empty = NA ) 
  {
    # Unify data
    list( data, ... ) -> input ;
    
    # include list elements
    repeat 
    {
      if (  !any( unlist( lapply( input, class ) ) == "list" ) ) { break }  
      
      which( unlist( lapply( input, class ) ) == "list" )[1] -> a ;
      input[[a]] -> tmp ;
      input[[a]] <- NA ;
      c( input[1:a],  tmp, input[ (a + 1):length( input ) ] ) -> 
        input ;
    }
    
    input[ !is.na( input ) ] ->
      input ;
    
    # delete NULL data and transform vector in data.frame
    for ( a in 1:length( input ) )
    {
      if ( is.null( dim( input[[a]] ) ) )
      {
        if ( is.null( input[[a]] ) )
        {
          input[[a]] <- NA ;
        } else
        {
          data.frame( input[[a]],
                      stringsAsFactors = FALSE ) -> input[[a]] ; 
          "vector" -> colnames(  input[[a]] ) ;
        }
      }
      
      if ( all( dim( input[[a]] ) == 0 ) )
      {
        input[[a]] <- NA ;
      }
    }
    
    input[ !is.na( input ) ] ->
      input ;
    
    # test data class
    if ( !all( unlist( lapply( input, is.data.frame ) ) |
               unlist( lapply( input, is.matrix ) ) |
               unlist( lapply( input, is.vector ) ) ) )
    { stop( "Some argument are not data.frame, neither vector" ) ;
      ; } ;
    
    # Set primer
    input[[1]] -> output ; 
    
    # job in case we keep columns 
    if ( keep.row & length( input ) > 1 )
    {
      for ( a in 2:length( input ) )
      { 
        output -> x ;
        input[[a]] -> y ; 
        
        for (a in 1:dim(x)[2]) { x[,a] <- as.character(x[,a])}
        for (a in 1:dim(y)[2]) { y[,a] <- as.character(y[,a])}
        
        x.diff <- setdiff(rownames(x), rownames(y))
        y.diff <- setdiff(rownames(y), rownames(x))
        
        if( dim(x)[2] > 0 ) { x[ c(as.character(y.diff)), ] <- empty ; }
        if( dim(y)[2] > 0 ) { y[ c(as.character(x.diff)), ] <- empty ; }
        
        cbind(x, y) -> output ;
      } 
    }
    
    # job in case we do not keep columns
    if ( !keep.row & length( input ) > 1 )
    {
      for ( a in 2:length( input ) )
      { 
        output -> x ;
        input[[a]] -> y ; 
        
        rownames(x) <- paste( "X",
                              1:dim( x )[1], 
                              sep = "" ) ;
        rownames(y) <- paste( "X",
                              1:dim( y )[1], 
                              sep = "" ) ;
        
        for (a in 1:dim(x)[2]) { x[,a] <- as.character(x[,a])}
        for (a in 1:dim(y)[2]) { y[,a] <- as.character(y[,a])}
        
        x.diff <- setdiff(rownames(x), rownames(y))
        y.diff <- setdiff(rownames(y), rownames(x))
        
        if( dim(x)[2] > 0 ) { x[ c(as.character(y.diff)), ] <- empty ; }
        if( dim(y)[2] > 0 ) { y[ c(as.character(x.diff)), ] <- empty ; }
        
        cbind(x, y) -> output ;
      } 
    }
    
    return( output ) ;
  } ;
  
  StringContatener <- function( vector, separator )
  {   
    # exclude NA
    na.omit( vector ) -> vector ;
    
    # selection of length for loop
    if ( length( vector ) >= 2) 
    { 
      # stock fisrt element
      tmp.val1 <- vector[1] ;
      
      # loop to concatenate the nect elements
      for ( a in 2:length( vector ) ) 
      { 
        tmp.val1 <- paste( tmp.val1, vector[a], sep = separator ) ; 
      } ;
    } 
    else
    {
      tmp.val1 <- vector ;
    } ;
    
    return( tmp.val1 ) ;
  } ;
  
  fun.univariate <- function( num.group.level,
                              variable,
                              group )
  {
    # domestic functions 
    CImean.boot <- function( vector, level = conf.level, nsim = nsim, 
                             boot.ci.method = boot.ci.method )
    {
      # domestic functions 
      # function for bootstrap mean
      mean.boot <- function( x, a) 
      { 
        mean( x[a], na.rm = T ) -> m ;
        length(a) -> n ;
        (n-1) * var( x[a], na.rm = T ) / (n^2) -> v ;
        return( c( m, v ) )
      } 
      
      # job  
      boot::boot( vector, statistic = mean.boot, R = nsim ) -> tmp1 ;
      boot::boot.ci( tmp1, conf = level, type = boot.ci.method ) -> tmp2 ;
      
      tmp2[[4]][ (length( tmp2[[4]] ) - 1):length( tmp2[[4]] ) ] -> ci ;
      
      return( ci ) ;
    } ;
    
    # prepare data 
    data.frame( var = variable,
                grp = group,
                stringsAsFactors = FALSE ) ->
      df
    
    levels( group )[num.group.level] -> level.grp ;
    
    base::subset( df, grp == level.grp, select = var )[,1] -> var ;
    
    # seed
    set.seed( seed ) ;
    
    # primer
    NULL -> output ;
    
    # factor
    if ( is.factor( var ) & length( var ) > 0 )
    {
      # remake factor 
      factor( var ) -> var ;
      
      # for each levels
      fun.lvl <- function( i, var,
                           conf.level = 0.95, 
                           binom.ci.method = "exact",
                           round = NULL )
      {
        # preparation
        levels( var )[i] -> tmp.level ;
        binom::binom.confint( length( var[ var == tmp.level ] ), 
                              length( var ), 
                              conf.level = conf.level, 
                              methods = binom.ci.method )[5:6] ->
          tmp.ci ;
        
        # job
        if ( !is.null( round ) ) 
        {
          c( " ",
             "-",
             tmp.level,
             round( length( var[ var == tmp.level ] ) / length( var ) * 100, 
                    digits = round ), 
             round( tmp.ci[1,1] * 100, 
                    digits = round ), 
             round( tmp.ci[1,2] * 100, digits = round ),
             binom.ci.method,
             length( var[ var == tmp.level ] )
          ) ->
            output.lvl ;
        } else
        {
          c( " ",
             "-",
             tmp.level,
             length( var[ var == tmp.level ] ) / length( var ) * 100, 
             tmp.ci[1,1] * 100, 
             tmp.ci[1,2] * 100,
             binom.ci.method,
             length( var[ var == tmp.level ] )
          ) ->
            output.lvl ;
        }
        
        return( output.lvl ) ;
      }
      
      rbind.force( c( "  ", length( var ) ),
                   lapply( 1:nlevels( var ),
                           fun.lvl,
                           var = var,
                           conf.level = conf.level, 
                           binom.ci.method = binom.ci.method,
                           round = round ),
                   empty = "" ) -> 
        output ;
    }
    
    # numeric 
    if ( is.numeric( var ) & 
         length( var ) > 0 & 
         nlevels( factor( as.character( var ) ) ) > 1 )
    {
      if ( length( var ) >= 1000 )
      {
        t.test( var, conf.level = conf.level )$conf.int -> cistudent1 ;
        ci1 <- cistudent1[1] ;
        ci2 <- cistudent1[2] ;
        type <- "Student" ;
      } else
      { 
        CImean.boot( var, level = conf.level, nsim = nsim, 
                     boot.ci.method = boot.ci.method ) -> ciboot1 ;
        ci1 <- ciboot1[1] ;
        ci2 <- ciboot1[2] ;
        type <- paste( "bootstrap", boot.ci.method, sep = "." ) ;
      }
      
      # job
      if (!is.null( round ) )
      {
        c( " ",
           length( var ), 
           "-",
           round( mean( var ), 
                  digits = round ), 
           round( ci1, 
                  digits = round ), 
           round( ci2, 
                  digits = round ),
           type,
           round( sd( var ), 
                  digits = round )
        ) ->
          output ;
      } else
      {
        c( " ", 
           length( var ), 
           "-", 
           mean( var ), 
           ci1, 
           ci2, 
           type,
           sd( var )
        ) ->
          output ;
      }
    }
    
    # Numeric var with only 1 possible value
    if ( is.numeric( var ) & 
         length( var ) > 0 & 
         nlevels( factor( as.character( var ) ) ) == 1 )
    {
      c(  "_",
          length( var ), 
          "-",
          "only 1",  "value:", 
          "", "", "" ) ->
        output ;
    } 
    
    # Var with 0 obs
    if ( length( var ) == 0 )
    {
      c( "_",
         length( var ), 
         "-",
         "has", "no", "observation", "", "" ) ->
        output ;
    } 
    
    # Not supported
    if ( is.null( output ) )
    {
      c( "_",
         length( var ), "-",
         "Class",
         "not",
         "supported", "", "" ) ->
        output ;
    } 
    
    # formating
    if ( is.null( dim( output ) ) )
    {
      data.frame( matrix( output,
                          nrow = 1),
                  stringsAsFactors = TRUE ) ->
        output ;
    }
    
    return( output )
  }
  
  ConfusionTable.Analysis <- function( x, y, name.x = "", name.y = "",
                                       na.rm = TRUE, conf.level = 0.95,
                                       binom.ci.method = "exact",
                                       pvalue.round = NULL, round = NULL  )
  {
    # Input condition
    if ( !is.factor( x ) ) { stop( "x is not a factor" );   } ;
    if ( !is.factor( y ) ) { stop( "y is not a factor" );   } ;
    if ( !is.character( name.x ) ) { stop( "name.x is not a factor" );   } ;
    if ( !is.character( name.y ) ) { stop( "name.y is not a factor" );   } ;
    if ( !is.logical( na.rm ) ) { stop( "na.rm is not TRUE or FALSE" );    } ;
    if ( !is.numeric( conf.level ) ) { stop( "conf.level is not numeric" );    } ;
    if ( !is.character( binom.ci.method ) ) { stop( "binom.ci.method is not a factor" );   } ;
    if ( !( is.numeric( pvalue.round ) | 
            is.null( pvalue.round ) ) ) { stop( "pvalue.round is neither numeric, neither NULL" );    } ;
    if ( !( is.numeric( round ) | 
            is.null( round ) ) ) { stop( "round is neither numeric, neither NULL" );    } ;
    
    # Domestic functions 
    
    ConfusionTable.Unique <- function( Reference, Prediction, 
                                       name.reference, name.prediction, 
                                       p.value )
    {
      # prepare
      table( Prediction, Reference ) -> ct ;
      
      ct[1,1] -> TP ;
      ct[2,2] -> TN ;
      ct[1,2] -> FP ;
      ct[2,1] -> FN ;
      
      TP + FN -> RP ;
      FP + TN -> RN ;
      TP + FP -> PP ;
      FN + TP -> PN ;
      
      
      TP / RP -> Se ;
      TN / RN -> Sp ;
      TP / PP -> PPV ;
      TP / PN -> NPV ;
      
      binom::binom.confint( TP, RP, 
                            conf.level = conf.level, 
                            methods = binom.ci.method )[5:6] -> 
        Se.CI ;
      binom::binom.confint( TN, RN, 
                            conf.level = conf.level, 
                            methods = binom.ci.method )[5:6] -> 
        Sp.CI ;
      binom::binom.confint( TP, PP, 
                            conf.level = conf.level, 
                            methods = binom.ci.method )[5:6] ->
        PPV.CI ;
      binom::binom.confint( TP, PN, 
                            conf.level = conf.level, 
                            methods = binom.ci.method )[5:6] -> 
        NPV.CI ;
      
      FN / RP -> FNR ;
      FP / RN -> FPR ;
      FP / PP -> FDR ;
      FN / PN -> FOR ;
      
      RP / sum( ct )  -> Pre ;
      (TP + TN) / sum( ct ) -> Acc ;
      
      Se / FPR -> PLR ;
      FNR / Sp -> NLR ;
      PLR / NLR -> DOR ;
      
      2 * TP / (2 * TP + FP + FN) -> F1 ;
      (TP * TN - FP * FN) / sqrt( (TP + FP) * (TP + FN) * (TN + FP) * (TN + FN) ) -> 
        MCC ;
      Se + Sp - 1 -> Informed ;
      PPV + NPV - 1 -> Marked ;
      
      # stock
      c( name.reference, name.prediction,
         colnames( ct )[1], colnames( ct )[2],
         Se * 100, Sp * 100, PPV * 100, NPV * 100, 
         p.value, 
         RP, RN, PP, PN,
         TP, TN, FP, FN, 
         Se * 100, Se.CI[1] * 100, Se.CI[2] * 100,
         Sp * 100, Sp.CI[1] * 100, Sp.CI[2] * 100,
         PPV * 100, PPV.CI[1] * 100, PPV.CI[2] * 100,
         NPV * 100, NPV.CI[1] * 100, NPV.CI[2] * 100,
         binom.ci.method,
         FNR * 100, FPR * 100, FDR * 100, FOR * 100,
         Pre * 100, Acc * 100,
         PLR, NLR, DOR, 
         F1, MCC, 
         Informed, Marked
      ) ->
        output ;
      
      unlist( output ) -> output ;
      
      # return 
      return( output )
    }
    
    # Load packages
    #active.packages( "coin", "binom" ) ;
    
    # Names
    if ( name.x == "" ) { name.x <- deparse( substitute( x ) ) ; }
    if ( name.y == "" ) { name.y <- deparse( substitute( y ) ) ; }
    
    # NA
    if ( na.rm ) 
    {
      na.omit( data.frame( x, y ) ) -> df ;
      df$x -> x ;
      df$y -> y ;
    } 
    
    # Format
    factor( x ) -> x ;
    factor( y ) -> y ;
    if ( nlevels( x ) != 2 ) { stop( "x has not 2 levels" );   } ;
    if ( nlevels( y ) != 2 ) { stop( "y has not 2 levels" );   } ;
    
    relevel( x, ref = levels( x )[2] ) -> xbis ;
    relevel( y, ref = levels( y )[2] ) -> ybis ;
    
    # Test
    coin::pvalue( coin::mh_test( table( x, y ), 
                                 distribution = exact() ) ) -> 
      p.value ;
    
    # Case 1
    ConfusionTable.Unique( Reference = x, 
                           Prediction = y, 
                           name.reference = name.x, 
                           name.prediction = name.y, 
                           p.value = p.value ) -> 
      case1 ;
    
    # Case 2
    ConfusionTable.Unique( Reference = y, 
                           Prediction = x, 
                           name.reference = name.y, 
                           name.prediction = name.x, 
                           p.value = p.value ) -> 
      case2 ;
    
    # Case 3
    ConfusionTable.Unique( Reference = xbis, 
                           Prediction = ybis, 
                           name.reference = name.x, 
                           name.prediction = name.y, 
                           p.value = p.value ) -> 
      case3 ;
    
    # Case 4
    ConfusionTable.Unique( Reference = ybis, 
                           Prediction = xbis, 
                           name.reference = name.y, 
                           name.prediction = name.x, 
                           p.value = p.value ) -> 
      case4 ;
    
    # fusion
    data.frame( rbind( case1, case2, case3, case4 ) ) ->
      output ;
    
    c( "Reference Condition", "Predicted Condition", "Positive", "Negative",
       "Sensitivity (%)", "Specificity (%)", 
       "Positive predictive value (%)", "Negative predictive value (%)",
       "Exact Marginal Homogeneity Test p-value",
       "Reference positive (n)", "Reference negative (n)", 
       "Prediction positive (n)", "Prediction negative (n)",
       "True positive (n)", "True negative (n)", 
       "False positive (n)", "False negative (n)",
       "Sensitivity (power, recall, hit rate, true positive rate) (%)", 
       "Se CI lb", "Se CI ub", 
       "Specificity (true negative rate) (%)",
       "Sp CI lb", "Sp CI ub", 
       "Predictive positive value (precision) (%)",
       "PPV CI lb", "PPV CI ub", 
       "Negative predictive value (%)",
       "NPV CI lb", "NPV CI ub", 
       "CI binomial method",
       "False negative rate (beta type II error,miss rate) (%)",
       "False positive rate (alpha type I error, fall-out) (%)",
       "False discovery rate (%)",
       "False omission rate (%)",
       "Prevalence (%)", 
       "Accuracy (%)",
       "Positive likelihood ratio", "Negative likelihood ratio",
       "Diagnostic odds ratio",
       "F1 score",
       "Matthews correlation coefficient (MCC)",
       "Informedness (bookmaker informedness)",
       "Markedness"
    ) -> 
      colnames( output ) ;
    
    NULL -> rownames( output ) ;
    
    # Round 
    if( !is.null( round ) )
    {
      for ( a in c(  "Sensitivity (%)", "Specificity (%)", 
                     "Positive predictive value (%)", "Negative predictive value (%)",
                     "Sensitivity (power, recall, hit rate, true positive rate) (%)", 
                     "Se CI lb", "Se CI ub", 
                     "Specificity (true negative rate) (%)",
                     "Sp CI lb", "Sp CI ub", 
                     "Predictive positive value (precision) (%)",
                     "PPV CI lb", "PPV CI ub", 
                     "Negative predictive value (%)",
                     "NPV CI lb", "NPV CI ub", 
                     "False negative rate (beta type II error,miss rate) (%)",
                     "False positive rate (alpha type I error, fall-out) (%)",
                     "False discovery rate (%)",
                     "False omission rate (%)",
                     "Prevalence (%)", 
                     "Accuracy (%)",
                     "Positive likelihood ratio", "Negative likelihood ratio",
                     "Diagnostic odds ratio",
                     "F1 score",
                     "Matthews correlation coefficient (MCC)",
                     "Informedness (bookmaker informedness)",
                     "Markedness"
      ) )
      {
        round( as.numeric( as.character( output[, a ] ) ), digits = round ) ->
          output[, a ] ; 
      }
    }
    
    if( !is.null( pvalue.round ) )
    {
      round( as.numeric( as.character( output[, "Exact Marginal Homogeneity Test p-value" ] ) ), 
             digits = pvalue.round ) ->
        output[, "Exact Marginal Homogeneity Test p-value" ] ; 
    }
    
    return( output )
  }
  
  fun.bivariate.r <- function( var, group, identifier,
                               Confusion.Table = TRUE,
                               No.Test.Details = TRUE,
                               name.var,
                               name.group,
                               nsim = 10000, 
                               seed = 123,
                               Continuity.correct = TRUE,
                               pvalue.round = NULL,
                               round = NULL )
    
  {
    # domestic function
    
    CramersV <- function( cont.table )
    {
      chisq.test( cont.table )$statistic -> X2 ;
      
      ( X2 / ( sum( cont.table )  * ( min( nrow( cont.table ), ncol( cont.table ) ) - 1 ) ) 
      ) -> V2 ;
      
      sqrt( V2 ) -> V
      "Cramer's V"-> names( V ) ;
      
      return( V )   
    } 
    
    eta.squared <- function( x, y )
    {
      if ( !is.factor( x ) ) { stop( "x is not factor" );  } ;
      if ( !is.numeric( y ) ) { stop( "y is not numeric" );  } ;
      
      means <- tapply( y, INDEX = x, FUN = mean ) ;
      samples <- tapply( y, INDEX = x, FUN = length ) ;
      varinter <- sum( samples * ( means - mean( y ) )^2 ) / length( y ) ;
      vartot <- var( y ) ;
      
      return( varinter / vartot ) ;
    };
    
    r.pb <- function( x, y )
    {
      if ( !is.factor( x ) ) { stop( "x is not factor" );  } ;
      if ( !is.numeric( y ) ) { stop( "y is not numeric" );  } ;
      
      sd <- sqrt( sum( (y - mean(y) )^2 ) / (length(y) - 1) ) ;
      means <- tapply( y, INDEX = x, FUN = mean ) ;
      lengths <- tapply( y, INDEX = x, FUN = length ) ;
      
      ( (means[2] - means[1]) / sd ) * sqrt( (lengths[1] * lengths[2]) / 
                                               (length(y) * (length(y) - 1)) )
    }
    
    CohenD <- function( x, y )
    {
      if ( !is.factor( x ) ) { stop( "x is not factor" );  } ;
      if ( !is.numeric( y ) ) { stop( "y is not numeric" );  } ;
      
      SCEs <- tapply( y, INDEX = x, FUN = function(a){sum( (a - mean(a) )^2 ) / (length(a) - 1) } ) ;
      lengths <- tapply( y, INDEX = x, FUN = length ) ;
      
      means <- tapply( y, INDEX = x, FUN = mean ) ;
      
      s <- sqrt( ( (lengths[1] - 1) * SCEs[1] + (lengths[2] - 1) * SCEs[2] ) / 
                   (lengths[1] + lengths[2] - 2) ) ;
      
      (means[2] - means[1]) / s
    }
    
    HedgeGstar <- function( x, y )
    {
      if ( !is.factor( x ) ) { stop( "x is not factor" );   } ;
      if ( !is.numeric( y ) ) { stop( "y is not numeric" );   } ;
      
      SCEs <- tapply( y, INDEX = x, FUN = function(a){sum( (a - mean(a) )^2 ) / (length(a) - 1) } ) ;
      lengths <- tapply( y, INDEX = x, FUN = length ) ;
      means <- tapply( y, INDEX = x, FUN = mean ) ;
      
      s <- sqrt( ( (lengths[1] - 1) * SCEs[1] + (lengths[2] - 1) * SCEs[2] ) / 
                   (lengths[1] + lengths[2] - 2) ) ;
      
      (means[2] - means[1]) / s -> g
      
      (1 - (3 / (4 * (lengths[1] + lengths[2]) - 9) ) ) * g 
    }
    
    CliffDelta2 <- function( x, y )
    {
      if ( !is.numeric( x ) ) { stop( "x is not numeric" );  } ;
      if ( !is.factor( y ) ) { stop( "y is not factor" );  } ;
      
      wilcox.test( x ~ y )$statistic -> W ;
      
      2 * W / ( length(x) * length(y) ) - 1 
    }
    
    RankBiserialCor2 <- function( x, y )
    {
      if ( !is.numeric( x ) ) { stop( "x is not numeric" );  } ;
      if ( !is.factor( y ) ) { stop( "y is not factor" );  } ;
      
      wilcox.test( x ~ y )$statistic -> W ;
      
      1 - 2 * W / ( length(x) * length(y) )
    }
    
    Chance.Corrected.Measure.Of.Effect.Size <- function( var, group, identifier )
    {
      
      # prepare matrix
      as.numeric( var ) - 1 -> var.num ;
      data.frame( var = var.num, group = group, identifier = identifier ) |>
        tidyr::spread(  key = group, value = var ) |>
        dplyr::select(  -identifier ) |>
        as.matrix() -> 
        matrix1 ;
      
      # prepare dimension
      dim( matrix1 )[2] -> k ;
      dim( matrix1 )[1] -> b ; 
      0 -> res ;
      
      # job
      for ( i in 1:k )
      {
        for ( j in 1:(b - 1) )
        {
          for ( l in (j + 1):b )
          {
            res + abs( matrix1[j,i] - matrix1[l,i] ) ->
              res ;
          }
        }
      }
      
      1 / (k * choose( b, 2 ) ) * res -> 
        delta ;
      
      rowSums( matrix1 ) / k  -> 
        pi ;
      
      0 -> spi ;
      0 -> spi2 ;
      
      for ( i in 1:b )
      {
        spi + pi[i] -> spi ;
        spi2 + pi[i] * (1 - pi[i]) -> spi2 ; 
      }
      
      2 / (b * (b - 1)) * (spi *(b - spi) -spi2) ->  mudelta ;
      
      1 - delta / mudelta -> output ;
      
      # output
      return( unname( output ) )
    }
    
    
    # data 
    data.frame( var = var, 
                group = factor( group ), 
                identifier = factor( identifier ),
                stringsAsFactors = FALSE ) ->
      df ;
    
    # seed
    set.seed( seed ) ;
    
    # primer
    NULL -> output ;
    
    # Two factors of two levels
    if ( is.factor( var ) &
         nlevels( df$var ) > 1 &
         nlevels( df$group ) > 1 &
         all( table( df$var, df$group ) > 2 ) )
    {
      # compute 
      if ( nlevels( df$group ) == 2 )
      {
        table( df[ df[, "group"] == levels( df$group )[1], "var" ], 
               df[ df[, "group"] == levels( df$group )[2], "var" ]  ) ->
          table1 ;
        table1[1,2] + table1[2,1] -> effectif ;
        
        if ( nlevels( df$var ) == 2 ) 
        { Continuity.correct -> correction } else
        { FALSE -> correction } 
        
        mcnemar.test( table1, correct = correction ) -> mcnemar ;
        
        CramersV( table1 ) -> V ;
        pwr::ES.w2( prop.table( table1 ) ) -> omega ;
      } else
      {
        NA -> effectif ;
        
        "-" -> correction ;
        
        list( method = "Test not possible",
              statistic = NA,
              parameter = NA,
              p.value = NA
        ) ->
          mcnemar ;
        
        NA -> V ;
        NA -> omega ;
      }
      
      if ( nlevels( df$var ) == 2 )
      {
        DescTools::CochranQTest(  var ~ group | identifier, data = df ) -> q.cochran ;
        
        q.cochran$statistic / ( nlevels(df$identifier) * (nlevels(df$group) - 1) ) ->
          eta.squared.Q ;
        Chance.Corrected.Measure.Of.Effect.Size( df$var, df$group, df$identifier ) -> 
          R ;
      } else
      {
        list( method = "Test not possible",
              statistic = NA,
              parameter = NA,
              p.value = NA
        ) ->
          q.cochran ;
        
        NA -> eta.squared.Q ;
        NA -> R ;
      }
      
      coin::mh_test( var ~ group | identifier,
                     data = df,    
                     distribution = coin::approximate( nsim ) ) -> mh ;
      if ( is.nan( coin::statistic( mh ) ) ) { NA -> mh.p ; } else { coin::pvalue( mh ) -> mh.p ; } 
      
      # fusion
      c( "factor",
         name.var,
         name.group,
         nrow( df ), 
         nrow( data ) - nrow( df ),
         mh.p,
         paste0( mh@method,
                 ": MonteCarlo approximation based on ",
                 nsim,
                 " simulations"
         ),
         effectif,
         mcnemar$method,
         correction,
         mcnemar$statistic,
         mcnemar$parameter,
         mcnemar$p.value,
         q.cochran$method,
         q.cochran$statistic,
         q.cochran$parameter,
         q.cochran$p.value,
         mh@method,
         mh@distribution@name,
         nsim,
         coin::statistic( mh ),
         mh.p,
         eta.squared.Q,
         R,
         V,
         omega
      ) -> 
        output ;
      
      c( "factor", 
         "var", "group", 
         "N", "Missing",
         "p-value",
         "Method",
         "Sum of no matches cells",
         "McNemar method",
         "Continuity correction",
         "McNemar's Chi-squared",
         "McNemar's Degree of freedom",
         "McNemar's p-value",
         "Cochran's Q method",
         "Cochran's Q statistic Q",
         "Cochran's Q Degree of freedom",
         "Cochran's Q p-value",
         "Marginal homogeneity method",
         "Marginal homogeneity's distribution",
         "Marginal homogeneity's number of simulation",
         "Marginal homogeneity's statistic",
         "Marginal homogeneity's p-value",
         "Eta squared Q",
         "Chance-corrected measure of effect size R",
         "Cramer's V",
         "Cohen's omega"
      ) -> 
        names( output ) ;
      
      # Round 
      if( !is.null( round ) )
      {
        for ( round.a in c(
          "Sum of no matches cells",
          "McNemar's Chi-squared",
          "McNemar's Degree of freedom",
          "Cochran's Q statistic Q",
          "Cochran's Q Degree of freedom",
          "Marginal homogeneity's statistic",
          "Cramer's V",
          "Cohen's omega",
          "Eta squared Q",
          "Chance-corrected measure of effect size R"
        ) )
        {
          round( as.numeric( as.character( output[ round.a ] ) ), 
                 digits = round ) ->
            output[ round.a ] ; 
        }
      }
      
      if( !is.null( pvalue.round ) )
      {
        for ( round.a in c( 
          "p-value",
          "McNemar's p-value",
          "Cochran's Q p-value",
          "Marginal homogeneity's p-value"
        ) )
        {
          p.round( as.numeric( output[ which( names( output ) == 
                                                round.a ) ] ),
                   digits = pvalue.round ) ->
            output[ which( names( output ) == round.a ) ] ; 
        }
      }
      
    }
    
    # Confusion table
    if ( Confusion.Table )
    {
      if ( is.factor( var ) &
           nlevels( var ) == 2 &
           nlevels( df$group ) == 2 &
           all( table( df$var, df$group ) > 2 ) )
      {
        ConfusionTable.Analysis( df[ df[, "group"] == levels( df$group )[1], "var" ], 
                                 df[ df[, "group"] == levels( df$group )[2], "var" ], 
                                 name.x = levels( df$group )[1], 
                                 name.y = levels( df$group )[2],
                                 na.rm = na.rm, conf.level = conf.level,
                                 binom.ci.method = binom.ci.method,
                                 pvalue.round = pvalue.round, 
                                 round = round  ) ->
          tmp.output ;
        
        cbind( "tabconfusion", 
               name.var,
               name.group,
               nrow( df ), 
               nrow( data ) - nrow( df ),
               tmp.output 
        ) -> tmp.output ;
        
        rbind.force( output, tmp.output ) -> output ; 
      }
    }
    
    # One factor and one numeric
    if ( is.numeric( var ) &
         nlevels( factor( df$var ) ) > 3 &
         all( table( df$group ) > 4 ) &
         nlevels( df$group ) > 1 
    )
    {
      # compute
      aov( var ~ group + Error( identifier/group ), data = df ) -> aov1 ;
      proj( aov1 )[[3]][, "Residuals"] -> residuals1 ;
      if ( length( residuals1 ) < 5000 ) 
      { shapiro.test( residuals1 ) -> shapiro ; }  else
      { list( "p.value" = NA ) -> shapiro ; }
      nortest::ad.test( residuals1) -> anderson ;
      moments::jarque.test( residuals1 ) -> jarque ;
      if ( any( c( shapiro$p.value, anderson$p.value, jarque$p.value ) < 0.05 ) ) 
      { FALSE -> normal } else { TRUE -> normal } 
      
      NULL -> tab ;
      for ( i in 1:nlevels( df$group ) )
      {
        cbind( tab, 
               df[ df[, "group"] == levels( df$group )[i], "var" ] ) ->
          tab ;
      }
      lm( tab ~ 1 ) ->
        m1 ;
      car::Anova( m1, type = 3, 
                  idata = data.frame( group = as.factor( levels( df$group ) ) ), 
                  idesign = ~ group , 
                  multivariate = FALSE ) -> 
        ANOVA ; 
      summary( ANOVA, multivariate = FALSE ) -> aov.tab ;
      if ( is.na( aov.tab$sphericity.tests[2] ) )
      {
        "-" -> sphericity ;
      } else
      {
        if (  aov.tab$sphericity.tests[2] > 0.05 )
        { TRUE -> sphericity } else { FALSE -> sphericity }
      }
      
      friedman.test( var ~ group | identifier, data = df ) -> friedman ;
      quade.test( var ~ group | identifier, data = df ) -> quade ;
      
      
      df |> tidyr::spread(  key = group, value = var ) |>
        dplyr::select( -identifier ) |> 
        (function(x) lapply( x, function(a,b) { na.omit( a == b ) }, b = x) )() |>
        cbind.force() |>
        data.frame( stringsAsFactors = FALSE) |>
        lapply(  all) |> 
        unlist() |>
        sum() -> Nb.Identical ;
      if ( nlevels( df$group ) == Nb.Identical )
      {
        heplots::etasq( ANOVA )[2,1] -> eta2 ;
        coin::symmetry_test(  var ~ group | identifier, 
                              data = df,
                              distribution = coin::approximate( nsim ) ) -> sm ;
        coin::pvalue( sm ) -> sm.p ;
      } else
      {
        NA -> eta2 ;
        
        setClass( "coin1", slots = c( name = "character" ) )
        setClass( "coin2", slots = c( teststatistic = "numeric" ) )
        setClass( "coin", slots = c( method = "character", 
                                     distribution = "coin1",
                                     statistic = "coin2" ) )
        new( "coin", method = "Test not possible" ) -> sm ;
        "-" -> sm@distribution@name ;
        as.numeric(NA) -> sm@statistic@teststatistic ;
        NA -> sm.p ;
      }
      
      
      if ( sphericity != "-" )
      {
        if ( normal & sphericity ) 
        {
          aov.tab$univariate.tests[2,6] ->  p.final ;
          "Univariate Type III Repeated-Measures ANOVA Assuming Sphericity" -> 
            method.final ; 
        }
        if ( normal & !sphericity ) 
        {
          aov.tab$pval.adjustments[2] -> p.final ;
          "Univariate Type III Repeated-Measures ANOVA with Greenhouse-Geisser Correction for Departure from Sphericity" -> 
            method.final ;
        }
      } else
      {
        if ( normal ) 
        {
          aov.tab$univariate.tests[2,6] ->  p.final ;
          "Univariate Type III Repeated-Measures ANOVA" -> 
            method.final ; 
        }
      }
      if ( !normal ) 
      {
        sm.p -> p.final ;
        paste0( sm@method,
                ": MonteCarlo approximation based on ",
                nsim,
                " simulations"
        ) -> method.final ;
      }
      
      
      if ( nlevels( df$group ) == 2 &
           !all( na.omit( 
             df$var[ df$group == levels( df$group )[1] ]  == 
             df$var[ df$group == levels( df$group )[2] ] 
           ) ) &
           nlevels( factor( 
             df$var[ df$group == levels( df$group )[1] ] 
           ) ) > 3 &
           nlevels( factor( 
             df$var[ df$group == levels( df$group )[2] ]
           ) ) > 3 )
      {
        df$var[ df$group == levels( df$group )[2] ] - df$var[ df$group == levels( df$group )[1] ] ->
          dif1 ;
        if ( length( dif1 ) < 5000 ) 
        { shapiro.test( dif1 ) -> shapiro1 ; }  else
        { list( "p.value" = NA ) -> shapiro1 ; }
        nortest::ad.test( dif1) -> anderson1 ;
        moments::jarque.test( dif1 ) -> jarque1 ;
        if ( any( c( shapiro1$p.value, anderson1$p.value, jarque1$p.value ) < 0.05 ) ) 
        { FALSE -> normal } else { TRUE -> normal } 
        
        t.test( df$var ~ df$group, paired = TRUE ) -> student ;
        wilcox.test( df$var ~ df$group, 
                     paired = TRUE, 
                     correct = Continuity.correct ) -> wilcoxon ;
        paste( levels( df$group )[1], "->", levels( df$group )[2]) -> direction;
        r.pb( df$group, df$var ) -> rpb ;
        CohenD( df$group, df$var ) -> cohend ;
        HedgeGstar( df$group, df$var ) -> hedgegstar ;
        RankBiserialCor2( df$var, df$group ) ->  rbc ;
        CliffDelta2( df$var, df$group ) -> cliff ;
        
        if ( normal  ) 
        {
          student$p.value -> p.final ; 
          student$method -> method.final
        } else
        {
          wilcoxon$p.value -> p.final ; 
          wilcoxon$method -> method.final
        }
      } else
      {
        list( "p.value" = NA ) -> shapiro1 ; 
        list( "p.value" = NA ) -> anderson1 ; 
        list( "p.value" = NA ) -> jarque1 ; 
        
        list(
          method = "Test not possible because: more than two levels or all values equal in two groups or less than four different possible values in one of groups",
          statistic = NA,
          parameter = NA,
          p.value = NA
        ) -> student ;
        list(
          method = "Test not possible",
          statistic = NA,
          p.value = NA
        ) -> wilcoxon ;
        
        "" -> direction;
        NA -> rpb ;
        NA -> cohend ;
        NA -> hedgegstar ;
        NA -> rbc ;
        NA -> cliff ;
      }
      
      
      # fusion
      c( "mix",
         name.var,
         name.group,
         nrow( df ), 
         nrow( data ) - nrow( df ),
         p.final,
         method.final,
         normal,
         sphericity,
         "Univariate Type III Repeated-Measures ANOVA Assuming Sphericity",
         aov.tab$univariate.tests[2,5],         
         aov.tab$univariate.tests[2,2],
         aov.tab$univariate.tests[2,4],
         aov.tab$univariate.tests[2,6],
         "Univariate Type III Repeated-Measures ANOVA with Greenhouse-Geisser Correction for Departure from Sphericity",
         aov.tab$pval.adjustments[1],
         aov.tab$pval.adjustments[2],
         "Univariate Type III Repeated-Measures ANOVA with Huynh-Feldt Correction for Departure from Sphericity",
         aov.tab$pval.adjustments[3],
         aov.tab$pval.adjustments[4],
         friedman$method,
         friedman$statistic,
         friedman$parameter,
         friedman$p.value,
         quade$method,
         quade$statistic,
         quade$parameter[1],
         quade$parameter[2],
         quade$p.value,
         sm@method,
         sm@distribution@name,
         nsim,
         sm@statistic@teststatistic,
         sm.p,
         student$method,
         student$statistic,
         student$parameter,
         student$p.value,
         wilcoxon$method,
         Continuity.correct,
         wilcoxon$statistic,
         wilcoxon$p.value,
         eta2,
         direction,
         rpb,
         cohend,
         hedgegstar,
         rbc,
         cliff,
         aov.tab$sphericity.tests[2],
         shapiro$p.value, 
         anderson$p.value,
         jarque$p.value,
         shapiro1$p.value, 
         anderson1$p.value,
         jarque1$p.value
      ) -> 
        output ;
      
      c( "mix",
         "var", "group", 
         "N", "Missing",
         "p-value",
         "Method",
         "Normality",
         "Sperecity",
         "Anova method",
         "ANOVA F statistic",
         "ANOVA Degree of freedom numerator",
         "ANOVA Degree of freedom denominator",
         "ANOVA p-value",
         "Greenhouse-Geisser method",
         "Greenhouse-Geisser epsilon",
         "Greenhouse-Geisser p-value",
         "Huynh-Feldt method",
         "Huynh-Feldt epsilon",
         "Huynh-Feldt p-value",
         "Friedman method",
         "Friedman chi-squared",
         "Friedman degree of freedom",
         "Friedman p-value",
         "Quade method",
         "Quade F statistic",
         "Quade degree of freedom numerator",
         "Quade degree of freedom denominator",
         "Quade p-value",
         "Symetry method",
         "Symetry's distribution",
         "Symetry's number of simulation ",
         "Symetry's statistic",
         "Symetry's p-value",
         "T method",
         "T ratio",
         "T degree of freedom",
         "T p-value",
         "Wilcoxon method",
         "Continuity correction",
         "Wilcoxon statistic",
         "Wilcoxon p-value",
         "Partial eta-squared",
         "Direction for size effects",
         "Point biserial correlation coefficient r.pb",
         "Cohen's d",
         "Hedge's g*",
         "Rank biserial correlation",
         "Cliff's delta",
         "Mauchly p-value",
         "Anova residuals Shapiro p-value",
         "Anova residuals Anderson-Darling p-value",
         "Anova residuals Jarque-Bera p-value",
         "Difference Shapiro p-value",
         "Difference Anderson-Darling p-value",
         "Difference Jarque-Bera p-value"
      ) -> names( output ) ;
      
      # Round 
      if( !is.null( round ) )
      {
        for ( round.a in c(
          "ANOVA F statistic",
          "ANOVA Degree of freedom numerator",
          "ANOVA Degree of freedom denominator",
          "Greenhouse-Geisser epsilon",
          "Huynh-Feldt epsilon",
          "Friedman chi-squared",
          "Friedman degree of freedom",
          "Quade F statistic",
          "Quade degree of freedom numerator",
          "Quade degree of freedom denominator",
          "Symetry's statistic",
          "T ratio",
          "T degree of freedom",
          "Wilcoxon statistic",
          "Partial eta-squared",
          "Direction for size effects",
          "Point biserial correlation coefficient r.pb",
          "Cohen's d",
          "Hedge's g*",
          "Rank biserial correlation",
          "Cliff's delta"
        ) )
        {
          round( as.numeric( as.character( output[ round.a ] ) ), 
                 digits = round ) ->
            output[ round.a ] ; 
        }
      }
      
      if( !is.null( pvalue.round ) )
      {
        for ( round.a in c( 
          "p-value",
          "ANOVA p-value",
          "Greenhouse-Geisser p-value",
          "Huynh-Feldt p-value",
          "Friedman p-value",
          "Quade p-value",
          "Symetry's p-value",
          "T p-value",
          "Wilcoxon p-value",
          "Mauchly p-value",
          "Anova residuals Shapiro p-value",
          "Anova residuals Anderson-Darling p-value",
          "Anova residuals Jarque-Bera p-value",
          "Difference Shapiro p-value",
          "Difference Anderson-Darling p-value",
          "Difference Jarque-Bera p-value"
        ) )
        {
          p.round( as.numeric( output[ which( names( output ) == 
                                                round.a ) ] ),
                   digits = pvalue.round ) ->
            output[ which( names( output ) == round.a ) ] ; 
        }
      }
    }
    
    # No test possible
    if ( is.null( output ) )
    {
      if ( No.Test.Details )
      {
        # tests
        !( is.factor( df$var ) |
             is.numeric( df$var ) ) -> notnumfact ;
        
        if ( is.factor( var ) )
        {
          !( nlevels( df$var ) > 1 ) -> isfactor.var ;
          !all( table( df$var, df$group ) > 2 ) -> contingencytab3 ;
        } else
        {
          "-" -> isfactor.var ;
          "-" -> contingencytab3 ;
        }
        
        !( nlevels( df$group ) > 1 ) -> isfactor.group
        
        if ( is.numeric( var ) )
        {
          !( nlevels( factor( df$var ) ) > 3 ) -> less4numeric.var
          !all( table( df$group ) > 4 ) -> less5 ;
        } else
        {
          "-" -> less4numeric.var ;
          "-" -> less5 ;
        }
        
        # fusion
        c( "other", 
           name.var,
           name.group,
           nrow( df ), 
           nrow( data ) - nrow( df ),
           class( df$var ),
           "No test because:",
           notnumfact, 
           isfactor.var,
           isfactor.group,
           less4numeric.var,
           contingencytab3,
           less5
        ) -> output
        
        c( "other", 
           "var", "group", 
           "N", "Missing",
           "class var",
           "No test because:", 
           "Is not factor or numeric",
           "Just 1 level for factor (var)",
           "Just 1 level for factor (group)",
           "Less than 4 different values for numeric (var)", 
           "Less than 3 observations for each cells (factor)",
           "Less than 5 observations by level (numeric)"
        ) -> 
          names( output ) 
      } else
      {
        c(
          "other", 
          name.var,
          name.group,
          nrow( df ), 
          nrow( data ) - nrow( df ),
          "Test not possible because: var is not factor or numeric, just 1 level for group or var, less than 4 different values for var numeric, less than 5 values per group for var, less than 3 observations for each cells" ) -> 
          output ;
      }
      
    }
    
    return( output ) ;
  }
  
  fun.a <- function( a, data.vars, data.group, data.identifier  )
  {
    #print( a ) ; print( colnames( data.vars )[a] ) ;
    
    # Prepara data
    data.frame( var = data.vars[,a], 
                group = factor( data.group ), 
                identifier = factor( data.identifier ),
                stringsAsFactors =FALSE ) ->
      df ;
    
    # NA
    if ( na.rm )
    {
      na.omit( df ) -> df ;
      
      if ( any( table( df$identifier ) < 
                max( table( df$identifier ) ) ) )
      {
        subset( df, !( identifier %in% 
                         levels( df$identifier )[ 
                           which( table( df$identifier ) < 
                                    max( table( df$identifier ) ) ) ] ) ) ->
          df ;
        
        if ( is.factor( df$var ) ) { factor( df$var ) -> df$var }
      }
    } else
    {
      if ( any( is.na( df ) ) ) { stop( "data coutains NA." ) ;  }  
    }
    
    # bi
    fun.bivariate.r( var = df$var, 
                     group = df$group, 
                     identifier = df$identifier,
                     Confusion.Table = FALSE,
                     No.Test.Details = FALSE,
                     name.var = colnames( data.vars )[a],
                     name.group = group,
                     nsim = nsim, 
                     seed = seed,
                     Continuity.correct = Continuity.correct,
                     pvalue.round = pvalue.round,
                     round = round ) ->
      bi ; 
    
    bi[-c(1:5)] -> bi
    
    # uni
    cbind.force( lapply( 1:nlevels( factor( data.group ) ),
                         FUN = fun.univariate,
                         variable = data.vars[,a],
                         group = data.group ),
                 empty = "" ) ->
      uni ;
    
    # factor
    if ( is.factor( df$var ) )
    {
      cbind.force( colnames( data.vars )[a], 
                   dim( df )[1],
                   ( dim( data.vars )[1] - dim( df )[1] ),
                   data.frame( uni,
                               stringsAsFactors = FALSE ),
                   data.frame( matrix( bi,
                                       nrow = 1 ),
                               stringsAsFactors = FALSE ),
                   empty = "" ) ->
        output.a ;
      
      cbind( cbind( paste0( "factor", "-",
                            nlevels( df$group ), "-",
                            StringContatener( levels( df$group ), "_" ) ),
                    group ),
             output.a ) -> 
        output.a ;
    }
    
    # Numeric
    if ( is.numeric( df$var ) )
    {
      cbind.force( colnames( data.vars )[a], 
                   dim( df )[1],
                   ( dim( data.vars )[1] - dim( df ) ),
                   uni,
                   data.frame( matrix( bi,
                                       nrow = 1 ),
                               stringsAsFactors = FALSE ),
                   empty = "" ) ->
        output.a ;
      
      cbind( cbind( paste0( "numeric", "-",
                            nlevels( df$group ), "-",
                            StringContatener( levels( df$group ), "_" ) ),
                    group ),
             output.a ) -> 
        output.a ;
    }
    
    # Other 
    if ( uni[1,1] == "_" )
    {
      cbind.force( colnames( data.vars )[a], 
                   dim( df )[1],
                   ( dim( data.vars )[1] - dim( df )[1] ),
                   uni,
                   empty = "" ) ->
        output.a ;
      
      cbind( cbind( paste0( "other", "-",
                            nlevels( df$group ), "-",
                            StringContatener( levels( df$group ), "_" ) ),
                    group ),
             output.a ) -> 
        output.a ;
    }
    
    # output
    return( output.a )
  }
  
  # Load packages
  download.packages( "furrr",  "pwr", "moments", "nortest", "binom",
                     "coin", "DescTools", "afex", "heplots", "dplyr", "tidyr" ) ;
  
  
  # prepare data
  #=============
  data[, which( !( colnames( data ) %in% group ) ) ] -> 
    data.vars ;
  
  data.vars[, which( !( colnames( data.vars ) %in% identifier ) ) ] -> 
    data.vars ; 
  
  data[, which( colnames( data ) %in% group ) ] -> 
    data.group ;
  
  data[, which( colnames( data ) %in% identifier ) ] -> 
    data.identifier ;
  
  # job
  #====
  
  furrr::future_map( 
    1:dim( data.vars )[2], 
    fun.a,
    data.vars = data.vars,
    data.group = data.group,
    data.identifier = data.identifier,
    .options = furrr::furrr_options( seed = seed ), .progress = T 
  ) |>
    rbind.force( empty = "" ) ->
    output ;
  
  # Output
  #=======
  c( 
    "class", 
    "var", "group", 
    "N", "Missing",
    "p-value",
    "Method",
    "Sum of no matches cells",
    "McNemar method",
    "Continuity correction",
    "McNemar's Chi-squared",
    "McNemar's Degree of freedom",
    "McNemar's p-value",
    "Cochran's Q method",
    "Cochran's Q statistic Q",
    "Cochran's Q Degree of freedom",
    "Cochran's Q p-value",
    "Marginal homogeneity method",
    "Marginal homogeneity's distribution",
    "Marginal homogeneity's number of simulation",
    "Marginal homogeneity's statistic",
    "Marginal homogeneity's p-value",
    "Eta squared Q",
    "Chance-corrected measure of effect size R",
    "Cramer's V",
    "Cohen's omega"
  )[-c(1:5)] -> titles.factor
  
  c(
    "class",
    "var", "group", 
    "N", "Missing",
    "p-value",
    "Method",
    "Normality",
    "Sperecity",
    "Anova method",
    "ANOVA F statistic",
    "ANOVA Degree of freedom numerator",
    "ANOVA Degree of freedom denominator",
    "ANOVA p-value",
    "Greenhouse-Geisser method",
    "Greenhouse-Geisser epsilon",
    "Greenhouse-Geisser p-value",
    "Huynh-Feldt method",
    "Huynh-Feldt epsilon",
    "Huynh-Feldt p-value",
    "Friedman method",
    "Friedman chi-squared",
    "Friedman degree of freedom",
    "Friedman p-value",
    "Quade method",
    "Quade F statistic",
    "Quade degree of freedom numerator",
    "Quade degree of freedom denominator",
    "Quade p-value",
    "Symetry method",
    "Symetry's distribution",
    "Symetry's number of simulation ",
    "Symetry's statistic",
    "Symetry's p-value",
    "T method",
    "T ratio",
    "T degree of freedom",
    "T p-value",
    "Wilcoxon method",
    "Continuity correction",
    "Wilcoxon statistic",
    "Wilcoxon p-value",
    "Partial eta-squared",
    "Direction for size effects",
    "Point biserial correlation coefficient r.pb",
    "Cohen's d",
    "Hedge's g*",
    "Rank biserial correlation",
    "Cliff's delta",
    "Mauchly p-value",
    "Anova residuals Shapiro p-value",
    "Anova residuals Anderson-Darling p-value",
    "Anova residuals Jarque-Bera p-value",
    "Difference Shapiro p-value",
    "Difference Anderson-Darling p-value",
    "Difference Jarque-Bera p-value"
  )[-c(1:5)] -> titles.mix
  
  NULL -> output.tmp
  for ( i in levels( factor( output[,1] ) ) )
  {
    if ( grepl( "factor", i ) )
    {
      
      c(  i, group, group, group, group ) -> levels.tmp
      for (j in strsplit( strsplit( i, "-" )[[1]][3], "_" )[[1]] )
      {
        c( levels.tmp,
           "---",
           rep( j, 7)
        ) -> levels.tmp
      }
      
      rbind.force( output.tmp,
                   levels.tmp, 
                   c( c( i, group, "Variable", "N", "Missing" ), 
                      rep( c( "---", "Group N", "Level", "%", 
                              "CI lb", "CI ub", "CI type", "Count" ), 
                           times = strsplit( i, "-" )[[1]][2] ),
                      titles.factor ),
                   output[ output[,1] == i, ],
                   empty = "" ) ->
        output.tmp ; 
    }
    
    
    if ( grepl( "numeric", i ) )
    {
      
      c(  i, group, group, group, group ) -> levels.tmp
      for (j in strsplit( strsplit( i, "-" )[[1]][3], "_" )[[1]] )
      {
        c( levels.tmp,
           "---",
           rep( j, 7)
        ) -> levels.tmp
      }
      
      rbind.force( output.tmp,
                   levels.tmp, 
                   c( c( i, group, "Variable", "N", "Missing" ), 
                      rep( c( "---", "Group N", "-", "Mean", 
                              "CI lb", "CI ub", "CI type", "Sd" ), 
                           times = strsplit( i, "-" )[[1]][2] ),
                      titles.mix ),
                   output[ output[,1] == i, ],
                   empty = "" ) ->
        output.tmp ; 
    }
    
    if ( grepl( "other", i ) )
    {
      
      c(  i, group, group, group, group ) -> levels.tmp
      for (j in strsplit( strsplit( i, "-" )[[1]][3], "_" )[[1]] )
      {
        c( levels.tmp,
           "---",
           rep( j, 7)
        ) -> levels.tmp
      }
      
      rbind.force( output.tmp,
                   levels.tmp, 
                   c( c( i, group, "Variable", "N", "Missing" ), 
                      rep( c( "---", "Group N", "-", "-", 
                              "-", "-", "-", "-" ), 
                           times = strsplit( i, "-" )[[1]][2] ),
                      "No tests for other" ),
                   output[ output[,1] == i, ],
                   empty = "" ) ->
        output.tmp ; 
    }
  }
  output.tmp -> output ;
  
  
  c( "class", "group", "variable", "N", "Missing", 
     paste( "col", 6:dim( output )[2], sep = "" ) ) ->
    colnames( output ) ;
  
  NULL -> rownames( output ) ;
  
  # end parallel
  future::plan("sequential")
  
  return( output ) ;
} 

# 1.4.5 Bivariate analysis paired data not on group
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Bivariate.Analysis.Repeated.notOnTimes <- function( data, 
                                                    level1.names,
                                                    group, 
                                                    identifier,
                                                    RSE = FALSE,
                                                    na.rm = TRUE,
                                                    seed = 123,
                                                    nitt = 15000, burnin = 5000, thin = 30,
                                                    pvalue.round = 3,
                                                    round = 2,
                                                    ncores = NULL )
  
{
  # Conditions for input
  if ( !is.data.frame( data ) ) { stop( "data is not a data.frame" );  } ;
  if ( !is.character( level1.names ) ) { stop( "level1.names is not character" );   } ;
  if ( !is.character( group ) ) { stop( "groups is not character" );   } ;
  if ( !is.character( identifier ) ) { stop( "identifier is not character" );   } ;
  if ( !(group %in% colnames( data ) ) ) { stop(  "group is not in data"  );   } ;
  if ( !(identifier %in% colnames( data ) ) ) { stop(  "identifier is not in data"  );   } ;
  if ( !is.logical( RSE ) ) { stop( "RSE is not TRUE or FALSE" );   } ;
  if ( !is.logical( na.rm ) ) { stop( "na.rm is not TRUE or FALSE" );   } ;
  if ( !is.double( seed ) ) { stop( "seed is not double" );   } ;
  if ( !( is.numeric( pvalue.round ) | 
          is.null( pvalue.round ) ) ) { stop( "pvalue.round is neither numeric, neither NULL" );    } ;
  if ( !( is.numeric( round ) | 
          is.null( round ) ) ) { stop( "round is neither numeric, neither NULL" );    } ;
  if ( !is.null(ncores) & !is.numeric(ncores) ) { stop( "ncores is not null nor numeric" ) }
  
  # parallel
  if ( !is.null( ncores ) ) { future::plan( "multisession",  workers = ncores ) }
  
  # custom functions
  download.packages <- function( PackagesNames, ... )
  {
    # Get a vector with packages names 
    packages1 <- c( PackagesNames, ... ) ;
    
    # Install packages
    for (a in 1:length( packages1 ) )
    {
      try( find.package( packages1[a]), silent = TRUE ) -> test ;
      
      if ( class( test ) == "try-error" )
      { print( packages1[a] ) ; 
        install.packages(  packages1[a] ) ;
      } 
    }
  } ;
  
  rbind.force <- function( data, ..., keep.col = FALSE, empty = NA ) 
  {
    # Unify data
    list( data, ... ) -> input ;
    
    # include list elements
    repeat 
    {
      if (  !any( unlist( lapply( input, class ) ) == "list" ) ) { break }  
      
      which( unlist( lapply( input, class ) ) == "list" )[1] -> a ;
      input[[a]] -> tmp ;
      input[[a]] <- NA ;
      c( input[1:a],  tmp, input[ (a + 1):length( input ) ] ) -> 
        input ;
    }
    
    input[ !is.na( input ) ] ->
      input ;
    
    # delete NULL data and transformt vector in data.frame
    for ( a in 1:length( input ) )
    {
      if ( is.null( dim( input[[a]] ) ) )
      {
        if ( is.null( input[[a]] ) )
        {
          input[[a]] <- NA ;
        } else
        {
          data.frame( matrix( input[[a]], nrow = 1 ),
                      stringsAsFactors = FALSE ) -> input[[a]] ; 
        }
      }
      
      if ( all( dim( input[[a]] ) == 0 ) )
      {
        input[[a]] <- NA ;
      }
    }
    
    input[ !is.na( input ) ] ->
      input ;
    
    # test data class
    if ( !all( unlist( lapply( input, is.data.frame ) ) |
               unlist( lapply( input, is.matrix ) ) |
               unlist( lapply( input, is.vector ) ) ) )
    { stop( "Some argument are not data.frame, neither vector" ) ;
      ; } ;
    
    # Set primer
    input[[1]] -> output ; 
    
    # job in case we keep columns 
    if ( keep.col & length( input ) >1 )
    {
      for ( a in 2:length( input ) )
      { 
        output -> x ;
        input[[a]] -> y ; 
        
        for (a in 1:dim(x)[2]) { x[,a] <- as.character(x[,a])}
        for (a in 1:dim(y)[2]) { y[,a] <- as.character(y[,a])}
        
        x.diff <- setdiff(colnames(x), colnames(y))
        y.diff <- setdiff(colnames(y), colnames(x))
        
        if( dim(x)[1] > 0 ) { x[, c(as.character(y.diff))] <- empty ; }
        if( dim(y)[1] > 0 ) { y[, c(as.character(x.diff))] <- empty ; }
        
        rbind(x, y) -> output ;
      } 
    }
    
    # job in case we do not keep columns
    if ( !keep.col & length( input ) >1 )
    {
      for ( a in 2:length( input ) )
      { 
        output -> x ;
        input[[a]] -> y ; 
        
        colnames(x) <- paste( "X",
                              1:dim( x )[2], 
                              sep = "" ) ;
        colnames(y) <- paste( "X",
                              1:dim( y )[2], 
                              sep = "" ) ;
        
        for (a in 1:dim(x)[2]) { x[,a] <- as.character(x[,a])}
        for (a in 1:dim(y)[2]) { y[,a] <- as.character(y[,a])}
        
        x.diff <- setdiff(colnames(x), colnames(y))
        y.diff <- setdiff(colnames(y), colnames(x))
        
        if( dim(x)[1] > 0 ) { x[, c(as.character(y.diff))] <- empty ; }
        if( dim(y)[1] > 0 ) { y[, c(as.character(x.diff))] <- empty ; }
        
        rbind(x, y) -> output ;
      } 
    }
    
    return( output ) ;
  } 
  
  p.round <- function( data, digits = 3 )
  {
    if (digits == 1)
    { "" -> tmp1 ; } else 
    { rep( "0", digits - 1 ) -> tmp1 ; }
    
    "0." -> tmp2 ;
    for( a in 1:length(tmp1) )
    {
      paste( tmp2, tmp1[a], sep = "" ) -> tmp2 ;
    }
    
    paste( tmp2, "1", sep = "" ) -> pval ;
    
    for ( a in 1:length(data) )
    {
      if ( !is.na( data[a] ) )
      {
        if ( data[a] >= as.numeric( pval ) )
        {
          round( data[a], digits = digits ) -> data[a] ;
        }
      }
    }
    
    data[ data < as.numeric( pval ) ] <- paste( "< ", pval, sep = "" ) ;
    
    return( data ) ;
  }
  
  Prior.Multinomial.Maker <- function( n, random.effects = "", random.interactions = list("") )
  {
    # Residuals
    list( V = diag( n - 1), nu = 0.002, fix = 1) -> R ;
    
    # Groups
    G.tmp = list( "" ) ;
    for ( a in 1:length(random.effects) )
    {
      if ( random.interactions[[a]][1] == "1" | random.interactions[[a]][1] == "" )
      {
        EstimatesNb <-  1 ;
      } else
      {
        EstimatesNb <- length(random.interactions[[a]]) + 1 ;
      } ;
      
      list( V = diag(EstimatesNb), n =  EstimatesNb, alpha.mu = rep( 0, EstimatesNb ), 
            alpha.V  = diag(EstimatesNb) * 25^2, nu = 0.002 ) -> tmp.list ;
      
      G.tmp <- c( G.tmp, tmp.list ) ;
    } ;
    G.tmp <- G.tmp[-1] ;
    G <- list( G.tmp ) ;
    for ( a in 1:length(G) )
    {
      names(G)[length(G)] <- paste( "G", a, ".", random.effects[a], sep = "" ) ;
    } ;
    
    prior <- list( R = R, G = G ) ;
    
    return( prior ) ;
  } ;
  
  fun.a <- function( a, data.vars,  data.group, 
                     data.identifier, 
                     group )
  {
    print( "a") ; print( a ) ; print( colnames( data.vars )[a] ) ;
    
    # Prepara data
    data.vars[,a] -> data.var1 ; 
    
    data.vars[, which( !( colnames( data.vars ) %in% colnames( data.vars )[a] ) ) ] -> 
      data.vars2 ; 
    
    rbind.force( 
      lapply( 1:dim( data.vars2 )[2], 
              FUN = fun.b,
              data.vars2 = data.vars2, 
              data.var1 = data.var1,
              data.group = data.group, 
              data.identifier = data.identifier, 
              group = group,
              identifier = identifier,
              name.a = colnames(data.vars)[a]
      ),
      empty = "" ) -> 
      output.a ;
    
    return( output.a )
  } 
  
  fun.b <- function( b, data.vars2, 
                     data.var1,
                     data.group,
                     data.identifier,
                     group,
                     identifier,
                     name.a  )
  {
    print( "b") ; print( b ) ; print( colnames( data.vars2 )[b] ) ; 
    
    require(ordinal) ; 
    
    # Prepare data
    data.frame( var1 = data.var1,
                var2 = data.vars2[,b], 
                #GROUP = factor( data.group ), 
                ID = as.factor( as.character( data.identifier ) ) ) ->
      df1 ;
    
    # NA
    if ( na.rm )
    {
      na.omit( df1 ) -> df1 ;
    }
    
    # seed
    set.seed( seed ) ;
    
    # primer
    NULL -> output.b ;
    
    # job
    
    # factor 2 levels & factor
    if ( is.factor( df1$var1 ) &
         is.factor( df1$var2 ) & 
         any( table(df1$ID) > 1 ) )
    {
      if (
        nlevels( df1$var1 ) == 2 &
        all( table( df1$var1, df1$var2 ) > 5 )
      )
      {
        "var1 ~ var2 + (1 | ID )" |>  as.formula() ->
          formula1 ; 
        "var1 ~ 1 + (1 | ID )" |> as.formula() ->
          formula2 ; 
        
        lme4::glmer( formula = formula1,
                     data = df1, 
                     family = "binomial",
                     control = lme4::glmerControl( optimizer ='bobyqa', 
                                                   tolPwrss=10^-3,
                                                   optCtrl = list( maxfun = 10^9 ) )
        ) -> glmer1 ;
        lme4::glmer( formula = formula2,
                     data = df1, 
                     family = "binomial",
                     control = lme4::glmerControl( optimizer ='bobyqa', 
                                                   tolPwrss=10^-3,
                                                   optCtrl = list( maxfun = 10^9 ) )
        ) -> glmer2 ;
        
        if ( ( is.factor( df1$var2 ) & nlevels( as.factor( df1$var2 ) ) == 2 ) |  
             is.numeric( df1$var2 )  )
        {
          summary( glmer1 )$coef[2,] -> coefs.glmer ;
        } else
        {
          c( "", "", "", "" ) -> coefs.glmer ; 
        }
        
        if ( RSE )
        {
          if ( ( is.factor( df1$var2 ) & nlevels( as.factor( df1$var2 ) ) == 2 ) |  
               is.numeric( df1$var2 )  )
          {
            sqrt( diag( 
              sandwich::sandwich(glmer1, 
                                 bread. = merDeriv::bread.glmerMod(glmer1, 
                                                                   full = TRUE), 
                                 meat. = sandwich::meat(glmer1, level = 2)) ) 
            )[1:length( MuMIn::coeffs(glmer1) )] ->
              RSE ;
            cbind(Estimate = summary(glmer1)$coefficients[,1], 
                  "Robust S.E." = RSE , 
                  "z value" = summary(glmer1)$coefficients[,1] / RSE, 
                  "Pr(>|z|)" = 2 * pnorm(abs( 
                    summary(glmer1)$coefficients[,1] / RSE), lower.tail=FALSE)
            ) ->
              coefs.glmer.robust ;
          } else
          {
            matrix(rep("",8),nrow=2) ->  coefs.glmer.robust ;
          }
        } else
        {
          matrix(rep("",8),nrow=2) ->  coefs.glmer.robust ;
        }
        
        car::Anova( glmer1, 3, "Chisq")[2,] -> Wald.glmer ;
        anova( glmer1, glmer2)[2,6:8] -> LRT.glemer ; 
        
        try(   MCMCglmm::MCMCglmm( fixed = var1 ~ 1 + var2,
                                   random = ~ ID,
                                   data = df1, 
                                   family = "categorical",
                                   nitt = nitt, burnin = burnin, thin = thin,
                                   verbose = FALSE
        ), silent = T ) -> mcmc1 ;
        if ( class( mcmc1 ) == "try-error" )
        { 
          "" -> mcmc.ptest ; 
        } else
        {
          if ( ( is.factor( df1$var2 ) & nlevels( as.factor( df1$var2 ) ) == 2 ) |  
               is.numeric( df1$var2 )  )
          {
            summary(mcmc1)$solutions[2,] -> mcmc.ptest
          } else
          {
            "" -> mcmc.ptest ;
          } 
        }
        
        try( MuMIn::r.squaredGLMM(glmer1)[,"R2m"], silent = T ) -> R2m1 ; 
        
        if ( class( R2m1 ) == "try-error" )
        { 
          "Not computable" -> f2 ; 
        } else
        {
          R2m1 / (1 - R2m1) -> f2 ;
        }
        
        residuals( glmer1 ) -> residuals.glmer ;
        if ( length( residuals.glmer ) < 5000 ) 
        { shapiro.test( residuals.glmer ) -> shapiro.res ; }  else
        { list( "p.value" = NA ) -> shapiro.res ; }
        nortest::ad.test( residuals.glmer ) -> anderson.res ;
        moments::jarque.test( residuals.glmer ) -> jarque.res ;
        
        c( "binomial", name.a, colnames( data.vars2 )[b], 
           identifier, Wald.glmer[3],
           nrow(df1), nrow(data.vars2) - nrow(df1),
           "Normal test on Maximum likelihood estimation method",
           coefs.glmer[1], coefs.glmer[2], coefs.glmer[3],  coefs.glmer[4],
           "Wald test on Maximum likelihood estimation, type 3",
           Wald.glmer[1], Wald.glmer[2], Wald.glmer[3],
           "Likelihood-ratio test on Maximum likelihood estimation",
           LRT.glemer[1], LRT.glemer[2], LRT.glemer[3],
           "Markov chain Monte Carlo Sampler estimation",
           nitt, burnin, thin,
           "Post mean test on Markov chain Monte Carlo Sampler estimation",
           mcmc.ptest[1], mcmc.ptest[2], mcmc.ptest[3], 
           mcmc.ptest[4], mcmc.ptest[5], 
           "Normal test with robust standard error sandwich method on Maximum likelihood estimation method",
           coefs.glmer.robust[2,1], coefs.glmer.robust[2,2], 
           coefs.glmer.robust[2,3], coefs.glmer.robust[2,4],
           f2,
           shapiro.res$p.value, anderson.res$p.value, jarque.res$p.value
        ) |> 
          unlist() -> 
          output.b ;
        
        c( "binomial", "var1", "var2", "ID", "Wald test p",
           "N", "Missing",
           "Method 1",
           "M1 Estimate", "Standard Error", "M1 Z value", "M1 p",
           "Method 2",
           "M2 Chi2", "M2 Degree of freedom", "M2 p",
           "Method 3", 
           "M3 Chi2", "M3 Degree of freedom", "M3 p",
           "Method 4a",
           "number of iterations", "burnin", "thin",
           "Method 4b",
           "post mean", "lb 95%CI", "ub 95%CI", "eff. samp.", "M4 p",
           "Method 5",
           "M5 Estimate", "Robust Standard Error", "M5 Z value", "M5 p",
           "Cohen f-squared of var2 on R-squared",
           "Shapiro-Wilk normality test on residuals p-value",
           "Anderson-Darling normality test on residuals p-value",
           "Jarque-Bera normality test on residuals p-value"
        ) -> 
          names( output.b ) ;
        
        if ( !is.null( pvalue.round ) ) 
        {  
          p.round( as.numeric( output.b[ which( names( output.b ) == 
                                                  "Wald test p" ) ] ),
                   digits = pvalue.round ) ->
            output.b[ which( names( output.b ) ==  "Wald test p" ) ] ;
          
          p.round( as.numeric( output.b[ which( names( output.b ) == 
                                                  "M1 p" ) ] ),
                   digits = pvalue.round ) ->
            output.b[ which( names( output.b ) == "M1 p" ) ] ;
          
          p.round( as.numeric( output.b[ which( names( output.b ) == 
                                                  "M2 p" ) ] ),
                   digits = pvalue.round ) ->
            output.b[ which( names( output.b ) == "M2 p" ) ] ;
          
          p.round( as.numeric( output.b[ which( names( output.b ) == 
                                                  "M3 p" ) ] ),
                   digits = pvalue.round ) ->
            output.b[ which( names( output.b ) == "M3 p" ) ] ;
          
          p.round( as.numeric( output.b[ which( names( output.b ) == 
                                                  "M4 p" ) ] ),
                   digits = pvalue.round ) ->
            output.b[ which( names( output.b ) == "M4 p" ) ] ;
          
          p.round( as.numeric( output.b[ which( names( output.b ) == 
                                                  "M5 p" ) ] ),
                   digits = pvalue.round ) ->
            output.b[ which( names( output.b ) == "M5 p" ) ] ;
          
          p.round( as.numeric( output.b[ which( names( output.b ) == 
                                                  "Shapiro-Wilk normality test on residuals p-value" ) ] ),
                   digits = pvalue.round ) ->
            output.b[ which( names( output.b ) == "Shapiro-Wilk normality test on residuals p-value" ) ] ;
          
          p.round( as.numeric( output.b[ which( names( output.b ) == 
                                                  "Anderson-Darling normality test on residuals p-value" ) ] ),
                   digits = pvalue.round ) ->
            output.b[ which( names( output.b ) == "Anderson-Darling normality test on residuals p-value" ) ] ;
          
          p.round( as.numeric( output.b[ which( names( output.b ) == 
                                                  "Jarque-Bera normality test on residuals p-value" ) ] ),
                   digits = pvalue.round ) ->
            output.b[ which( names( output.b ) == "Jarque-Bera normality test on residuals p-value" ) ] ;
        }
        
        if ( !is.null( round ) ) 
        { 
          round( as.numeric( output.b[ which( names( output.b ) == 
                                                "M1 Estimate" ) ] ),
                 digits = round ) ->
            output.b[ which( names( output.b ) == "M1 Estimate" ) ] ;
          
          round( as.numeric( output.b[ which( names( output.b ) == 
                                                "Standard Error" ) ] ),
                 digits = round ) ->
            output.b[ which( names( output.b ) == "Standard Error" ) ] ;
          
          round( as.numeric( output.b[ which( names( output.b ) == 
                                                "M1 Z value" ) ] ),
                 digits = round ) ->
            output.b[ which( names( output.b ) == "M1 Z value" ) ] ;
          
          round( as.numeric( output.b[ which( names( output.b ) == 
                                                "M2 Chi2" ) ] ),
                 digits = round ) ->
            output.b[ which( names( output.b ) == "M2 Chi2" ) ] ;
          
          round( as.numeric( output.b[ which( names( output.b ) == 
                                                "M3 Chi2" ) ] ),
                 digits = round ) ->
            output.b[ which( names( output.b ) == "M3 Chi2" ) ] ;
          
          round( as.numeric( output.b[ which( names( output.b ) == 
                                                "post mean" ) ] ),
                 digits = round ) ->
            output.b[ which( names( output.b ) == "post mean" ) ] ;
          
          round( as.numeric( output.b[ which( names( output.b ) == 
                                                "lb 95%CI" ) ] ),
                 digits = round ) ->
            output.b[ which( names( output.b ) == "lb 95%CI" ) ] ;
          
          round( as.numeric( output.b[ which( names( output.b ) == 
                                                "ub 95%CI" ) ] ),
                 digits = round ) ->
            output.b[ which( names( output.b ) == "ub 95%CI" ) ] ;
          
          round( as.numeric( output.b[ which( names( output.b ) == 
                                                "eff. samp." ) ] ),
                 digits = round ) ->
            output.b[ which( names( output.b ) == "eff. samp." ) ] ;
          
          round( as.numeric( output.b[ which( names( output.b ) == 
                                                "M5 Estimate" ) ] ),
                 digits = round ) ->
            output.b[ which( names( output.b ) == "M5 Estimate" ) ] ;
          
          round( as.numeric( output.b[ which( names( output.b ) == 
                                                "Robust Standard Error" ) ] ),
                 digits = round ) ->
            output.b[ which( names( output.b ) == "Robust Standard Error" ) ] ;
          
          round( as.numeric( output.b[ which( names( output.b ) == 
                                                "M5 Z value" ) ] ),
                 digits = round ) ->
            output.b[ which( names( output.b ) == "M5 Z value" ) ] ;
          
          round( as.numeric( output.b[ which( names( output.b ) == "Cohen f-squared of var2 on R-squared" ) ] ),
                 digits = round ) ->
            output.b[ which( names( output.b ) == "Cohen f-squared of var2 on R-squared" ) ] ;
        } 
        
        unlist( output.b )-> output.b ;
      }
    }
    
    # factor 2 levels & numeric
    if ( is.factor( df1$var1 ) &
         is.numeric( df1$var2 ) & 
         any( table(df1$ID) > 1 ) )
    {
      if (  nlevels( df1$var1 ) == 2 &
            all( table( df1$var1 ) > 5 ) &
            nlevels( factor( df1$var2 ) ) > 3 &
            length( df1$var2 ) > 7 &
            !all( df1$var1 == df1$var2 ) )
      {
        "var1 ~ var2 + (1 | ID )" |> as.formula() ->
          formula1 ; 
        "var1 ~ 1 + (1 | ID )" |> as.formula() ->
          formula2 ; 
        
        lme4::glmer( formula = formula1,
                     data = df1, 
                     family = "binomial",
                     control = lme4::glmerControl( optimizer ='bobyqa', 
                                                   tolPwrss=10^-3,
                                                   optCtrl = list( maxfun = 10^9 ) )
        ) -> glmer1 ;
        lme4::glmer( formula = formula2,
                     data = df1, 
                     family = "binomial",
                     control = lme4::glmerControl( optimizer ='bobyqa', 
                                                   tolPwrss=10^-3,
                                                   optCtrl = list( maxfun = 10^9 ) )
        ) -> glmer2 ;
        
        if ( ( is.factor( df1$var2 ) & nlevels( as.factor( df1$var2 ) ) == 2 ) |  
             is.numeric( df1$var2 )  )
        {
          summary( glmer1 )$coef[2,] -> coefs.glmer ;
        } else
        {
          c( "", "", "", "" ) -> coefs.glmer ; 
        }
        
        if ( RSE )
        {
          if ( ( is.factor( df1$var2 ) & nlevels( as.factor( df1$var2 ) ) == 2 ) |  
               is.numeric( df1$var2 )  )
          {
            sqrt( diag( 
              sandwich::sandwich(glmer1, 
                                 bread. = merDeriv::bread.glmerMod(
                                   glmer1, full = TRUE), 
                                 meat. = sandwich::meat(glmer1, level = 2)) ) 
            )[1:length( MuMIn::coeffs(glmer1) )] ->
              RSE ;
            cbind(Estimate = summary(glmer1)$coefficients[,1], 
                  "Robust S.E." = RSE , 
                  "z value" = summary(glmer1)$coefficients[,1] / RSE, 
                  "Pr(>|z|)" = 2 * pnorm(abs( 
                    summary(glmer1)$coefficients[,1] / RSE), lower.tail=FALSE)) ->
              coefs.glmer.robust ;
          } else
          {
            matrix(rep("",8),nrow=2) ->  coefs.glmer.robust ;
          }
        } else
        {
          matrix(rep("",8),nrow=2) ->  coefs.glmer.robust ;
        }
        
        car::Anova( glmer1, 3, "Chisq")[2,] -> Wald.glmer ;
        anova( glmer1, glmer2)[2,6:8] -> LRT.glemer ; 
        
        try( MCMCglmm::MCMCglmm( fixed = var1 ~ 1 + var2,
                                 random = ~ ID,
                                 data = df1, 
                                 family = "categorical",
                                 nitt = nitt, burnin = burnin, thin = thin,
                                 verbose = FALSE
        ), silent = T)  -> mcmc1 ;
        if ( class( mcmc1 ) == "try-error" )
        {
          "" -> mcmc.ptest ; 
        } else
        {
          if ( ( is.factor( df1$var2 ) & nlevels( as.factor( df1$var2 ) ) == 2 ) |  
               is.numeric( df1$var2 )  )
          {
            summary(mcmc1)$solutions[2,] -> mcmc.ptest
          } else
          {
            "" -> mcmc.ptest ;
          } 
        }
        
        try( MuMIn::r.squaredGLMM(glmer1)[,"R2m"], silent = T ) -> R2m1 ; 
        
        if ( class( R2m1 ) == "try-error" )
        { 
          "Not computable" -> f2 ; 
        } else
        {
          R2m1 / (1 - R2m1) -> f2 ;
        }
        
        residuals( glmer1 ) -> residuals.glmer ;
        if ( length( residuals.glmer ) < 5000 ) 
        { shapiro.test( residuals.glmer ) -> shapiro.res ; }  else
        { list( "p.value" = NA ) -> shapiro.res ; }
        nortest::ad.test( residuals.glmer ) -> anderson.res ;
        moments::jarque.test( residuals.glmer ) -> jarque.res ;
        
        c( "binomial", name.a, colnames( data.vars2 )[b], identifier, Wald.glmer[3],
           nrow(df1), nrow(data.vars2) - nrow(df1),
           "Normal test on Maximum likelihood estimation method",
           coefs.glmer[1], coefs.glmer[2], coefs.glmer[3],  coefs.glmer[4],
           "Wald test on Maximum likelihood estimation, type 3",
           Wald.glmer[1], Wald.glmer[2], Wald.glmer[3],
           "Likelihood-ratio test on Maximum likelihood estimation",
           LRT.glemer[1], LRT.glemer[2], LRT.glemer[3],
           "Markov chain Monte Carlo Sampler estimation",
           nitt, burnin, thin,
           "Post mean test on Markov chain Monte Carlo Sampler estimation",
           mcmc.ptest[1], mcmc.ptest[2], mcmc.ptest[3], mcmc.ptest[4], mcmc.ptest[5], 
           "Normal test with robust standard error sandwich method on Maximum likelihood estimation method",
           coefs.glmer.robust[2,1], coefs.glmer.robust[2,2], 
           coefs.glmer.robust[2,3], coefs.glmer.robust[2,4],
           f2,
           shapiro.res$p.value, anderson.res$p.value, jarque.res$p.value
        ) |>
          unlist() -> 
          output.b ;
        
        c( "binomial", "var1", "var2", "ID", "Wald test p",
           "N", "Missing",
           "Method 1",
           "M1 Estimate", "Standard Error", "M1 Z value", "M1 p",
           "Method 2",
           "M2 Chi2", "M2 Degree of freedom", "M2 p",
           "Method 3", 
           "M3 Chi2", "M3 Degree of freedom", "M3 p",
           "Method 4a",
           "number of iterations", "burnin", "thin",
           "Method 4b",
           "post mean", "lb 95%CI", "ub 95%CI", "eff. samp.", "M4 p",
           "Method 5",
           "M5 Estimate", "Robust Standard Error", "M5 Z value", "M5 p",
           "Cohen f-squared of var2 on R-squared",
           "Shapiro-Wilk normality test on residuals p-value",
           "Anderson-Darling normality test on residuals p-value",
           "Jarque-Bera normality test on residuals p-value"
        ) -> 
          names( output.b ) ;
        
        if ( !is.null( pvalue.round ) ) 
        {  
          p.round( as.numeric( output.b[ which( names( output.b ) == 
                                                  "Wald test p" ) ] ),
                   digits = pvalue.round ) ->
            output.b[ which( names( output.b ) ==  "Wald test p" ) ] ;
          
          p.round( as.numeric( output.b[ which( names( output.b ) == 
                                                  "M1 p" ) ] ),
                   digits = pvalue.round ) ->
            output.b[ which( names( output.b ) == "M1 p" ) ] ;
          
          p.round( as.numeric( output.b[ which( names( output.b ) == 
                                                  "M2 p" ) ] ),
                   digits = pvalue.round ) ->
            output.b[ which( names( output.b ) == "M2 p" ) ] ;
          
          p.round( as.numeric( output.b[ which( names( output.b ) == 
                                                  "M3 p" ) ] ),
                   digits = pvalue.round ) ->
            output.b[ which( names( output.b ) == "M3 p" ) ] ;
          
          p.round( as.numeric( output.b[ which( names( output.b ) == 
                                                  "M4 p" ) ] ),
                   digits = pvalue.round ) ->
            output.b[ which( names( output.b ) == "M4 p" ) ] ;
          
          p.round( as.numeric( output.b[ which( names( output.b ) == 
                                                  "M5 p" ) ] ),
                   digits = pvalue.round ) ->
            output.b[ which( names( output.b ) == "M5 p" ) ] ;
          
          p.round( as.numeric( output.b[ which( names( output.b ) == 
                                                  "Shapiro-Wilk normality test on residuals p-value" ) ] ),
                   digits = pvalue.round ) ->
            output.b[ which( names( output.b ) == "Shapiro-Wilk normality test on residuals p-value" ) ] ;
          
          p.round( as.numeric( output.b[ which( names( output.b ) == 
                                                  "Anderson-Darling normality test on residuals p-value" ) ] ),
                   digits = pvalue.round ) ->
            output.b[ which( names( output.b ) == "Anderson-Darling normality test on residuals p-value" ) ] ;
          
          p.round( as.numeric( output.b[ which( names( output.b ) == 
                                                  "Jarque-Bera normality test on residuals p-value" ) ] ),
                   digits = pvalue.round ) ->
            output.b[ which( names( output.b ) == "Jarque-Bera normality test on residuals p-value" ) ] ;
        }
        
        if ( !is.null( round ) ) 
        { 
          round( as.numeric( output.b[ which( names( output.b ) == 
                                                "M1 Estimate" ) ] ),
                 digits = round ) ->
            output.b[ which( names( output.b ) == "M1 Estimate" ) ] ;
          
          round( as.numeric( output.b[ which( names( output.b ) == 
                                                "Standard Error" ) ] ),
                 digits = round ) ->
            output.b[ which( names( output.b ) == "Standard Error" ) ] ;
          
          round( as.numeric( output.b[ which( names( output.b ) == 
                                                "M1 Z value" ) ] ),
                 digits = round ) ->
            output.b[ which( names( output.b ) == "M1 Z value" ) ] ;
          
          round( as.numeric( output.b[ which( names( output.b ) == 
                                                "M2 Chi2" ) ] ),
                 digits = round ) ->
            output.b[ which( names( output.b ) == "M2 Chi2" ) ] ;
          
          round( as.numeric( output.b[ which( names( output.b ) == 
                                                "M3 Chi2" ) ] ),
                 digits = round ) ->
            output.b[ which( names( output.b ) == "M3 Chi2" ) ] ;
          
          round( as.numeric( output.b[ which( names( output.b ) == 
                                                "post mean" ) ] ),
                 digits = round ) ->
            output.b[ which( names( output.b ) == "post mean" ) ] ;
          
          round( as.numeric( output.b[ which( names( output.b ) == 
                                                "lb 95%CI" ) ] ),
                 digits = round ) ->
            output.b[ which( names( output.b ) == "lb 95%CI" ) ] ;
          
          round( as.numeric( output.b[ which( names( output.b ) == 
                                                "ub 95%CI" ) ] ),
                 digits = round ) ->
            output.b[ which( names( output.b ) == "ub 95%CI" ) ] ;
          
          round( as.numeric( output.b[ which( names( output.b ) == 
                                                "eff. samp." ) ] ),
                 digits = round ) ->
            output.b[ which( names( output.b ) == "eff. samp." ) ] ;
          
          round( as.numeric( output.b[ which( names( output.b ) == 
                                                "M5 Estimate" ) ] ),
                 digits = round ) ->
            output.b[ which( names( output.b ) == "M5 Estimate" ) ] ;
          
          round( as.numeric( output.b[ which( names( output.b ) == 
                                                "Robust Standard Error" ) ] ),
                 digits = round ) ->
            output.b[ which( names( output.b ) == "Robust Standard Error" ) ] ;
          
          round( as.numeric( output.b[ which( names( output.b ) == 
                                                "M5 Z value" ) ] ),
                 digits = round ) ->
            output.b[ which( names( output.b ) == "M5 Z value" ) ] ;
          
          round( as.numeric( output.b[ which( names( output.b ) == 
                                                "Cohen f-squared of var2 on R-squared" ) ] ),
                 digits = round ) ->
            output.b[ which( names( output.b ) == "Cohen f-squared of var2 on R-squared" ) ] ;
        } 
        
        unlist( output.b )-> output.b ;
      }
    }
    
    # factor > 2 levels & factor
    if ( is.factor( df1$var1 ) &
         is.factor( df1$var2 ) & 
         any( table(df1$ID) > 1 ) )
    {
      if ( nlevels( df1$var1 ) > 2 &
           all( table( df1$var1, df1$var2 ) > 5 ) )
      {
        ordinal::clmm2( location = var1 ~ 1,
                        nominal = ~ var2,
                        random = ID,
                        data = df1, 
                        link = "logistic",
                        Hess = TRUE, nAGQ = 20,
                        control = ordinal::clmm2.control(maxIter = 1000, 
                                                         maxLineIter = 1000)
        ) -> clmm1 ;
        ordinal::clmm2( location = var1 ~ 1,
                        nominal = ~ 1,
                        random = ID,
                        data = df1, 
                        link = "logistic",
                        Hess = TRUE, nAGQ = 20,
                        control = ordinal::clmm2.control(maxIter = 1000, 
                                                         maxLineIter = 1000)
        ) -> clmm2 ;
        anova( clmm1, clmm2)[2,5:7] -> LRT.clmm ; 
        
        Prior.Multinomial.Maker( nlevels(df1$var1), "ID", 
                                 list( rep("trait",   nlevels(df1$var1) - 2 ) ) 
        ) -> prior1 ;
        try( MCMCglmm::MCMCglmm( fixed = var1 ~ -1 + trait + trait:(var2),
                                 random = ~ us(trait):ID,
                                 rcov = ~ us(trait):units,
                                 family = "categorical",
                                 data = df1, 
                                 nitt = nitt, burnin = burnin, thin = thin,
                                 verbose = FALSE, prior = prior1
        ), silent = T ) -> mcmc1 ;
        if ( class( mcmc1 ) == "try-error" )
        {
          "Not computable" -> pMCMC ;
        } else 
        {
          summary(mcmc1)-> mcmc1.summary ;
          mcmc1.summary$solutions -> mcmc1.summary ;
          mcmc1.summary[ grepl( ":", rownames( mcmc1.summary) ), ] ->
            mcmc1.summary ;
          paste0( rownames(mcmc1.summary), ": pMCMC: ",
                  p.round( mcmc1.summary[ , 5], 3)
          ) -> longpMCMC ; 
          pMCMC <- longpMCMC[1] ; 
          for ( g in 2:length(longpMCMC) )
          {
            paste( pMCMC, longpMCMC[g], sep = " // " ) ->
              pMCMC ;
          }
        }
        
        c( "multinomial", name.a, colnames( data.vars2 )[b], 
           identifier, LRT.clmm[3], 
           nrow(df1), nrow(data.vars2) - nrow(df1),
           "Maximum likelihood estimation method",
           LRT.clmm[2], LRT.clmm[1], LRT.clmm[3], 
           "Markov chain Monte Carlo Sampler estimation: Post mean test",
           nitt, burnin, thin, 
           pMCMC
        ) -> 
          output.b ;
        
        c( "multinomial", "var1", "var2", 
           "ID", "LRT p on ML",
           "N", "Missing",
           "Method 1",
           "M1 Chi2", "M1 Degree of freedom", "M1 p",
           "Method 2",
           "number of iterations", "burnin", "thin",
           "M2 p"
        ) -> 
          names( output.b ) ;
        
        if ( !is.null( pvalue.round ) ) 
        {  
          p.round( as.numeric( output.b[ which( names( output.b ) == 
                                                  "LRT p on ML" ) ] ),
                   digits = pvalue.round ) ->
            output.b[ which( names( output.b ) == "LRT p on ML" ) ] ;
          
          p.round( as.numeric( output.b[ which( names( output.b ) == 
                                                  "M1 p" ) ] ),
                   digits = pvalue.round ) ->
            output.b[ which( names( output.b ) == "M1 p" ) ] ;
        }
        
        if ( !is.null( round ) ) 
        { 
          round( as.numeric( output.b[ which( names( output.b ) == 
                                                "M1 Chi2" ) ] ),
                 digits = round ) ->
            output.b[ which( names( output.b ) == "M1 Chi2" ) ] ;
        }
        
        unlist( output.b )-> output.b ;
      }
    }
    
    # factor > 2 levels & numeric
    if ( is.factor( df1$var1 ) &
         is.numeric( df1$var2 ) & 
         any( table(df1$ID) > 1 ) )
    {
      if (  nlevels( df1$var1 ) > 2 &
            all( table( df1$var1 ) > 5 ) &
            nlevels( factor( df1$var2 ) ) > 3 &
            length( df1$var2 ) > 7 &
            !all( df1$var1 == df1$var2 ) )
      {
        ordinal::clmm2( location = var1 ~ 1,
                        nominal = ~ var2,
                        random = ID,
                        data = df1, 
                        link = "logistic",
                        Hess = TRUE, nAGQ = 20,
                        control = ordinal::clmm2.control(maxIter = 1000, 
                                                         maxLineIter = 1000)
        ) -> clmm1 ;
        ordinal::clmm2( location = var1 ~ 1,
                        nominal = ~ 1,
                        random = ID,
                        data = df1, 
                        link = "logistic",
                        Hess = TRUE, nAGQ = 20,
                        control = ordinal::clmm2.control(maxIter = 1000, 
                                                         maxLineIter = 1000)
        ) -> clmm2 ;
        anova( clmm1, clmm2)[2,5:7] -> LRT.clmm ; 
        
        Prior.Multinomial.Maker( nlevels(df1$var1), "ID", 
                                 list( rep("trait",  nlevels(df1$var1) - 2 ) ) 
        ) -> prior1 ;
        try(MCMCglmm::MCMCglmm( fixed = var1 ~ -1 + trait + trait:(var2),
                                random = ~ us(trait):ID,
                                rcov = ~ us(trait):units,
                                family = "categorical",
                                data = df1, 
                                nitt = nitt, burnin = burnin, thin = thin,
                                verbose = FALSE, prior = prior1
        ), silent = T) -> mcmc1 ;
        if ( class( mcmc1 ) == "try-error" )
        {
          "Not computable" -> pMCMC ;
        } else
        {
          summary(mcmc1)$solutions -> mcmc1.summary ;
          mcmc1.summary[ grepl( ":", rownames( mcmc1.summary) ), ] ->
            mcmc1.summary ;
          paste0( rownames(mcmc1.summary), ": pMCMC: ",
                  p.round( mcmc1.summary[ , 5], 3)
          ) -> longpMCMC ; 
          pMCMC <- longpMCMC[1] ; 
          for ( g in 2:length(longpMCMC) )
          {
            paste( pMCMC, longpMCMC[g], sep = " // " ) ->
              pMCMC ;
          }
        }
        
        c( "multinomial", name.a, colnames( data.vars2 )[b], 
           identifier, LRT.clmm[3], 
           nrow(df1), nrow(data.vars2) - nrow(df1),
           "Maximum likelihood estimation method",
           LRT.clmm[2], LRT.clmm[1], LRT.clmm[3], 
           "Markov chain Monte Carlo Sampler estimation: Post mean test",
           nitt, burnin, thin,
           pMCMC
        ) -> 
          output.b ;
        
        c( "multinomial", "var1", "var2", "ID", "LRT p on ML",
           "N", "Missing",
           "Method 1",
           "M1 Chi2", "M1 Degree of freedom", "M1 p",
           "Method 2",
           "number of iterations", "burnin", "thin",
           "M2 p"
        ) -> 
          names( output.b ) ;
        
        if ( !is.null( pvalue.round ) ) 
        {  
          p.round( as.numeric( output.b[ which( names( output.b ) == 
                                                  "LRT p on ML" ) ] ),
                   digits = pvalue.round ) ->
            output.b[ which( names( output.b ) == "LRT p on ML" ) ] ;
          
          p.round( as.numeric( output.b[ which( names( output.b ) == 
                                                  "M1 p" ) ] ),
                   digits = pvalue.round ) ->
            output.b[ which( names( output.b ) == "M1 p" ) ] ;
        }
        
        if ( !is.null( round ) ) 
        { 
          round( as.numeric( output.b[ which( names( output.b ) == 
                                                "M1 Chi2" ) ] ),
                 digits = round ) ->
            output.b[ which( names( output.b ) == "M1 Chi2" ) ] ;
        }
        
        unlist( output.b )-> output.b ;
      }
    }
    
    # Numeric & factor 
    if ( is.numeric( df1$var1 ) &
         is.factor( df1$var2 ) & 
         any( table(df1$ID) > 1 ) )
    {
      if (  nlevels( factor( df1$var1 ) ) > 3 &
            length( df1$var1 ) > 7 &
            all( table( df1$var2 ) > 5 ) &
            !all( df1$var1 == df1$var2 ) )
      {
        "var1 ~ var2 + (1 | ID )" |> as.formula() ->
          formula1 ; 
        "var1 ~ 1 + (1 | ID )" |> as.formula() ->
          formula2 ; 
        lmerTest::lmer( formula = formula1,
                        data = df1, 
                        REML = FALSE,
                        control = lme4::lmerControl( optimizer = "bobyqa", 
                                                     optCtrl = list( maxfun = 10^9 ),
                                                     calc.derivs = FALSE ) 
        ) -> lmer1 ;
        lmerTest::lmer( formula = formula2,
                        data = df1, 
                        REML = FALSE,
                        control = lme4::lmerControl( optimizer = "bobyqa", 
                                                     optCtrl = list( maxfun = 10^9 ),
                                                     calc.derivs = FALSE ) 
        ) -> lmer2 ;
        lmerTest::lmer( formula = formula1,
                        data = df1, 
                        REML = TRUE,
                        control = lme4::lmerControl( optimizer = "bobyqa", 
                                                     optCtrl = list( maxfun = 10^9 ),
                                                     calc.derivs = FALSE ) 
        ) -> lmer1bis ;
        
        if ( ( is.factor( df1$var2 ) & nlevels( as.factor( df1$var2 ) ) == 2 ) | 
             is.numeric( df1$var2 ) )
        {
          summary( lmer1 )$coef[2,] -> coefs.lmer ;
        } else
        {
          c( "", "", "", "", "" ) -> coefs.lmer ; 
        }
        
        if ( RSE )
        {
          if ( ( is.factor( df1$var2 ) & nlevels( as.factor( df1$var2 ) ) == 2 ) | 
               is.numeric( df1$var2 ) )
          {
            clubSandwich::coef_test( lmer1, 
                                     clubSandwich::vcovCR(lmer1, 
                                                          type = "CR2"))[2,] -> 
              coefs.robust.lmer ; 
          } else
          {
            matrix(rep("",5),nrow=1) -> coefs.robust.lmer ; 
          }
        } else
        {
          matrix(rep("",5),nrow=1) -> coefs.robust.lmer ; 
        }
        
        car::Anova( lmer1, 3, "Chisq")[2,] -> Wald.lmer ;
        car::Anova( lmer1bis, 3, "F")[2,] -> WaldKenward.lmer ;
        anova( lmer1, lmer2)[2,6:8] -> LRT.lmer ; 
        
        try( MCMCglmm::MCMCglmm( fixed = var1 ~ 1 + var2,
                                 random = ~ ID,
                                 data = df1, 
                                 family = "gaussian",
                                 nitt = nitt, burnin = burnin, thin = thin,
                                 verbose = FALSE
        ), silent = T) -> mcmc1 ;
        if ( class( mcmc1 ) == "try-error" )
        {
          "" -> mcmc.ptest ; 
        } else
        {
          if ( ( is.factor( df1$var2 ) & nlevels( as.factor( df1$var2 ) ) == 2 ) | 
               is.numeric( df1$var2 ) )
          {
            summary(mcmc1)$solutions[2,] -> mcmc.ptest
          } else
          {
            "" -> mcmc.ptest ;
          }
        }
        
        try( MuMIn::r.squaredGLMM(lmer1)[,"R2m"], silent = T ) -> R2m1 ; 
        
        if ( class( R2m1 ) == "try-error" )
        { 
          "Not computable" -> f2 ; 
        } else
        {
          R2m1 / (1 - R2m1) -> f2 ;
        }
        
        effectsize::eta_squared(lmer1)[2]  -> eta2 ;
        
        residuals( lmer1 ) -> residuals.lmer ;
        if ( length( residuals.lmer ) < 5000 ) 
        { shapiro.test( residuals.lmer ) -> shapiro.res ; }  else
        { list( "p.value" = NA ) -> shapiro.res ; }
        nortest::ad.test( residuals.lmer ) -> anderson.res ;
        moments::jarque.test( residuals.lmer ) -> jarque.res ;
        
        
        c( "gaussian", name.a, colnames( data.vars2 )[b], identifier, Wald.lmer[3],
           nrow(df1), nrow(data.vars2) - nrow(df1),
           "T-test with Satterthwaite's medthod on Maximum likelihood estimation method",
           coefs.lmer[1], coefs.lmer[2], coefs.lmer[3],  coefs.lmer[4], 
           coefs.lmer[5],
           "Wald test on Maximum likelihood estimation, type 3",
           Wald.lmer[1], Wald.lmer[2], Wald.lmer[3],
           "Wald test with Kenward-Roger degree of freedom on Restricted maximum likelihood estimation, type 3",
           WaldKenward.lmer[1], WaldKenward.lmer[2], WaldKenward.lmer[3], 
           WaldKenward.lmer[4],
           "Likelihood-ratio test on Maximum likelihood estimation",
           LRT.lmer[1], LRT.lmer[2], LRT.lmer[3],
           "Markov chain Monte Carlo Sampler estimation",
           nitt, burnin, thin,
           "Post mean test on Markov chain Monte Carlo Sampler estimation",
           mcmc.ptest[1], mcmc.ptest[2], mcmc.ptest[3], mcmc.ptest[4], 
           mcmc.ptest[5], 
           "T-test with Satterthwaite's medthod with robust standard error Bell-McCaffrey on Maximum likelihood estimation method",
           coefs.robust.lmer[1,1],  coefs.robust.lmer[1,2],  
           coefs.robust.lmer[1,3],  coefs.robust.lmer[1,4],
           coefs.robust.lmer[1,5],
           f2, eta2,
           shapiro.res$p.value, anderson.res$p.value, jarque.res$p.value
        ) -> 
          output.b ;
        
        c( "gaussian", "var1", "var2", "ID", "Wald test p",
           "N", "Missing",
           "Method 1",
           "M1 Estimate", "M1 Standard Error", "M1 T statistic", "M1 degree of freedom", "M1 p",
           "Method 2",
           "M2 Chi2", "M2 Degree of freedom", "M2 p",
           "Method 3", 
           "M3 F", "M3 Degree of freedom", "M3 degree of freedom residuals", "M3 p",
           "Method 4",
           "M4 Chi2", "M4 Degree of freedom", "M4 p",
           "Method 5a",
           "number of iterations", "burnin", "thin",
           "Method 5b",
           "post mean", "lb 95%CI", "ub 95%CI", "eff. samp.", "M5 p",
           "Method 6",
           "M6 Estimate", "M6 Standard Error", "M6 T statistic", "M6 degree of freedom", "M6 p",
           "Cohen f-squared of var2 on R-squared",
           "Partial eta-squared",
           "Shapiro-Wilk normality test on residuals p-value",
           "Anderson-Darling normality test on residuals p-value",
           "Jarque-Bera normality test on residuals p-value"
        ) -> 
          names( output.b ) ;
        
        if ( !is.null( pvalue.round ) ) 
        {  
          p.round( as.numeric( output.b[ which( names( output.b ) == 
                                                  "Wald test p" ) ] ),
                   digits = pvalue.round ) ->
            output.b[ which( names( output.b ) == "Wald test p" ) ] ;
          
          p.round( as.numeric( output.b[ which( names( output.b ) == 
                                                  "M1 p" ) ] ),
                   digits = pvalue.round ) ->
            output.b[ which( names( output.b ) == "M1 p" ) ] ;
          
          p.round( as.numeric( output.b[ which( names( output.b ) == 
                                                  "M2 p" ) ] ),
                   digits = pvalue.round ) ->
            output.b[ which( names( output.b ) == "M2 p" ) ] ;
          
          p.round( as.numeric( output.b[ which( names( output.b ) == 
                                                  "M3 p" ) ] ),
                   digits = pvalue.round ) ->
            output.b[ which( names( output.b ) == "M3 p" ) ] ;
          
          p.round( as.numeric( output.b[ which( names( output.b ) == 
                                                  "M4 p" ) ] ),
                   digits = pvalue.round ) ->
            output.b[ which( names( output.b ) == "M4 p" ) ] ;
          
          p.round( as.numeric( output.b[ which( names( output.b ) == 
                                                  "M5 p" ) ] ),
                   digits = pvalue.round ) ->
            output.b[ which( names( output.b ) == "M5 p" ) ] ;
          
          p.round( as.numeric( output.b[ which( names( output.b ) == 
                                                  "M6 p" ) ] ),
                   digits = pvalue.round ) ->
            output.b[ which( names( output.b ) == "M6 p" ) ] ;
          
          p.round( as.numeric( output.b[ which( names( output.b ) == 
                                                  "Shapiro-Wilk normality test on residuals p-value" ) ] ),
                   digits = pvalue.round ) ->
            output.b[ which( names( output.b ) == "Shapiro-Wilk normality test on residuals p-value" ) ] ;
          
          p.round( as.numeric( output.b[ which( names( output.b ) == 
                                                  "Anderson-Darling normality test on residuals p-value" ) ] ),
                   digits = pvalue.round ) ->
            output.b[ which( names( output.b ) == "Anderson-Darling normality test on residuals p-value" ) ] ;
          
          p.round( as.numeric( output.b[ which( names( output.b ) == 
                                                  "Jarque-Bera normality test on residuals p-value" ) ] ),
                   digits = pvalue.round ) ->
            output.b[ which( names( output.b ) == "Jarque-Bera normality test on residuals p-value" ) ] ;
        }
        
        if ( !is.null( round ) ) 
        { 
          round( as.numeric( output.b[ which( names( output.b ) == 
                                                "M1 Estimate" ) ] ),
                 digits = round ) ->
            output.b[ which( names( output.b ) == "M1 Estimate" ) ] ;
          
          round( as.numeric( output.b[ which( names( output.b ) == 
                                                "M1 Standard Error" ) ] ),
                 digits = round ) ->
            output.b[ which( names( output.b ) == "M1 Standard Error" ) ] ;
          
          round( as.numeric( output.b[ which( names( output.b ) == 
                                                "M1 T statistic" ) ] ),
                 digits = round ) ->
            output.b[ which( names( output.b ) == "M1 T statistic" ) ] ;
          
          round( as.numeric( output.b[ which( names( output.b ) == 
                                                "M1 degree of freedom" ) ] ),
                 digits = round ) ->
            output.b[ which( names( output.b ) == "M1 degree of freedom" ) ] ;
          
          round( as.numeric( output.b[ which( names( output.b ) == 
                                                "M2 Chi2" ) ] ),
                 digits = round ) ->
            output.b[ which( names( output.b ) == "M2 Chi2" ) ] ;
          
          round( as.numeric( output.b[ which( names( output.b ) == 
                                                "M3 F" ) ] ),
                 digits = round ) ->
            output.b[ which( names( output.b ) == "M3 F" ) ] ;
          
          round( as.numeric( output.b[ which( names( output.b ) == 
                                                "M3 degree of freedom residuals" ) ] ),
                 digits = round ) ->
            output.b[ which( names( output.b ) == "M3 degree of freedom residuals" ) ] ;
          
          round( as.numeric( output.b[ which( names( output.b ) == 
                                                "M4 Chi2" ) ] ),
                 digits = round ) ->
            output.b[ which( names( output.b ) == "M4 Chi2" ) ] ;
          
          round( as.numeric( output.b[ which( names( output.b ) == 
                                                "post mean" ) ] ),
                 digits = round ) ->
            output.b[ which( names( output.b ) == "post mean" ) ] ;
          
          round( as.numeric( output.b[ which( names( output.b ) == 
                                                "lb 95%CI" ) ] ),
                 digits = round ) ->
            output.b[ which( names( output.b ) == "lb 95%CI" ) ] ;
          
          round( as.numeric( output.b[ which( names( output.b ) == 
                                                "ub 95%CI" ) ] ),
                 digits = round ) ->
            output.b[ which( names( output.b ) == "ub 95%CI" ) ] ;
          
          round( as.numeric( output.b[ which( names( output.b ) == 
                                                "eff. samp." ) ] ),
                 digits = round ) ->
            output.b[ which( names( output.b ) == "eff. samp." ) ] ;
          
          round( as.numeric( output.b[ which( names( output.b ) == 
                                                "M6 Estimate" ) ] ),
                 digits = round ) ->
            output.b[ which( names( output.b ) == "M6 Estimate" ) ] ;
          
          round( as.numeric( output.b[ which( names( output.b ) == 
                                                "M6 Standard Error" ) ] ),
                 digits = round ) ->
            output.b[ which( names( output.b ) == "M6 Standard Error" ) ] ;
          
          round( as.numeric( output.b[ which( names( output.b ) == 
                                                "M6 T statistic" ) ] ),
                 digits = round ) ->
            output.b[ which( names( output.b ) == "M6 T statistic" ) ] ;
          
          round( as.numeric( output.b[ which( names( output.b ) == 
                                                "M6 degree of freedom" ) ] ),
                 digits = round ) ->
            output.b[ which( names( output.b ) == "M6 degree of freedom" ) ] ;
          
          round( as.numeric( output.b[ which( names( output.b ) == 
                                                "Cohen f-squared of var2 on R-squared" ) ] ),
                 digits = round ) ->
            output.b[ which( names( output.b ) == "Cohen f-squared of var2 on R-squared" ) ] ;
          
          round( as.numeric( output.b[ which( names( output.b ) == 
                                                "Partial eta-squared" ) ] ),
                 digits = round ) ->
            output.b[ which( names( output.b ) == "Partial eta-squared" ) ] ;
        } 
        
        unlist( output.b )-> output.b ;
      }   
    }
    
    # Numeric & numeric 
    if ( is.numeric( df1$var1 ) &
         is.numeric( df1$var2 ) & 
         any( table(df1$ID) > 1 ) )
    {
      if (  nlevels( factor( df1$var1 ) ) > 3 &
            length( df1$var1 ) > 7 &
            nlevels( factor( df1$var2 ) ) > 3 &
            length( df1$var2 ) > 7 &
            !all( df1$var1 == df1$var2 ) )
      {
        "var1 ~ var2 + (1 | ID )" |> as.formula() ->
          formula1 ; 
        "var1 ~ 1 + (1 | ID )" |> as.formula() ->
          formula2 ; 
        lmerTest::lmer( formula = formula1,
                        data = df1, 
                        REML = FALSE,
                        control = lme4::lmerControl( optimizer = "bobyqa", 
                                                     optCtrl = list( maxfun = 10^9 ),
                                                     calc.derivs = FALSE ) 
        ) -> lmer1 ;
        lmerTest::lmer( formula = formula2,
                        data = df1, 
                        REML = FALSE,
                        control = lme4::lmerControl( optimizer = "bobyqa", 
                                                     optCtrl = list( maxfun = 10^9 ),
                                                     calc.derivs = FALSE ) 
        ) -> lmer2 ;
        lmerTest::lmer( formula = formula1,
                        data = df1, 
                        REML = TRUE,
                        control = lme4::lmerControl( optimizer = "bobyqa", 
                                                     optCtrl = list( maxfun = 10^9 ),
                                                     calc.derivs = FALSE ) 
        ) -> lmer1bis ;
        
        if ( ( is.factor( df1$var2 ) & nlevels( as.factor( df1$var2 ) ) == 2 ) | 
             is.numeric( df1$var2 ) )
        {
          summary( lmer1 )$coef[2,] -> coefs.lmer ;
        } else
        {
          c( "", "", "", "", "" ) -> coefs.lmer ; 
        }
        
        if ( RSE )
        {
          if ( ( is.factor( df1$var2 ) & nlevels( as.factor( df1$var2 ) ) == 2 ) | 
               is.numeric( df1$var2 ) )
          {
            clubSandwich::coef_test( lmer1, 
                                     clubSandwich::vcovCR(lmer1, 
                                                          type = "CR2"))[2,] -> 
              coefs.robust.lmer ; 
          } else
          {
            matrix(rep("",5),nrow=1) -> coefs.robust.lmer ; 
          }
        } else
        {
          matrix(rep("",5),nrow=1) -> coefs.robust.lmer ; 
        }
        
        car::Anova( lmer1, 3, "Chisq")[2,] -> Wald.lmer ;
        car::Anova( lmer1bis, 3, "F")[2,] -> WaldKenward.lmer ;
        anova( lmer1, lmer2)[2,6:8] -> LRT.lmer ; 
        
        try( MCMCglmm::MCMCglmm( fixed = var1 ~ 1 + var2,
                                 random = ~ ID,
                                 data = df1, 
                                 family = "gaussian",
                                 nitt = nitt, burnin = burnin, thin = thin,
                                 verbose = FALSE
        ), silent = T) -> mcmc1 ;
        if ( class( mcmc1 ) == "try-error" )
        { 
          "" -> mcmc.ptest ; 
        } else
        {
          if ( ( is.factor( df1$var2 ) & nlevels( as.factor( df1$var2 ) ) == 2 ) | 
               is.numeric( df1$var2 ) )
          {
            summary(mcmc1)$solutions[2,] -> mcmc.ptest
          } else
          {
            "" -> mcmc.ptest ;
          } 
        }
        
        try( MuMIn::r.squaredGLMM(lmer1)[,"R2m"], silent = T ) -> R2m1 ; 
        
        if ( class( R2m1 ) == "try-error" )
        { 
          "Not computable" -> f2 ; 
        } else
        {
          R2m1 / (1 - R2m1) -> f2 ;
        }
        
        effectsize::eta_squared(lmer1)[2]  -> eta2 ;
        
        residuals( lmer1 ) -> residuals.lmer ;
        if ( length( residuals.lmer ) < 5000 ) 
        { shapiro.test( residuals.lmer ) -> shapiro.res ; }  else
        { list( "p.value" = NA ) -> shapiro.res ; }
        nortest::ad.test( residuals.lmer ) -> anderson.res ;
        moments::jarque.test( residuals.lmer ) -> jarque.res ;
        
        
        c( "gaussian", name.a, colnames( data.vars2 )[b], identifier, Wald.lmer[3],
           nrow(df1), nrow(data.vars2) - nrow(df1),
           "T-test with Satterthwaite's medthod on Maximum likelihood estimation method",
           coefs.lmer[1], coefs.lmer[2], coefs.lmer[3],  coefs.lmer[4], coefs.lmer[5],
           "Wald test on Maximum likelihood estimation, type 3",
           Wald.lmer[1], Wald.lmer[2], Wald.lmer[3],
           "Wald test with Kenward-Roger degree of freedom on Restricted maximum likelihood estimation, type 3",
           WaldKenward.lmer[1], WaldKenward.lmer[2], WaldKenward.lmer[3], WaldKenward.lmer[4],
           "Likelihood-ratio test on Maximum likelihood estimation",
           LRT.lmer[1], LRT.lmer[2], LRT.lmer[3],
           "Markov chain Monte Carlo Sampler estimation",
           nitt, burnin, thin,
           "Post mean test on Markov chain Monte Carlo Sampler estimation",
           mcmc.ptest[1], mcmc.ptest[2], mcmc.ptest[3], mcmc.ptest[4], mcmc.ptest[5], 
           "T-test with Satterthwaite's medthod with robust standard error Bell-McCaffrey on Maximum likelihood estimation method",
           coefs.robust.lmer[1,1],  coefs.robust.lmer[1,2],  coefs.robust.lmer[1,3],  coefs.robust.lmer[1,4],
           coefs.robust.lmer[1,5],
           f2, eta2,
           shapiro.res$p.value, anderson.res$p.value, jarque.res$p.value
        ) -> 
          output.b ;
        
        c( "gaussian", "var1", "var2", "ID", "Wald test p",
           "N", "Missing",
           "Method 1",
           "M1 Estimate", "M1 Standard Error", "M1 T statistic", "M1 degree of freedom", "M1 p",
           "Method 2",
           "M2 Chi2", "M2 Degree of freedom", "M2 p",
           "Method 3", 
           "M3 F", "M3 Degree of freedom", "M3 degree of freedom residuals", "M3 p",
           "Method 4",
           "M4 Chi2", "M4 Degree of freedom", "M4 p",
           "Method 5a",
           "number of iterations", "burnin", "thin",
           "Method 5n",
           "post mean", "lb 95%CI", "ub 95%CI", "eff. samp.", "M5 p",
           "Method 6",
           "M6 Estimate", "M6 Standard Error", "M6 T statistic", "M6 degree of freedom", "M6 p",
           "Cohen f-squared of var2 on R-squared",
           "Partial eta-squared",
           "Shapiro-Wilk normality test on residuals p-value",
           "Anderson-Darling normality test on residuals p-value",
           "Jarque-Bera normality test on residuals p-value"
        ) -> 
          names( output.b ) ;
        
        if ( !is.null( pvalue.round ) ) 
        {  
          p.round( as.numeric( output.b[ which( names( output.b ) == 
                                                  "Wald test p" ) ] ),
                   digits = pvalue.round ) ->
            output.b[ which( names( output.b ) == "Wald test p" ) ] ;
          
          p.round( as.numeric( output.b[ which( names( output.b ) == 
                                                  "M1 p" ) ] ),
                   digits = pvalue.round ) ->
            output.b[ which( names( output.b ) == "M1 p" ) ] ;
          
          p.round( as.numeric( output.b[ which( names( output.b ) == 
                                                  "M2 p" ) ] ),
                   digits = pvalue.round ) ->
            output.b[ which( names( output.b ) == "M2 p" ) ] ;
          
          p.round( as.numeric( output.b[ which( names( output.b ) == 
                                                  "M3 p" ) ] ),
                   digits = pvalue.round ) ->
            output.b[ which( names( output.b ) == "M3 p" ) ] ;
          
          p.round( as.numeric( output.b[ which( names( output.b ) == 
                                                  "M4 p" ) ] ),
                   digits = pvalue.round ) ->
            output.b[ which( names( output.b ) == "M4 p" ) ] ;
          
          p.round( as.numeric( output.b[ which( names( output.b ) == 
                                                  "M5 p" ) ] ),
                   digits = pvalue.round ) ->
            output.b[ which( names( output.b ) == "M5 p" ) ] ;
          
          p.round( as.numeric( output.b[ which( names( output.b ) == 
                                                  "M6 p" ) ] ),
                   digits = pvalue.round ) ->
            output.b[ which( names( output.b ) == "M6 p" ) ] ;
          
          p.round( as.numeric( output.b[ which( names( output.b ) == 
                                                  "Shapiro-Wilk normality test on residuals p-value" ) ] ),
                   digits = pvalue.round ) ->
            output.b[ which( names( output.b ) == "Shapiro-Wilk normality test on residuals p-value" ) ] ;
          
          p.round( as.numeric( output.b[ which( names( output.b ) == 
                                                  "Anderson-Darling normality test on residuals p-value" ) ] ),
                   digits = pvalue.round ) ->
            output.b[ which( names( output.b ) == "Anderson-Darling normality test on residuals p-value" ) ] ;
          
          p.round( as.numeric( output.b[ which( names( output.b ) == 
                                                  "Jarque-Bera normality test on residuals p-value" ) ] ),
                   digits = pvalue.round ) ->
            output.b[ which( names( output.b ) == "Jarque-Bera normality test on residuals p-value" ) ] ;
        }
        
        if ( !is.null( round ) ) 
        { 
          round( as.numeric( output.b[ which( names( output.b ) == 
                                                "M1 Estimate" ) ] ),
                 digits = round ) ->
            output.b[ which( names( output.b ) == "M1 Estimate" ) ] ;
          
          round( as.numeric( output.b[ which( names( output.b ) == 
                                                "M1 Standard Error" ) ] ),
                 digits = round ) ->
            output.b[ which( names( output.b ) == "M1 Standard Error" ) ] ;
          
          round( as.numeric( output.b[ which( names( output.b ) == 
                                                "M1 T statistic" ) ] ),
                 digits = round ) ->
            output.b[ which( names( output.b ) == "M1 T statistic" ) ] ;
          
          round( as.numeric( output.b[ which( names( output.b ) == 
                                                "M1 degree of freedom" ) ] ),
                 digits = round ) ->
            output.b[ which( names( output.b ) == "M1 degree of freedom" ) ] ;
          
          round( as.numeric( output.b[ which( names( output.b ) == 
                                                "M2 Chi2" ) ] ),
                 digits = round ) ->
            output.b[ which( names( output.b ) == "M2 Chi2" ) ] ;
          
          round( as.numeric( output.b[ which( names( output.b ) == 
                                                "M3 F" ) ] ),
                 digits = round ) ->
            output.b[ which( names( output.b ) == "M3 F" ) ] ;
          
          round( as.numeric( output.b[ which( names( output.b ) == 
                                                "M3 degree of freedom residuals" ) ] ),
                 digits = round ) ->
            output.b[ which( names( output.b ) == "M3 degree of freedom residuals" ) ] ;
          
          round( as.numeric( output.b[ which( names( output.b ) == 
                                                "M4 Chi2" ) ] ),
                 digits = round ) ->
            output.b[ which( names( output.b ) == "M4 Chi2" ) ] ;
          
          round( as.numeric( output.b[ which( names( output.b ) == 
                                                "post mean" ) ] ),
                 digits = round ) ->
            output.b[ which( names( output.b ) == "post mean" ) ] ;
          
          round( as.numeric( output.b[ which( names( output.b ) == 
                                                "lb 95%CI" ) ] ),
                 digits = round ) ->
            output.b[ which( names( output.b ) == "lb 95%CI" ) ] ;
          
          round( as.numeric( output.b[ which( names( output.b ) == 
                                                "ub 95%CI" ) ] ),
                 digits = round ) ->
            output.b[ which( names( output.b ) == "ub 95%CI" ) ] ;
          
          round( as.numeric( output.b[ which( names( output.b ) == 
                                                "eff. samp." ) ] ),
                 digits = round ) ->
            output.b[ which( names( output.b ) == "eff. samp." ) ] ;
          
          round( as.numeric( output.b[ which( names( output.b ) == 
                                                "M7 Estimate" ) ] ),
                 digits = round ) ->
            output.b[ which( names( output.b ) == "M7 Estimate" ) ] ;
          
          round( as.numeric( output.b[ which( names( output.b ) == 
                                                "M7 Standard Error" ) ] ),
                 digits = round ) ->
            output.b[ which( names( output.b ) == "M7 Standard Error" ) ] ;
          
          round( as.numeric( output.b[ which( names( output.b ) == 
                                                "M7 T statistic" ) ] ),
                 digits = round ) ->
            output.b[ which( names( output.b ) == "M7 T statistic" ) ] ;
          
          round( as.numeric( output.b[ which( names( output.b ) == 
                                                "M7 degree of freedom" ) ] ),
                 digits = round ) ->
            output.b[ which( names( output.b ) == "M7 degree of freedom" ) ] ;
          
          round( as.numeric( output.b[ which( names( output.b ) == 
                                                "Cohen f-squared of var2 on R-squared" ) ] ),
                 digits = round ) ->
            output.b[ which( names( output.b ) == "Cohen f-squared of var2 on R-squared" ) ] ;
          
          round( as.numeric( output.b[ which( names( output.b ) == 
                                                "Partial eta-squared" ) ] ),
                 digits = round ) ->
            output.b[ which( names( output.b ) == "Partial eta-squared" ) ] ;
        } 
        
        unlist( output.b )-> output.b ;
      }   
    }
    
    # No test possible
    if ( is.null( output.b ) )
    {
      # tests
      
      
      # fusion
      c( "other", name.a, colnames( data.vars2 )[b], identifier, "-",
         nrow(df1), nrow(data.vars2) - nrow(df1)
      ) -> output.b
      
      c( "other", 
         "var1", "var2", "identifier", "-",
         "N", "Missing"
      ) -> 
        names( output.b ) 
      
    }
    
    return( output.b )
  } 
  
  # Load packages
  download.packages( "furrr", "dplyr", "lme4", "lmerTest", "MCMCglmm", "MuMIn", "ordinal", "data.table", "openxlsx",
                     #"optmix", 
                     "car", "pbkrtest", "nortest", "moments", "effectsize", "merDeriv", "clubSandwich", "sandwich" ) ;
  
  
  # prepare data
  #=============
  as.data.frame( data ) -> data ; 
  
  data[, which( !( colnames( data ) %in% group ) ) ] -> 
    data.vars ;
  
  data.vars[, which( !( colnames( data.vars ) %in% identifier ) ) ] -> 
    data.vars ; 
  
  if ( length( level1.names ) > 1 )
  {
    cbind( data.vars[ , which( colnames( data.vars ) %in% level1.names ) ],
           data.vars[ , which( ! colnames( data.vars ) %in% level1.names ) ] ) ->
      data.vars ; 
  } else
  {
    cbind( data.vars[ , which( colnames( data.vars ) %in% level1.names ) ],
           data.vars[ , which( ! colnames( data.vars ) %in% level1.names ) ] ) ->
      data.vars ; 
    colnames(data.vars)[1] <- level1.names ;
  }
  
  data[, which( colnames( data ) %in% group ) ] -> 
    data.group ;
  
  data[, which( colnames( data ) %in% identifier ) ] -> 
    data.identifier ;
  
  # Job
  furrr::future_map( 1:length( level1.names ), 
                     fun.a,
                     data.vars = data.vars, 
                     data.group = data.group, 
                     data.identifier = data.identifier, 
                     group = group,
                     .options = furrr::furrr_options( seed = seed ), .progress = T 
  ) |>
    rbind.force(  empty = "" ) -> 
    output
  
  # prepare output
  c( "class", "var1", "var2", "ID", "Wald test p",
     "N", "Missing",
     "Method 1",
     "M1 Estimate", "Standard Error", "M1 Z value", "M1 p",
     "Method 2",
     "M2 Chi2", "M2 Degree of freedom", "M2 p",
     "Method 3", 
     "M3 Chi2", "M3 Degree of freedom", "M3 p",
     "Method 4a",
     "number of iterations", "burnin", "thin",
     "Method 4b",
     "post mean", "lb 95%CI", "ub 95%CI", "eff. samp.", "M4 p",
     "Method 5",
     "M5 Estimate", "Robust Standard Error", "M5 Z value", "M5 p",
     "Cohen f-squared of var2 on R-squared",
     "Shapiro-Wilk normality test on residuals p-value",
     "Anderson-Darling normality test on residuals p-value",
     "Jarque-Bera normality test on residuals p-value"
  ) -> titles.binomial ;
  
  c( "class", 
     "var1", "var2", "ID", "LRT p on ML",
     "N", "Missing",
     "Method 1",
     "M1 Chi2", "M1 Degree of freedom", "M1 p",
     "Method 2",
     "number of iterations", "burnin", "thin",
     "M2 p"
  ) -> titles.multinomial ;
  
  c( "class", "var1", "var2", "ID", "Wald test p",
     "N", "Missing",
     "Method 1",
     "M1 Estimate", "M1 Standard Error", "M1 T statistic", "M1 degree of freedom", "M1 p",
     "Method 2",
     "M2 Chi2", "M2 Degree of freedom", "M2 p",
     "Method 3", 
     "M3 F", "M3 Degree of freedom", "M3 degree of freedom residuals", "M3 p",
     "Method 4",
     "M4 Chi2", "M4 Degree of freedom", "M4 p",
     "Method 5a",
     "number of iterations", "burnin", "thin",
     "Method 5b",
     "post mean", "lb 95%CI", "ub 95%CI", "eff. samp.", "M5 p",
     "Method 7",
     "M6 Estimate", "M6 Standard Error", "M6 T statistic", "M6 degree of freedom", "M6 p",
     "Cohen f-squared of var2 on R-squared",
     "Partial eta-squared",
     "Shapiro-Wilk normality test on residuals p-value",
     "Anderson-Darling normality test on residuals p-value",
     "Jarque-Bera normality test on residuals p-value"
  ) -> titles.gaussian ;
  
  c( "class", 
     "var1", "var2", "identifier", "-",
     "N", "Missing"
  ) -> titles.other ; 
  
  NULL -> output.tmp
  
  for ( i in levels( factor( output[,1] ) ) )
  {
    if ( grepl( "binomial", i ) )
    {
      rbind.force( output.tmp,
                   titles.binomial,
                   output[ output[,1] == i, ],
                   empty = "" ) ->
        output.tmp ; 
    }
    
    if ( grepl( "multinomial", i ) )
    {
      rbind.force( output.tmp,
                   titles.multinomial,
                   output[ output[,1] == i, ],
                   empty = "" ) ->
        output.tmp ; 
    }
    
    if ( grepl( "gaussian", i ) )
    {
      rbind.force( output.tmp,
                   titles.gaussian,
                   output[ output[,1] == i, ],
                   empty = "" ) ->
        output.tmp ; 
    }
    
    
    if ( grepl( "other", i ) )
    {
      rbind.force( output.tmp,
                   titles.other,
                   output[ output[,1] == i, ],
                   empty = "" ) ->
        output.tmp ; 
    }
    
  }
  output.tmp -> output
  
  c( "Class", "var", "group", "N", "Missing",
     paste( rep( "col", length( 6:ncol( output ) ) ), 
            6:ncol( output ), sep = "" ) ) ->         
    colnames( output ) ;
  
  # end parallel
  future::plan("sequential")
  
  return( output ) ;
}

# 1.4.6 Function to perform triivariate analysis non paired
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Trivariate.Analysis <- function(  x, y, z,
                                  by = NULL, 
                                  na.rm = TRUE,
                                  White.correct = TRUE,
                                  Continuity.correct = TRUE,
                                  pvalue.round = 3,
                                  round = 2,
                                  nsim = 10000,
                                  remove.by = TRUE,
                                  remove.x.y.z = TRUE,
                                  ncores = NULL ) 
{
  if ( !is.data.frame( x ) ) { stop( "x is not a data.frame" );   } ;
  if ( !is.data.frame( y ) ) { stop( "y is not a data.frame" );   } ;
  if ( !is.data.frame( z ) ) { stop( "z is not a data.frame" );   } ;
  if ( !is.character( by ) ) { stop( "by is not a string" );   } ;
  if ( !is.logical( na.rm ) ) { stop( "na.rm is not TRUE or FALSE" );    } ;
  if ( !is.logical( White.correct ) ) { stop( "Welch.correct is not TRUE or FALSE" );    } ;
  if ( !is.logical( Continuity.correct ) ) { stop( "Continuity.correct is not TRUE or FALSE" );    } ;
  if ( !( is.numeric( pvalue.round ) | 
          is.null( pvalue.round ) ) ) { stop( "pvalue.round is neither numeric, neither NULL" );    } ;
  if ( !( is.numeric( round ) | 
          is.null( round ) ) ) { stop( "round is neither numeric, neither NULL" );    } ;
  if ( !is.numeric( nsim ) ) { stop( "nsim is not numeric" );    } ;
  if ( !is.logical( remove.by ) ) { stop( "remove.by is not TRUE or FALSE" );    } ;
  if ( !is.logical( remove.x.y.z ) ) { stop( "remove.x.y.z is not TRUE or FALSE" );    } ;
  if ( !is.null(ncores) & !is.numeric(ncores) ) { stop( "ncores is not null nor numeric" ) }
  
  # parallel
  if ( !is.null( ncores ) ) { future::plan( "multisession",  workers = ncores ) }
  
  # Domestic functions
  
  download.packages <- function( PackagesNames, ... )
  {
    # Get a vector with packages names 
    packages1 <- c( PackagesNames, ... ) ;
    
    # Install packages
    for (a in 1:length( packages1 ) )
    {
      try( find.package( packages1[a]), silent = TRUE ) -> test ;
      
      if ( class( test ) == "try-error" )
      { print( packages1[a] ) ; 
        install.packages(  packages1[a] ) ;
      } 
    }
  } ;
  
  rbind.force <- function( data, ..., keep.col = FALSE, empty = NA ) 
  {
    # Unify data
    list( data, ... ) -> input ;
    
    # include list elements
    repeat 
    {
      if (  !any( unlist( lapply( input, class ) ) == "list" ) ) { break }  
      
      which( unlist( lapply( input, class ) ) == "list" )[1] -> a ;
      input[[a]] -> tmp ;
      input[[a]] <- NA ;
      c( input[1:a],  tmp, input[ (a + 1):length( input ) ] ) -> 
        input ;
    }
    
    input[ !is.na( input ) ] ->
      input ;
    
    # delete NULL data and transformt vector in data.frame
    for ( a in 1:length( input ) )
    {
      if ( is.null( dim( input[[a]] ) ) )
      {
        if ( is.null( input[[a]] ) )
        {
          input[[a]] <- NA ;
        } else
        {
          data.frame( matrix( input[[a]], nrow = 1 ),
                      stringsAsFactors = FALSE ) -> input[[a]] ; 
        }
      }
      
      if ( all( dim( input[[a]] ) == 0 ) )
      {
        input[[a]] <- NA ;
      }
    }
    
    input[ !is.na( input ) ] ->
      input ;
    
    # test data class
    if ( !all( unlist( lapply( input, is.data.frame ) ) |
               unlist( lapply( input, is.matrix ) ) |
               unlist( lapply( input, is.vector ) ) ) )
    { stop( "Some argument are not data.frame, neither vector" ) ;
      ; } ;
    
    # Set primer
    input[[1]] -> output ; 
    
    # job in case we keep columns 
    if ( keep.col & length( input ) >1 )
    {
      for ( a in 2:length( input ) )
      { 
        output -> x ;
        input[[a]] -> y ; 
        
        for (a in 1:dim(x)[2]) { x[,a] <- as.character(x[,a])}
        for (a in 1:dim(y)[2]) { y[,a] <- as.character(y[,a])}
        
        x.diff <- setdiff(colnames(x), colnames(y))
        y.diff <- setdiff(colnames(y), colnames(x))
        
        if( dim(x)[1] > 0 ) { x[, c(as.character(y.diff))] <- empty ; }
        if( dim(y)[1] > 0 ) { y[, c(as.character(x.diff))] <- empty ; }
        
        rbind(x, y) -> output ;
      } 
    }
    
    # job in case we do not keep columns
    if ( !keep.col & length( input ) >1 )
    {
      for ( a in 2:length( input ) )
      { 
        output -> x ;
        input[[a]] -> y ; 
        
        colnames(x) <- paste( "X",
                              1:dim( x )[2], 
                              sep = "" ) ;
        colnames(y) <- paste( "X",
                              1:dim( y )[2], 
                              sep = "" ) ;
        
        for (a in 1:dim(x)[2]) { x[,a] <- as.character(x[,a])}
        for (a in 1:dim(y)[2]) { y[,a] <- as.character(y[,a])}
        
        x.diff <- setdiff(colnames(x), colnames(y))
        y.diff <- setdiff(colnames(y), colnames(x))
        
        if( dim(x)[1] > 0 ) { x[, c(as.character(y.diff))] <- empty ; }
        if( dim(y)[1] > 0 ) { y[, c(as.character(x.diff))] <- empty ; }
        
        rbind(x, y) -> output ;
      } 
    }
    
    return( output ) ;
  } 
  
  p.round <- function( data, digits = 3 )
  {
    if (digits == 1)
    { "" -> tmp1 ; } else 
    { rep( "0", digits - 1 ) -> tmp1 ; }
    
    "0." -> tmp2 ;
    for( a in 1:length(tmp1) )
    {
      paste( tmp2, tmp1[a], sep = "" ) -> tmp2 ;
    }
    
    paste( tmp2, "1", sep = "" ) -> pval ;
    
    for ( a in 1:length(data) )
    {
      if ( !is.na( data[a] ) )
      {
        if ( data[a] >= as.numeric( pval ) )
        {
          round( data[a], digits = digits ) -> data[a] ;
        }
      }
    }
    
    data[ data < as.numeric( pval ) ] <- paste( "< ", pval, sep = "" ) ;
    
    return( data ) ;
  }
  
  MeanCramersV <- function( x, y, z, na.rm = TRUE )
  {
    CramersV <- function( x, y, na.rm = TRUE )
    {
      if ( na.rm ) 
      {
        na.omit( data.frame( x, y ) ) -> df ;
        df$x -> x ;
        df$y -> y ;  
      }
      
      ftable( x, y ) -> cont.table ;
      
      chisq.test( cont.table )$statistic -> X2 ;
      
      ( X2 / ( length( x ) * ( min( nrow( cont.table ), ncol( cont.table ) ) - 1 ) ) 
      ) -> V2 ;
      
      sqrt( V2 ) -> V
      "Cramer's V"-> names( V ) ;
      
      return( V )   
    } 
    
    data.frame( x = x, y = y, z = z ) -> df ;
    
    lapply( 1:nlevels( z ),
            function(a) 
            { CramersV( df[ df[, c( "z" ) ] == levels( z )[a], c("x") ],
                        df[ df[, c( "z" ) ] == levels( z )[a], c("y") ],
                        na.rm = na.rm ) } 
    ) ->
      ListOfV ;
    
    mean( unlist( ListOfV ) )
  } 
  
  woolf.test <- function(x) 
  {
    if ( dim(x)[1] == 2 &
         dim(x)[2] == 2 )
    {
      x <- x + 1 / 2
      k <- dim(x)[3]
      df <- k - 1
      or <- apply(x, 3, function(x) (x[1,1]*x[2,2])/(x[1,2]*x[2,1]))
      w <-  apply(x, 3, function(x) 1 / sum(1 / x))
      X2 <- sum(w * (log(or) - weighted.mean(log(or), w)) ^ 2)
      p <- 1 - pchisq(X2, df)
      
      names( X2 ) <- "X²" 
      names( df ) <- "df"
      method <- "Woolf-test on Homogeneity of Odds Ratios"
    }
    else
    {
      X2 <- NA 
      df <- NA
      p = NA
      method <- "More than 2 dimensions in strata, test non applicable."
    }
    
    list( statistic = X2,
          parameter = df,
          p.value = p,
          method = method )
  }
  
  ScheirerRayHare.test <-  function( quanti, quali1, quali2, interaction = FALSE,
                                     na.omit = FALSE )
  {
    if ( interaction )
    {
      if ( na.omit )
      {
        lm1 <- lm( rank( quanti ) ~ quali1 * quali2, na.action = na.omit ) ;
      } else
      {
        lm1 <- lm( rank( quanti ) ~ quali1 * quali2, na.action = NULL ) ;
      }
    } else
    {
      if ( na.omit )
      {
        lm1 <- lm( rank( quanti ) ~ quali1 + quali2, na.action = na.omit ) ;
      } else
      {
        lm1 <- lm( rank( quanti ) ~ quali1 + quali2, na.action = NULL ) ;
      }
    }
    
    anolm1 <- anova( lm1 ) ;
    
    if ( interaction )
    {
      MS <-  anolm1[1:3,1:3] ;
    } else
    {
      MS <-  anolm1[1:2,1:3] ;
    }
    
    MS[,4] <- MS[,2] / ( length( quanti ) * ( length( quanti ) + 1) / 12) ;
    MS[,5] <- (1 - pchisq( MS[,4], MS[,1] ) ) ;
    colnames(MS)[4:5] <- c( "H", "pvalue" ) ;
    
    return( MS )
  }
  
  fun.a <- function( a, x, y, g.data, na.rm, White.correct, Continuity.correct, 
                     pvalue.round, round, nsim )
  {
    rbind.force( lapply( (dim(x)[2] + 1):(dim(x)[2] + dim(y)[2] - 1),
                         FUN = fun.b,
                         a = a,
                         x = x, 
                         y = y,
                         g.data = g.data,
                         na.rm = na.rm, 
                         White.correct = White.correct,
                         Continuity.correct = Continuity.correct,
                         pvalue.round = pvalue.round,
                         round = round,
                         nsim = nsim ),
                 empty = "" ) -> 
      output.a
    
    return( output.a )
  }
  
  fun.b <- function( b, a, x, y, g.data, na.rm, White.correct, Continuity.correct, 
                     pvalue.round, round, nsim )
  {
    rbind.force( lapply( (dim(x)[2] + dim(y)[2]):(dim(g.data)[2]),
                         FUN = fun.c,
                         a = a,
                         b = b,
                         x = x, 
                         y = y,
                         g.data = g.data,
                         na.rm = na.rm, 
                         White.correct = White.correct,
                         Continuity.correct = Continuity.correct,
                         pvalue.round = pvalue.round,
                         round = round,
                         nsim = nsim ),
                 empty = "" ) -> 
      output.b
    
    return( output.b )
  }
  
  fun.c <- function( c, a, b, x, y, g.data, na.rm, White.correct, Continuity.correct, 
                     pvalue.round, round, nsim )
  {
    print("a") ; print(a) ; print("b") ; print(b) ; print("c") ; print(c) ;
    
    # fusion of var
    g.data[, c( a, b, c ) ]  -> df ;
    
    # clean NA
    if ( na.rm )
    {
      na.omit( df ) -> df ;
      
      if ( is.factor( df[,1] ) ) { factor( df[,1] ) -> df[,1] ; }
      if ( is.factor( df[,2] ) ) { factor( df[,2] ) -> df[,2] ; }
      if ( is.factor( df[,3] ) ) { factor( df[,3] ) -> df[,3] ; }
    }
    
    df -> df2 ; 
    colnames( df2 ) <- c( "var1", "var2", "var3" ) ;
    
    # primer
    NULL -> output.c ;
    
    # Three factors
    if ( is.factor( df[,1] ) &
         is.factor( df[,2] ) &
         is.factor( df[,3] ) 
    )
    {
      if (           nlevels( df[,1] ) > 1 &
                     nlevels( df[,2] ) > 1 &
                     nlevels( df[,3] ) > 1 &
                     all( table( df[,1], df[,2], df[,3] ) > 2 ) )
      {
        woolf.test( table( df[,1], df[,2], df[,3] ) ) -> 
          woolf ;
        mantelhaen.test( table( df[,1], df[,2], df[,3] ), 
                         correct = Continuity.correct ) -> 
          cmh ;
        coin::cmh_test( table( df[,1], df[,2], df[,3] ), 
                        distribution = coin::approximate( B = nsim ) ) -> 
          cmh.perm ;
        MeanCramersV( df[,1], df[,2], df[,3] ) -> 
          meanV ;
        correction <- Continuity.correct ;
        if ( is.null( cmh$estimate ) ) { cmh$estimate <- NA ;
        correction <- NA ; }
        if ( nlevels( df2$var1 ) == 2) 
        {
          glm( var1 ~ var2 + var3, data = df2, family = binomial ) -> m1 ;
          glm( var1 ~ var3, data = df2, family = binomial ) -> m2 ;
          glm( var1 ~ 1, data = df2, family = binomial ) -> m3 ;
          
          anova( m1, m2, test = "LRT" )-> ANODE ;
          abs( ANODE$Deviance[2] ) -> LRT.chi ;
          abs( ANODE$Df[2] ) -> LRT.df ;
          ANODE$`Pr(>Chi)`[2] -> LRT.p ;
          
          1 - exp( -2 / nrow( m1$data ) * ( logLik( m1 )[1] - logLik( m3 )[1] ) ) -> Rcs1 ;
          1 - exp( -2 / nrow( m2$data ) * ( logLik( m2 )[1] - logLik( m3 )[1] ) ) -> Rcs2 ;
          (Rcs1 - Rcs2) / (1 - Rcs1)-> f2 ; 
          
          sum( cooks.distance( m1 ) > 4 / nrow( df2 ) ) -> nb.cook ;
          car::vif( m1 ) ->  gvif ;
          car::durbinWatsonTest( m1 ) -> dw ;
          summary( m1 )$dispersion -> disp ;
        } else
        {
          nnet::multinom( var1 ~  var2 + var3, data = df2 ) -> m1 ;
          nnet::multinom( var1  ~  var3, data = df2 ) -> m2 ;
          nnet::multinom( var1 ~ 1 , data = df2 ) -> m3 ;
          
          anova( m1, m2, test = "Chisq" )-> ANODE ;
          abs( ANODE$`LR stat.`[2] ) -> LRT.chi ;
          abs( ANODE$`   Df`[2] ) -> LRT.df ;
          ANODE$`Pr(Chi)`[2] -> LRT.p ;
          
          1 - exp( -2 / nrow( df2 ) * ( logLik( m1 )[1] - logLik( m3 )[1] ) ) -> Rcs1 ;
          1 - exp( -2 / nrow( df2 ) * ( logLik( m2 )[1] - logLik( m3 )[1] ) ) -> Rcs2 ;
          (Rcs1 - Rcs2) / (1 - Rcs1)-> f2 ; 
          
          NA -> nb.cook ;
          car::vif( m1 ) -> gvif ;
          list( p = NA ) -> dw ;
          NA -> disp ;
        }
        
        
        coin::pvalue( cmh.perm ) -> p.value ;
        paste( cmh.perm@method,
               cmh.perm@distribution@name ) -> method ; 
        
        
        c( "quali3",
           colnames( df )[1], 
           colnames( df )[2],
           colnames( df )[3],
           length( df[,1] ),
           length( g.data[,1] ) - length( df[,1] ),
           p.value,
           method,
           woolf$method,
           woolf$statistic,
           woolf$parameter,
           woolf$p.value,
           cmh$method,
           correction,
           cmh$statistic,
           cmh$parameter,
           cmh$p.value,
           cmh.perm@method,
           cmh.perm@distribution@name,
           nsim,
           coin::statistic( cmh.perm ),
           coin::pvalue( cmh.perm ),
           "Analysis Of Deviance with likelihood ratio test with no interaction",
           LRT.chi,
           LRT.df,
           LRT.p,
           meanV,
           cmh$estimate,
           f2,
           nb.cook,
           gvif[1],
           gvif[2],
           gvif[5],
           gvif[6],
           dw$p,
           disp
        ) -> 
          output.c ;
        
        c( "quali3", "var1", "var2", "var3",
           "N", "Missing",
           "p-value", "Method",
           "Woolf method",
           "Woolf Chi-squared",
           "Woolf degree of freedom",
           "Woolf p-value",
           "Cochran-Mantel-Haenszel method",
           "Continuity correction",
           "CHM M-squared",
           "CMH degree of freedom",
           "CMH p-value",
           "Monte Carlo CMH simulation method",
           "Monte Carlo CMH distribution",
           "Monte Carlo CMH number of simulations",
           "Monte Carlo CMH M-squared",
           "Monte Carlo CMH p-value",
           "ANODE method",
           "ANODE chi-squared",
           "ANODE degree of freedom",
           "ANODE p-value",
           "Mean Cramer's V",
           "Common odds ratio",
           "Cohen f-squared of var2 on Cox and Snell Pseudo R-squared",
           "Number of observations with a cook distance above cut-off",
           "Generalized Variance-Inflation Factor Var2",
           "Generalized Variance-Inflation Factor Var3",
           "Generalized Variance-Inflation Factor^[1/(2*df)] Var2",
           "Generalized Variance-Inflation Factor^[1/(2*df)] Var3",
           "Durbin-Watson Test for Autocorrelated Errors p-value",
           "Dispersion"
        ) -> 
          names( output.c ) ;
        
        if ( !is.null( pvalue.round ) ) 
        { 
          p.round( as.numeric( output.c[ which( names( output.c ) == 
                                                  "p-value" ) ] ),
                   digits = pvalue.round ) ->
            output.c[ which( names( output.c ) == "p-value" ) ] ;
          
          p.round( as.numeric( output.c[ which( names( output.c ) == 
                                                  "Woolf p-value" ) ] ),
                   digits = pvalue.round ) ->
            output.c[ which( names( output.c ) == "Woolf p-value" ) ] ;
          
          p.round( as.numeric( output.c[ which( names( output.c ) == 
                                                  "CMH p-value" ) ] ),
                   digits = pvalue.round ) ->
            output.c[ which( names( output.c ) == "CMH p-value" ) ] ;
          
          p.round( as.numeric( output.c[ which( names( output.c ) == 
                                                  "Monte Carlo CMH p-value" ) ] ),
                   digits = pvalue.round ) ->
            output.c[ which( names( output.c ) == "Monte Carlo CMH p-value" ) ] ;
          
          p.round( as.numeric( output.c[ which( names( output.c ) == 
                                                  "ANODE p-value" ) ] ),
                   digits = pvalue.round ) ->
            output.c[ which( names( output.c ) == "ANODE p-value" ) ] ;
          
          p.round( as.numeric( output.c[ which( names( output.c ) == 
                                                  "Durbin-Watson Test for Autocorrelated Errors p-value" ) ] ),
                   digits = pvalue.round ) ->
            output.c[ which( names( output.c ) == "Durbin-Watson Test for Autocorrelated Errors p-value" ) ] ;
        }
        
        if ( !is.null( round ) ) 
        { 
          round( as.numeric( output.c[ which( names( output.c ) == 
                                                "Woolf Chi-squared" ) ] ),
                 digits = round ) ->
            output.c[ which( names( output.c ) == "Woolf Chi-squared" ) ] ;
          
          round( as.numeric( output.c[ which( names( output.c ) == 
                                                "CHM M-squared" ) ] ),
                 digits = round ) ->
            output.c[ which( names( output.c ) == "CHM M-squared" ) ] ;
          
          round( as.numeric( output.c[ which( names( output.c ) == 
                                                "Monte Carlo CMH M-squared" ) ] ),
                 digits = round ) ->
            output.c[ which( names( output.c ) == "Monte Carlo CMH M-squared" ) ] ;
          
          round( as.numeric( output.c[ which( names( output.c ) == 
                                                "ANODE chi-squared" ) ] ),
                 digits = round ) ->
            output.c[ which( names( output.c ) == "ANODE chi-squared" ) ] ;
          
          round( as.numeric( output.c[ which( names( output.c ) == 
                                                "Mean Cramer's V" ) ] ),
                 digits = round ) ->
            output.c[ which( names( output.c ) == "Mean Cramer's V" ) ] ;
          
          round( as.numeric( output.c[ which( names( output.c ) == 
                                                "Common odds ratio" ) ] ),
                 digits = round ) ->
            output.c[ which( names( output.c ) == "Common odds ratio" ) ] ;
          
          round( as.numeric( output.c[ which( names( output.c ) == 
                                                "Cohen f-squared of var2 on Cox and Snell Pseudo R-squared" ) ] ),
                 digits = round ) ->
            output.c[ which( names( output.c ) == "Cohen f-squared of var2 on Cox and Snell Pseudo R-squared" ) ] ;
          
          round( as.numeric( output.c[ which( names( output.c ) == 
                                                "Generalized Variance-Inflation Factor Var2" ) ] ),
                 digits = round ) ->
            output.c[ which( names( output.c ) == "Generalized Variance-Inflation Factor Var2" ) ] ;
          
          round( as.numeric( output.c[ which( names( output.c ) == 
                                                "Generalized Variance-Inflation Factor Var3" ) ] ),
                 digits = round ) ->
            output.c[ which( names( output.c ) == "Generalized Variance-Inflation Factor Var3" ) ] ;
          
          round( as.numeric( output.c[ which( names( output.c ) == 
                                                "Generalized Variance-Inflation Factor^[1/(2*df)] Var2" ) ] ),
                 digits = round ) ->
            output.c[ which( names( output.c ) == "Generalized Variance-Inflation Factor^[1/(2*df)] Var2" ) ] ;
          
          round( as.numeric( output.c[ which( names( output.c ) == 
                                                "Generalized Variance-Inflation Factor^[1/(2*df)] Var3" ) ] ),
                 digits = round ) ->
            output.c[ which( names( output.c ) == "Generalized Variance-Inflation Factor^[1/(2*df)] Var3" ) ] ;
          
          round( as.numeric( output.c[ which( names( output.c ) == 
                                                "Dispersion" ) ] ),
                 digits = round ) ->
            output.c[ which( names( output.c ) == "Dispersion" ) ] ;
        } 
      }
      
    }
    
    # Three numerics
    if ( is.numeric( df[,1] ) &
         is.numeric( df[,2] ) &
         is.numeric( df[,3] ) )
    {
      if (  !all( df[,1] == df[,2] ) & 
            !all( df[,1] == df[,3] ) & 
            !all( df[,2] == df[,3] ) &
            nlevels( factor( df[,1] ) ) > 3 &
            nlevels( factor( df[,2] ) ) > 3 &
            nlevels( factor( df[,3] ) ) > 3  &
            length( df[,1] ) > 7 )
      {
        if ( length( df2$var1 ) < 5000 ) 
        { shapiro.test( df2$var1 ) -> shapiro1 ; }  else
        { list( "p.value" = NA ) -> shapiro1 ; }
        if ( length( df2$var2 ) < 5000 ) 
        { shapiro.test( df2$var2 ) -> shapiro2 ; }  else
        { list( "p.value" = NA ) -> shapiro2 ; }
        nortest::ad.test( df2$var1 ) -> anderson1 ;
        nortest::ad.test( df2$var2 ) -> anderson2 ;
        moments::jarque.test( df2$var1 ) -> jarque1 ;
        moments::jarque.test( df2$var2 ) -> jarque2 ;
        
        if ( any( c( shapiro1$p.value, anderson1$p.value, jarque1$p.value,
                     shapiro2$p.value, anderson2$p.value, jarque2$p.value ) < 0.05 ) ) 
        { FALSE -> normal ; } else { TRUE -> normal } 
        
        lm( var1 ~ var3, data = df2 )$residuals -> pv1 ;
        lm( var2 ~ var3, data = df2 )$residuals -> pv2 ;
        list( estimate = NULL ) -> pearson ;
        cor( pv1, pv2 , method = "pearson" ) -> pearson$estimate ;
        ( pearson$estimate / sqrt( (1 - pearson$estimate^2) / (length(pv1) - 3) ) ) -> 
          pearson$statistic ;
        ( length(pv1) - 3 ) -> pearson$parameter ;
        ( pt( abs( pearson$statistic ), 
              pearson$parameter, 
              lower.tail = FALSE ) * 2 ) -> pearson$p.value ;
        ( "Pearson's product-moment partial correlation based on linear regressions, degree of freedom corrected" ) -> pearson$method ;
        
        data.frame( var1 = rank( df2$var1, ties.method = "average" ),
                    var2 = rank( df2$var2, ties.method = "average" ),
                    var3 = rank( df2$var3, ties.method = "average" ) 
        ) -> df2.bis ;
        lm( var1 ~ var3, data = df2.bis )$residuals -> pv3 ;
        lm( var2 ~ var3, data = df2.bis )$residuals -> pv4 ;
        list( estimate = NULL ) -> spearman ;
        cor( pv3, pv4 , method = "pearson" ) -> spearman$estimate ;
        ( spearman$estimate / sqrt( (1 - spearman$estimate^2) / (length(pv3) - 3) ) ) -> 
          spearman$statistic ;
        ( length(pv3) - 3 ) -> spearman$parameter ;
        ( pt( abs( spearman$statistic ), 
              spearman$parameter, 
              lower.tail = FALSE ) * 2 ) -> spearman$p.value ;
        ( "Spearman's rank partial correlation based on linear regressions of ranked variables, degree of freedom corrected" ) -> spearman$method ;
        
        
        lm( var1 ~ var2 + var3, data = df2 ) -> m1 ;
        lm( var1 ~ var3, data = df2 ) -> m2 ;
        car::Anova( m1, type = "3", white.adjust = White.correct ) -> ANOVA ;
        car::Anova( m1, type = "3", white.adjust = FALSE ) -> ANOVA2 ;
        if ( White.correct ) { Fstat <- ANOVA$F[2] } else { Fstat <- ANOVA$`F value`[2] }
        ANOVA2$`Sum Sq`[2] / (ANOVA2$`Sum Sq`[2] + ANOVA2$`Sum Sq`[4]) ->  eta2 ;
        (summary( m1 )$r.squared - summary( m2 )$r.squared) / 
          (1 - summary( m1 )$r.squared) -> f2 ;
        
        
        if (normal)
        {
          pearson$p.value -> p.value ;
          pearson$method -> method ;   
        } else
        {
          spearman$p.value -> p.value ;
          spearman$method -> method ;  
        }
        
        
        sum( cooks.distance( m1 ) > 4 / nrow( df2 ) ) -> nb.cook ;
        car::vif( m1 ) -> gvif ;
        car::durbinWatsonTest( m1 ) -> dw ;
        car::ncvTest( m1 ) -> ncv ;
        residuals( m1 ) -> residuals1 ;
        if ( length( residuals1 ) < 5000 ) 
        { shapiro.test( residuals1 ) -> shapiro.res ; }  else
        { list( "p.value" = NA ) -> shapiro.res ; }
        nortest::ad.test( residuals1 ) -> anderson.res ;
        moments::jarque.test( residuals1 ) -> jarque.res ;
        try( car::residualPlots( m1, plot = FALSE ), silent = T ) -> resPlots ;
        
        if ( class( resPlots ) == "try-error" )
        { 
          data.frame( rep( "Not computable", 3), rep( "Not computable", 3) ) -> resPlots ;
          rownames(resPlots) <- c( "1", "2", "Tukey test") ;
          colnames(resPlots) <- c( "1", "Pr(>|Test stat|)" ) ;
        } 
        
        c( "quanti3",
           colnames( df )[1], 
           colnames( df )[2],
           colnames( df )[3],
           length( df[,1] ),
           length( g.data[,1] ) - length( df[,1] ),
           p.value,
           method,
           shapiro1$p.value,
           anderson1$p.value,
           jarque1$p.value,
           shapiro2$p.value,
           anderson2$p.value,
           jarque2$p.value,
           normal,
           pearson$method,
           pearson$statistic,
           pearson$parameter,
           pearson$p.value,
           spearman$method,
           spearman$statistic,
           spearman$parameter,
           spearman$p.value,
           "Analysis of variance of type 3 with no interaction",
           White.correct,
           Fstat,
           ANOVA$Df[2],
           ANOVA$Df[4],
           ANOVA$`Pr(>F)`[2],
           pearson$estimate,
           pearson$estimate^2,
           spearman$estimate,
           eta2,
           f2,
           nb.cook,
           gvif[1],
           gvif[2],
           dw$p,
           ncv$p,
           shapiro.res$p.value,
           anderson.res$p.value,
           jarque.res$p.value,
           resPlots[ "Tukey test", "Pr(>|Test stat|)"],
           resPlots[ 1, "Pr(>|Test stat|)"],
           resPlots[ 2, "Pr(>|Test stat|)"]
        ) -> 
          output.c ;
        
        c( "quanti3", "var1", "var2", "var3",
           "N", "Missing",
           "p-value", "Method",
           "var1 Shapiro p-value",
           "var1 Anderson-Darling p-value",
           "var1 Jarque-Bera p-value",
           "var2 Shapiro p-value",
           "var2 Anderson-Darling p-value",
           "var2 Jarque-Bera p-value",
           "var1 & var2 normal",
           "Pearson method for partial correlation",
           "T ratio",
           "Degree of freeedom",
           "Pearson p-value",
           "Spearman method for partial correlation",
           "Spearman T statistic",
           "Degree of freedom",
           "Spearman p-value",
           "ANOVA method",
           "White adjustment for heteroscedasticity",
           "ANOVA F statistic",
           "ANOVA Degree of freedom numerator",
           "ANOVA Degree of freedom denominator",
           "ANOVA p-value",
           "Pearson r correlation coefficient",
           "R-squared coefficient of determinationt",
           "Spearman rho correlation coefficient",
           "Partial eta-squared",
           "Cohen f-squared of var2 on R-squared",
           "Number of observations with a cook distance above cut-off",
           "Variance-Inflation Factor Var2",
           "Variance-Inflation Factor Var3",
           "Durbin-Watson Test for Autocorrelated Errors p-value",
           "Score Test for Non-Constant Error Variance p-value",
           "Shapiro-Wilk normality test on residuals p-value",
           "Jarque-Bera normality test on residuals p-value",
           "Anderson-Darling normality test on residuals p-value",
           "Tukey's test for nonadditivity p-value",
           "Curvature Test p-value for Var2",
           "Curvature Test p-value for Var3"
        ) -> 
          names( output.c ) ;
        
        if ( !is.null( pvalue.round ) ) 
        {  
          p.round( as.numeric( output.c[ which( names( output.c ) == 
                                                  "p-value" ) ] ),
                   digits = pvalue.round ) ->
            output.c[ which( names( output.c ) == "p-value" ) ] ;
          
          p.round( as.numeric( output.c[ which( names( output.c ) == 
                                                  "var1 Shapiro p-value" ) ] ),
                   digits = pvalue.round ) ->
            output.c[ which( names( output.c ) == "var1 Shapiro p-value" ) ] ;
          
          p.round( as.numeric( output.c[ which( names( output.c ) == 
                                                  "var1 Anderson-Darling p-value" ) ] ),
                   digits = pvalue.round ) ->
            output.c[ which( names( output.c ) == "var1 Anderson-Darling p-value" ) ] ;
          
          p.round( as.numeric( output.c[ which( names( output.c ) == 
                                                  "var1 Jarque-Bera p-value" ) ] ),
                   digits = pvalue.round ) ->
            output.c[ which( names( output.c ) == "var1 Jarque-Bera p-value" ) ] ;
          
          p.round( as.numeric( output.c[ which( names( output.c ) == 
                                                  "var2 Shapiro p-value" ) ] ),
                   digits = pvalue.round ) ->
            output.c[ which( names( output.c ) == "var2 Shapiro p-value" ) ] ;
          
          p.round( as.numeric( output.c[ which( names( output.c ) == 
                                                  "var2 Anderson-Darling p-value" ) ] ),
                   digits = pvalue.round ) ->
            output.c[ which( names( output.c ) == "var2 Anderson-Darling p-value" ) ] ;
          
          p.round( as.numeric( output.c[ which( names( output.c ) == 
                                                  "var2 Jarque-Bera p-value" ) ] ),
                   digits = pvalue.round ) ->
            output.c[ which( names( output.c ) == "var2 Jarque-Bera p-value" ) ] ;
          
          p.round( as.numeric( output.c[ which( names( output.c ) == 
                                                  "Pearson p-value" ) ] ),
                   digits = pvalue.round ) ->
            output.c[ which( names( output.c ) == "Pearson p-value" ) ] ;
          
          p.round( as.numeric( output.c[ which( names( output.c ) == 
                                                  "Spearman p-value" ) ] ),
                   digits = pvalue.round ) ->
            output.c[ which( names( output.c ) == "Spearman p-value" ) ] ;
          
          p.round( as.numeric( output.c[ which( names( output.c ) == 
                                                  "ANOVA p-value" ) ] ),
                   digits = pvalue.round ) ->
            output.c[ which( names( output.c ) == "ANOVA p-value" ) ] ;
          
          p.round( as.numeric( output.c[ which( names( output.c ) == 
                                                  "Durbin-Watson Test for Autocorrelated Errors p-value" ) ] ),
                   digits = pvalue.round ) ->
            output.c[ which( names( output.c ) == "Durbin-Watson Test for Autocorrelated Errors p-value" ) ] ;
          
          p.round( as.numeric( output.c[ which( names( output.c ) == 
                                                  "Score Test for Non-Constant Error Variance p-value" ) ] ),
                   digits = pvalue.round ) ->
            output.c[ which( names( output.c ) == "Score Test for Non-Constant Error Variance p-value" ) ] ;
          
          p.round( as.numeric( output.c[ which( names( output.c ) == 
                                                  "Shapiro-Wilk normality test on residuals p-value" ) ] ),
                   digits = pvalue.round ) ->
            output.c[ which( names( output.c ) == "Shapiro-Wilk normality test on residuals p-value" ) ] ;
          
          p.round( as.numeric( output.c[ which( names( output.c ) == 
                                                  "Jarque-Bera normality test on residuals p-value" ) ] ),
                   digits = pvalue.round ) ->
            output.c[ which( names( output.c ) == "Jarque-Bera normality test on residuals p-value" ) ] ;
          
          p.round( as.numeric( output.c[ which( names( output.c ) == 
                                                  "Anderson-Darling normality test on residuals p-value" ) ] ),
                   digits = pvalue.round ) ->
            output.c[ which( names( output.c ) == "Anderson-Darling normality test on residuals p-value" ) ] ;
          
          p.round( as.numeric( output.c[ which( names( output.c ) == 
                                                  "Tukey's test for nonadditivity p-value" ) ] ),
                   digits = pvalue.round ) ->
            output.c[ which( names( output.c ) == "Tukey's test for nonadditivity p-value" ) ] ;
          
          p.round( as.numeric( output.c[ which( names( output.c ) == 
                                                  "Curvature Test p-value for Var2" ) ] ),
                   digits = pvalue.round ) ->
            output.c[ which( names( output.c ) == "Curvature Test p-value for Var2" ) ] ;
          
          p.round( as.numeric( output.c[ which( names( output.c ) == 
                                                  "Curvature Test p-value for Var3" ) ] ),
                   digits = pvalue.round ) ->
            output.c[ which( names( output.c ) == "Curvature Test p-value for Var3" ) ] ;
          
        }
        
        if ( !is.null( round ) ) 
        { 
          round( as.numeric( output.c[ which( names( output.c ) == 
                                                "T ratio" ) ] ),
                 digits = round ) ->
            output.c[ which( names( output.c ) == "T ratio" ) ] ;
          
          round( as.numeric( output.c[ which( names( output.c ) == 
                                                "Spearman T statistic" ) ] ),
                 digits = round ) ->
            output.c[ which( names( output.c ) ==  "Spearman T statistic" ) ] ;
          
          round( as.numeric( output.c[ which( names( output.c ) == 
                                                "ANOVA F statistic" ) ] ),
                 digits = round ) ->
            output.c[ which( names( output.c ) == "ANOVA F statistic" ) ] ;
          
          round( as.numeric( output.c[ which( names( output.c ) == 
                                                "Pearson r correlation coefficient" ) ] ),
                 digits = round ) ->
            output.c[ which( names( output.c ) == "Pearson r correlation coefficient" ) ] ;
          
          round( as.numeric( output.c[ which( names( output.c ) == 
                                                "R-squared coefficient of determinationt" ) ] ),
                 digits = round ) ->
            output.c[ which( names( output.c ) == "R-squared coefficient of determinationt" ) ] ;
          
          round( as.numeric( output.c[ which( names( output.c ) == 
                                                "Spearman rho correlation coefficient" ) ] ),
                 digits = round ) ->
            output.c[ which( names( output.c ) == "Spearman rho correlation coefficient" ) ] ;
          
          round( as.numeric( output.c[ which( names( output.c ) == 
                                                "Partial eta-squared" ) ] ),
                 digits = round ) ->
            output.c[ which( names( output.c ) == "Partial eta-squared" ) ] ;
          
          round( as.numeric( output.c[ which( names( output.c ) == 
                                                "Cohen f-squared of var2 on R-squared" ) ] ),
                 digits = round ) ->
            output.c[ which( names( output.c ) == "Cohen f-squared of var2 on R-squared" ) ] ;
          
          round( as.numeric( output.c[ which( names( output.c ) == 
                                                "Variance-Inflation Factor Var2" ) ] ),
                 digits = round ) ->
            output.c[ which( names( output.c ) == "Variance-Inflation Factor Var2" ) ] ;
          
          round( as.numeric( output.c[ which( names( output.c ) == 
                                                "Generalized Variance-Inflation Factor^[1/(2*df)] Var3" ) ] ),
                 digits = round ) ->
            output.c[ which( names( output.c ) == "Generalized Variance-Inflation Factor^[1/(2*df)] Var3" ) ] ;
        } 
      } 
    }
    
    
    # One factor and Two numerics, first way ( n ~ n + f )
    if ( is.numeric( df[,1] ) &
         is.numeric( df[,2] ) &
         is.factor( df[,3] )  )
    {
      if (  !all( df[,1] == df[,2] ) &
            nlevels( factor( df[,1] ) ) > 3 &
            nlevels( factor( df[,2] ) ) > 3 &
            nlevels( df[,3] ) > 1 &
            all( table( df[,3] ) > 4 ) )
      {
        lm( var1 ~ var2 + var3, data = df2 ) -> m1 ;
        lm( var1 ~ var3, data = df2 ) -> m2 ;
        try( car::Anova( m1, type = "3", white.adjust = White.correct ) ) -> ANOVA ;  
        if ( any( class( ANOVA ) == "try-error" ) )
        { 
          ANOVA$F <- c( "error", "error" ) ;
          ANOVA$Df <- c( "error", "error" ) ;
          ANOVA$Df <- c( "error", "error", "error", "error" ) ;
          ANOVA$`Pr(>F)` <- c( "error", "error" ) ;
        }
        car::Anova( m1, type = "3", white.adjust = FALSE ) -> ANOVA2 ;
        if ( White.correct ) { Fstat <- ANOVA$F[2] } else { Fstat <- ANOVA$`F value`[2] }
        ANOVA2$`Sum Sq`[2] / (ANOVA2$`Sum Sq`[2] + ANOVA2$`Sum Sq`[4]) -> eta2 ;
        (summary( m1 )$r.squared - summary( m2 )$r.squared) / 
          (1 - summary( m1 )$r.squared) -> f2 ;
        
        sum( cooks.distance( m1 ) > 4 / nrow( df2 ) ) -> nb.cook ;
        car::vif( m1 ) -> gvif ;
        car::durbinWatsonTest( m1 ) -> dw ;
        car::ncvTest( m1 ) -> ncv ;
        residuals( m1 ) -> residuals1 ;
        if ( length( residuals1 ) < 5000 ) 
        { shapiro.test( residuals1 ) -> shapiro.res ; }  else
        { list( "p.value" = NA ) -> shapiro.res ; }
        nortest::ad.test( residuals1 ) -> anderson.res ;
        moments::jarque.test( residuals1 ) -> jarque.res ;
        
        try( car::residualPlots( m1, plot = FALSE ), silent = T ) -> resPlots ;
        
        if ( class( resPlots ) == "try-error" )
        { 
          data.frame( rep( "Not computable", 3), rep( "Not computable", 3) ) -> resPlots ;
          rownames(resPlots) <- c( "1", "2", "Tukey test") ;
          colnames(resPlots) <- c( "1", "Pr(>|Test stat|)" ) ;
        } 
        
        ANOVA$`Pr(>F)`[2] -> p.value ;
        paste(  "Analysis of variance of type 3 with no interaction;",
                "White correction",
                White.correct ) -> method ; 
        
        
        c( "quanti2quali1",
           colnames( df )[1], 
           colnames( df )[2],
           colnames( df )[3],
           length( df[,1] ),
           length( g.data[,1] ) - length( df[,1] ),
           p.value,
           method,
           "Analysis of variance of type 3 with no interaction",
           White.correct,
           Fstat,
           ANOVA$Df[2],
           ANOVA$Df[4],
           ANOVA$`Pr(>F)`[2],
           eta2,
           f2,
           nb.cook,
           gvif[1],
           gvif[2],
           gvif[5],
           gvif[6],
           dw$p,
           ncv$p,
           shapiro.res$p.value,
           anderson.res$p.value,
           jarque.res$p.value,
           resPlots[ "Tukey test", "Pr(>|Test stat|)"],
           resPlots[ 1, "Pr(>|Test stat|)"],
           resPlots[ 2, "Pr(>|Test stat|)"]
        ) -> 
          output.c ;
        
        c( "quanti2quali1", "var1", "var2", "var3",
           "N", "Missing",
           "p-value", "Method",
           "ANOVA method",
           "White adjustment for heteroscedasticity",
           "ANOVA F statistic",
           "ANOVA Degree of freedom numerator",
           "ANOVA Degree of freedom denominator",
           "ANOVA p-value",
           "Partial eta-squared",
           "Cohen f-squared of var2 on R-squared",
           "Number of observations with a cook distance above cut-off",
           "Generalized Variance-Inflation Factor Var2",
           "Generalized Variance-Inflation Factor Var3",
           "Generalized Variance-Inflation Factor^[1/(2*df)] Var2",
           "Generalized Variance-Inflation Factor^[1/(2*df)] Var3",
           "Durbin-Watson Test for Autocorrelated Errors p-value",
           "Score Test for Non-Constant Error Variance p-value",
           "Shapiro-Wilk normality test on residuals p-value",
           "Jarque-Bera normality test on residuals p-value",
           "Anderson-Darling normality test on residuals p-value",
           "Tukey's test for nonadditivity p-value",
           "Curvature Test p-value for Var2",
           "Curvature Test p-value for Var3"
        ) -> 
          names( output.c ) ;
        
        if ( !is.null( pvalue.round ) ) 
        {  
          p.round( as.numeric( output.c[ which( names( output.c ) == 
                                                  "p-value" ) ] ),
                   digits = pvalue.round ) ->
            output.c[ which( names( output.c ) == "p-value" ) ] ;
          
          p.round( as.numeric( output.c[ which( names( output.c ) == 
                                                  "ANOVA p-value" ) ] ),
                   digits = pvalue.round ) ->
            output.c[ which( names( output.c ) == "ANOVA p-value" ) ] ;
          
          p.round( as.numeric( output.c[ which( names( output.c ) == 
                                                  "Durbin-Watson Test for Autocorrelated Errors p-value" ) ] ),
                   digits = pvalue.round ) ->
            output.c[ which( names( output.c ) == "Durbin-Watson Test for Autocorrelated Errors p-value" ) ] ;
          
          p.round( as.numeric( output.c[ which( names( output.c ) == 
                                                  "Score Test for Non-Constant Error Variance p-value" ) ] ),
                   digits = pvalue.round ) ->
            output.c[ which( names( output.c ) == "Score Test for Non-Constant Error Variance p-value" ) ] ;
          
          p.round( as.numeric( output.c[ which( names( output.c ) == 
                                                  "Shapiro-Wilk normality test on residuals p-value" ) ] ),
                   digits = pvalue.round ) ->
            output.c[ which( names( output.c ) == "Shapiro-Wilk normality test on residuals p-value" ) ] ;
          
          p.round( as.numeric( output.c[ which( names( output.c ) == 
                                                  "Jarque-Bera normality test on residuals p-value" ) ] ),
                   digits = pvalue.round ) ->
            output.c[ which( names( output.c ) == "Jarque-Bera normality test on residuals p-value" ) ] ;
          
          p.round( as.numeric( output.c[ which( names( output.c ) == 
                                                  "Anderson-Darling normality test on residuals p-value" ) ] ),
                   digits = pvalue.round ) ->
            output.c[ which( names( output.c ) == "Anderson-Darling normality test on residuals p-value" ) ] ;
          
          p.round( as.numeric( output.c[ which( names( output.c ) == 
                                                  "Tukey's test for nonadditivity p-value" ) ] ),
                   digits = pvalue.round ) ->
            output.c[ which( names( output.c ) == "Tukey's test for nonadditivity p-value" ) ] ;
          
          p.round( as.numeric( output.c[ which( names( output.c ) == 
                                                  "Curvature Test p-value for Var2" ) ] ),
                   digits = pvalue.round ) ->
            output.c[ which( names( output.c ) == "Curvature Test p-value for Var2" ) ] ;
          
          p.round( as.numeric( output.c[ which( names( output.c ) == 
                                                  "Curvature Test p-value for Var3" ) ] ),
                   digits = pvalue.round ) ->
            output.c[ which( names( output.c ) == "Curvature Test p-value for Var3" ) ] ;
          
        }
        
        if ( !is.null( round ) ) 
        { 
          round( as.numeric( output.c[ which( names( output.c ) == 
                                                "ANOVA F statistic" ) ] ),
                 digits = round ) ->
            output.c[ which( names( output.c ) == "ANOVA F statistic" ) ] ;
          
          round( as.numeric( output.c[ which( names( output.c ) == 
                                                "Partial eta-squared" ) ] ),
                 digits = round ) ->
            output.c[ which( names( output.c ) == "Partial eta-squared" ) ] ;
          
          round( as.numeric( output.c[ which( names( output.c ) == 
                                                "Cohen f-squared of var2 on R-squared" ) ] ),
                 digits = round ) ->
            output.c[ which( names( output.c ) == "Cohen f-squared of var2 on R-squared" ) ] ;
          
          round( as.numeric( output.c[ which( names( output.c ) == 
                                                "Generalized Variance-Inflation Factor Var2" ) ] ),
                 digits = round ) ->
            output.c[ which( names( output.c ) == "Generalized Variance-Inflation Factor Var2" ) ] ;
          
          round( as.numeric( output.c[ which( names( output.c ) == 
                                                "Generalized Variance-Inflation Factor Var3" ) ] ),
                 digits = round ) ->
            output.c[ which( names( output.c ) == "Generalized Variance-Inflation Factor Var3" ) ] ;
          
          round( as.numeric( output.c[ which( names( output.c ) == 
                                                "Generalized Variance-Inflation Factor^[1/(2*df)] Var2" ) ] ),
                 digits = round ) ->
            output.c[ which( names( output.c ) == "Generalized Variance-Inflation Factor^[1/(2*df)] Var2" ) ] ;
          
          round( as.numeric( output.c[ which( names( output.c ) == 
                                                "Generalized Variance-Inflation Factor^[1/(2*df)] Var3" ) ] ),
                 digits = round ) ->
            output.c[ which( names( output.c ) == "Generalized Variance-Inflation Factor^[1/(2*df)] Var3" ) ] ;
          
          
        } 
      }
    }
    
    
    # One factor and Two numerics, second way ( f ~ n + n )
    if ( is.factor( df[,1] ) &
         is.numeric( df[,2] ) &
         is.numeric( df[,3] )  )
    {
      if ( !all( df[,2] == df[,3] ) &
           nlevels( factor( df[,2] ) ) > 3 &
           nlevels( factor( df[,3] ) ) > 3 &
           nlevels( df[,1] ) > 1 &
           all( table( df[,1] ) > 4 ) )
      {
        lm( var2 ~ var1 + var3, data = df2 ) -> m1 ;
        lm( var2 ~ var3, data = df2 ) -> m2 ;
        try( car::Anova( m1, type = "3", white.adjust = White.correct ) ) -> ANOVA ;  
        if ( any( class( ANOVA ) == "try-error" ) )
        { 
          ANOVA$F <- c( "error", "error" ) ;
          ANOVA$Df <- c( "error", "error" ) ;
          ANOVA$Df <- c( "error", "error", "error", "error" ) ;
          ANOVA$`Pr(>F)` <- c( "error", "error" ) ;
        }
        car::Anova( m1, type = "3", white.adjust = FALSE ) -> ANOVA2 ;
        if ( White.correct ) { Fstat <- ANOVA$F[2] } else 
          { Fstat <- ANOVA$`F value`[2] }
        ANOVA2$`Sum Sq`[2] / (ANOVA2$`Sum Sq`[2] + ANOVA2$`Sum Sq`[4]) -> eta2 ;
        (summary( m1 )$r.squared - summary( m2 )$r.squared) / 
          (1 - summary( m1 )$r.squared) -> f2 ;
        
        sum( cooks.distance( m1 ) > 4 / nrow( df2 ) ) -> nb.cook ;
        car::vif( m1 ) -> gvif ;
        car::durbinWatsonTest( m1 ) -> dw ;
        car::ncvTest( m1 ) -> ncv ;
        residuals( m1 ) -> residuals1 ;
        if ( length( residuals1 ) < 5000 ) 
        { shapiro.test( residuals1 ) -> shapiro.res ; }  else
        { list( "p.value" = NA ) -> shapiro.res ; }
        nortest::ad.test( residuals1 ) -> anderson.res ;
        moments::jarque.test( residuals1 ) -> jarque.res ;
        try( car::residualPlots( m1, plot = FALSE ), silent = T ) -> resPlots ;
        
        if ( class( resPlots ) == "try-error" )
        { 
          data.frame( rep( "Not computable", 3), rep( "Not computable", 3) ) -> resPlots ;
          rownames(resPlots) <- c( "1", "2", "Tukey test") ;
          colnames(resPlots) <- c( "1", "Pr(>|Test stat|)" ) ;
        } 
        
        
        ANOVA$`Pr(>F)`[2] -> p.value ;
        paste(  "Analysis of variance of type 3 with no interaction;",
                "White correction",
                White.correct ) -> method ; 
        
        
        c( "quanti2quali1",
           colnames( df )[2], 
           colnames( df )[1],
           colnames( df )[3],
           length( df[,1] ),
           length( g.data[,1] ) - length( df[,1] ),
           p.value,
           method,
           "Analysis of variance of type 3 with no interaction",
           White.correct,
           Fstat,
           ANOVA$Df[2],
           ANOVA$Df[4],
           ANOVA$`Pr(>F)`[2],
           eta2,
           f2,
           nb.cook,
           gvif[1],
           gvif[2],
           gvif[5],
           gvif[6],
           dw$p,
           ncv$p,
           shapiro.res$p.value,
           anderson.res$p.value,
           jarque.res$p.value,
           resPlots[ "Tukey test", "Pr(>|Test stat|)"],
           resPlots[ 1, "Pr(>|Test stat|)"],
           resPlots[ 2, "Pr(>|Test stat|)"]
        ) -> 
          output.c ;
        
        c( "quanti2quali1", "var1", "var2", "var3",
           "N", "Missing",
           "p-value", "Method",
           "ANOVA method",
           "White adjustment for heteroscedasticity",
           "ANOVA F statistic",
           "ANOVA Degree of freedom numerator",
           "ANOVA Degree of freedom denominator",
           "ANOVA p-value",
           "Partial eta-squared",
           "Cohen f-squared of var2 on R-squared",
           "Number of observations with a cook distance above cut-off",
           "Generalized Variance-Inflation Factor Var2",
           "Generalized Variance-Inflation Factor Var3",
           "Generalized Variance-Inflation Factor^[1/(2*df)] Var2",
           "Generalized Variance-Inflation Factor^[1/(2*df)] Var3",
           "Durbin-Watson Test for Autocorrelated Errors p-value",
           "Score Test for Non-Constant Error Variance p-value",
           "Shapiro-Wilk normality test on residuals p-value",
           "Jarque-Bera normality test on residuals p-value",
           "Anderson-Darling normality test on residuals p-value",
           "Tukey's test for nonadditivity p-value",
           "Curvature Test p-value for Var2",
           "Curvature Test p-value for Var3"
        ) -> 
          names( output.c ) ;
        
        if ( !is.null( pvalue.round ) ) 
        {  
          p.round( as.numeric( output.c[ which( names( output.c ) == 
                                                  "p-value" ) ] ),
                   digits = pvalue.round ) ->
            output.c[ which( names( output.c ) == "p-value" ) ] ;
          
          p.round( as.numeric( output.c[ which( names( output.c ) == 
                                                  "ANOVA p-value" ) ] ),
                   digits = pvalue.round ) ->
            output.c[ which( names( output.c ) == "ANOVA p-value" ) ] ;
          
          p.round( as.numeric( output.c[ which( names( output.c ) == 
                                                  "Durbin-Watson Test for Autocorrelated Errors p-value" ) ] ),
                   digits = pvalue.round ) ->
            output.c[ which( names( output.c ) == "Durbin-Watson Test for Autocorrelated Errors p-value" ) ] ;
          
          p.round( as.numeric( output.c[ which( names( output.c ) == 
                                                  "Score Test for Non-Constant Error Variance p-value" ) ] ),
                   digits = pvalue.round ) ->
            output.c[ which( names( output.c ) == "Score Test for Non-Constant Error Variance p-value" ) ] ;
          
          p.round( as.numeric( output.c[ which( names( output.c ) == 
                                                  "Shapiro-Wilk normality test on residuals p-value" ) ] ),
                   digits = pvalue.round ) ->
            output.c[ which( names( output.c ) == "Shapiro-Wilk normality test on residuals p-value" ) ] ;
          
          p.round( as.numeric( output.c[ which( names( output.c ) == 
                                                  "Jarque-Bera normality test on residuals p-value" ) ] ),
                   digits = pvalue.round ) ->
            output.c[ which( names( output.c ) == "Jarque-Bera normality test on residuals p-value" ) ] ;
          
          p.round( as.numeric( output.c[ which( names( output.c ) == 
                                                  "Anderson-Darling normality test on residuals p-value" ) ] ),
                   digits = pvalue.round ) ->
            output.c[ which( names( output.c ) == "Anderson-Darling normality test on residuals p-value" ) ] ;
          
          p.round( as.numeric( output.c[ which( names( output.c ) == 
                                                  "Tukey's test for nonadditivity p-value" ) ] ),
                   digits = pvalue.round ) ->
            output.c[ which( names( output.c ) == "Tukey's test for nonadditivity p-value" ) ] ;
          
          p.round( as.numeric( output.c[ which( names( output.c ) == 
                                                  "Curvature Test p-value for Var2" ) ] ),
                   digits = pvalue.round ) ->
            output.c[ which( names( output.c ) == "Curvature Test p-value for Var2" ) ] ;
          
          p.round( as.numeric( output.c[ which( names( output.c ) == 
                                                  "Curvature Test p-value for Var3" ) ] ),
                   digits = pvalue.round ) ->
            output.c[ which( names( output.c ) == "Curvature Test p-value for Var3" ) ] ;
          
        }
        
        if ( !is.null( round ) ) 
        { 
          round( as.numeric( output.c[ which( names( output.c ) == 
                                                "ANOVA F statistic" ) ] ),
                 digits = round ) ->
            output.c[ which( names( output.c ) == "ANOVA F statistic" ) ] ;
          
          round( as.numeric( output.c[ which( names( output.c ) == 
                                                "Partial eta-squared" ) ] ),
                 digits = round ) ->
            output.c[ which( names( output.c ) == "Partial eta-squared" ) ] ;
          
          round( as.numeric( output.c[ which( names( output.c ) == 
                                                "Cohen f-squared of var2 on R-squared" ) ] ),
                 digits = round ) ->
            output.c[ which( names( output.c ) == "Cohen f-squared of var2 on R-squared" ) ] ;
          
          round( as.numeric( output.c[ which( names( output.c ) == 
                                                "Generalized Variance-Inflation Factor Var2" ) ] ),
                 digits = round ) ->
            output.c[ which( names( output.c ) == "Generalized Variance-Inflation Factor Var2" ) ] ;
          
          round( as.numeric( output.c[ which( names( output.c ) == 
                                                "Generalized Variance-Inflation Factor Var3" ) ] ),
                 digits = round ) ->
            output.c[ which( names( output.c ) == "Generalized Variance-Inflation Factor Var3" ) ] ;
          
          round( as.numeric( output.c[ which( names( output.c ) == 
                                                "Generalized Variance-Inflation Factor^[1/(2*df)] Var2" ) ] ),
                 digits = round ) ->
            output.c[ which( names( output.c ) == "Generalized Variance-Inflation Factor^[1/(2*df)] Var2" ) ] ;
          
          round( as.numeric( output.c[ which( names( output.c ) == 
                                                "Generalized Variance-Inflation Factor^[1/(2*df)] Var3" ) ] ),
                 digits = round ) ->
            output.c[ which( names( output.c ) == "Generalized Variance-Inflation Factor^[1/(2*df)] Var3" ) ] ;
          
        } 
      }
    }
    
    
    # One factor and Two numerics, thrid way ( n ~ f + n )
    if ( is.numeric( df[,1] ) &
         is.factor( df[,2] ) &
         is.numeric( df[,3] )  )
    {
      if ( !all( df[,1] == df[,3] ) &
           nlevels( factor( df[,1] ) ) > 3 &
           nlevels( factor( df[,3] ) ) > 3 &
           nlevels( df[,2] ) > 1 &
           all( table( df[,2] ) > 4 ) )
      {
        lm( var1 ~ var2 + var3, data = df2 ) -> m1 ;
        lm( var1 ~ var3, data = df2 ) -> m2 ;
        try( car::Anova( m1, type = "3", white.adjust = White.correct ) ) -> ANOVA ;  
        if ( any( class( ANOVA ) == "try-error" ) )
        { 
          ANOVA$F <- c( "error", "error" ) ;
          ANOVA$Df <- c( "error", "error" ) ;
          ANOVA$Df <- c( "error", "error", "error", "error" ) ;
          ANOVA$`Pr(>F)` <- c( "error", "error" ) ;
        }
        car::Anova( m1, type = "3", white.adjust = FALSE ) -> ANOVA2 ;
        if ( White.correct ) { Fstat <- ANOVA$F[2] } else { Fstat <- ANOVA$`F value`[2] }
        ANOVA2$`Sum Sq`[2] / (ANOVA2$`Sum Sq`[2] + ANOVA2$`Sum Sq`[4]) -> eta2 ;
        (summary( m1 )$r.squared - summary( m2 )$r.squared) / 
          (1 - summary( m1 )$r.squared) -> f2 ;
        
        sum( cooks.distance( m1 ) > 4 / nrow( df2 ) ) -> nb.cook ;
        car::vif( m1 ) -> gvif ;
        car::durbinWatsonTest( m1 ) -> dw ;
        car::ncvTest( m1 ) -> ncv ;
        residuals( m1 ) -> residuals1 ;
        if ( length( residuals1 ) < 5000 ) 
        { shapiro.test( residuals1 ) -> shapiro.res ; }  else
        { list( "p.value" = NA ) -> shapiro.res ; }
        nortest::ad.test( residuals1 ) -> anderson.res ;
        moments::jarque.test( residuals1 ) -> jarque.res ;
        try( car::residualPlots( m1, plot = FALSE ), silent = T ) -> resPlots ;
        
        if ( class( resPlots ) == "try-error" )
        { 
          data.frame( rep( "Not computable", 3), rep( "Not computable", 3) ) -> resPlots ;
          rownames(resPlots) <- c( "1", "2", "Tukey test") ;
          colnames(resPlots) <- c( "1", "Pr(>|Test stat|)" ) ;
        } 
        
        
        ANOVA$`Pr(>F)`[2] -> p.value ;
        paste(  "Analysis of variance of type 3 with no interaction;",
                "White correction",
                White.correct ) -> method ;  
        
        
        c( "quanti2quali1",
           colnames( df )[1], 
           colnames( df )[2],
           colnames( df )[3],
           length( df[,1] ),
           length( g.data[,1] ) - length( df[,1] ),
           p.value,
           method,
           "Analysis of variance of type 3 with no interaction",
           White.correct,
           Fstat,
           ANOVA$Df[2],
           ANOVA$Df[4],
           ANOVA$`Pr(>F)`[2],
           eta2,
           f2,
           nb.cook,
           gvif[1],
           gvif[2],
           gvif[5],
           gvif[6],
           dw$p,
           ncv$p,
           shapiro.res$p.value,
           anderson.res$p.value,
           jarque.res$p.value,
           resPlots[ "Tukey test", "Pr(>|Test stat|)"],
           resPlots[ 1, "Pr(>|Test stat|)"],
           resPlots[ 2, "Pr(>|Test stat|)"]
        ) -> 
          output.c ;
        
        c( "quanti2quali1", "var1", "var2", "var3",
           "N", "Missing",
           "p-value", "Method",
           "ANOVA method",
           "White adjustment for heteroscedasticity",
           "ANOVA F statistic",
           "ANOVA Degree of freedom numerator",
           "ANOVA Degree of freedom denominator",
           "ANOVA p-value",
           "Partial eta-squared",
           "Cohen f-squared of var2 on R-squared",
           "Number of observations with a cook distance above cut-off",
           "Generalized Variance-Inflation Factor Var2",
           "Generalized Variance-Inflation Factor Var3",
           "Generalized Variance-Inflation Factor^[1/(2*df)] Var2",
           "Generalized Variance-Inflation Factor^[1/(2*df)] Var3",
           "Durbin-Watson Test for Autocorrelated Errors p-value",
           "Score Test for Non-Constant Error Variance p-value",
           "Shapiro-Wilk normality test on residuals p-value",
           "Jarque-Bera normality test on residuals p-value",
           "Anderson-Darling normality test on residuals p-value",
           "Tukey's test for nonadditivity p-value",
           "Curvature Test p-value for Var2",
           "Curvature Test p-value for Var3"
        ) -> 
          names( output.c ) ;
        
        if ( !is.null( pvalue.round ) ) 
        {  
          p.round( as.numeric( output.c[ which( names( output.c ) == 
                                                  "p-value" ) ] ),
                   digits = pvalue.round ) ->
            output.c[ which( names( output.c ) == "p-value" ) ] ;
          
          p.round( as.numeric( output.c[ which( names( output.c ) == 
                                                  "ANOVA p-value" ) ] ),
                   digits = pvalue.round ) ->
            output.c[ which( names( output.c ) == "ANOVA p-value" ) ] ;
          
          p.round( as.numeric( output.c[ which( names( output.c ) == 
                                                  "Durbin-Watson Test for Autocorrelated Errors p-value" ) ] ),
                   digits = pvalue.round ) ->
            output.c[ which( names( output.c ) == "Durbin-Watson Test for Autocorrelated Errors p-value" ) ] ;
          
          p.round( as.numeric( output.c[ which( names( output.c ) == 
                                                  "Score Test for Non-Constant Error Variance p-value" ) ] ),
                   digits = pvalue.round ) ->
            output.c[ which( names( output.c ) == "Score Test for Non-Constant Error Variance p-value" ) ] ;
          
          p.round( as.numeric( output.c[ which( names( output.c ) == 
                                                  "Shapiro-Wilk normality test on residuals p-value" ) ] ),
                   digits = pvalue.round ) ->
            output.c[ which( names( output.c ) == "Shapiro-Wilk normality test on residuals p-value" ) ] ;
          
          p.round( as.numeric( output.c[ which( names( output.c ) == 
                                                  "Jarque-Bera normality test on residuals p-value" ) ] ),
                   digits = pvalue.round ) ->
            output.c[ which( names( output.c ) == "Jarque-Bera normality test on residuals p-value" ) ] ;
          
          p.round( as.numeric( output.c[ which( names( output.c ) == 
                                                  "Anderson-Darling normality test on residuals p-value" ) ] ),
                   digits = pvalue.round ) ->
            output.c[ which( names( output.c ) == "Anderson-Darling normality test on residuals p-value" ) ] ;
          
          p.round( as.numeric( output.c[ which( names( output.c ) == 
                                                  "Tukey's test for nonadditivity p-value" ) ] ),
                   digits = pvalue.round ) ->
            output.c[ which( names( output.c ) == "Tukey's test for nonadditivity p-value" ) ] ;
          
          p.round( as.numeric( output.c[ which( names( output.c ) == 
                                                  "Curvature Test p-value for Var2" ) ] ),
                   digits = pvalue.round ) ->
            output.c[ which( names( output.c ) == "Curvature Test p-value for Var2" ) ] ;
          
          p.round( as.numeric( output.c[ which( names( output.c ) == 
                                                  "Curvature Test p-value for Var3" ) ] ),
                   digits = pvalue.round ) ->
            output.c[ which( names( output.c ) == "Curvature Test p-value for Var3" ) ] ;
          
        }
        
        if ( !is.null( round ) ) 
        { 
          round( as.numeric( output.c[ which( names( output.c ) == 
                                                "ANOVA F statistic" ) ] ),
                 digits = round ) ->
            output.c[ which( names( output.c ) == "ANOVA F statistic" ) ] ;
          
          round( as.numeric( output.c[ which( names( output.c ) == 
                                                "Partial eta-squared" ) ] ),
                 digits = round ) ->
            output.c[ which( names( output.c ) == "Partial eta-squared" ) ] ;
          
          round( as.numeric( output.c[ which( names( output.c ) == 
                                                "Cohen f-squared of var2 on R-squared" ) ] ),
                 digits = round ) ->
            output.c[ which( names( output.c ) == "Cohen f-squared of var2 on R-squared" ) ] ;
          
          round( as.numeric( output.c[ which( names( output.c ) == 
                                                "Generalized Variance-Inflation Factor Var2" ) ] ),
                 digits = round ) ->
            output.c[ which( names( output.c ) == "Generalized Variance-Inflation Factor Var2" ) ] ;
          
          round( as.numeric( output.c[ which( names( output.c ) == 
                                                "Generalized Variance-Inflation Factor Var3" ) ] ),
                 digits = round ) ->
            output.c[ which( names( output.c ) == "Generalized Variance-Inflation Factor Var3" ) ] ;
          
          round( as.numeric( output.c[ which( names( output.c ) == 
                                                "Generalized Variance-Inflation Factor^[1/(2*df)] Var2" ) ] ),
                 digits = round ) ->
            output.c[ which( names( output.c ) == "Generalized Variance-Inflation Factor^[1/(2*df)] Var2" ) ] ;
          
          round( as.numeric( output.c[ which( names( output.c ) == 
                                                "Generalized Variance-Inflation Factor^[1/(2*df)] Var3" ) ] ),
                 digits = round ) ->
            output.c[ which( names( output.c ) == "Generalized Variance-Inflation Factor^[1/(2*df)] Var3" ) ] ;
          
        } 
      }
    }
    
    # Two factors and one numeric, first way ( f ~ f + n )
    if ( is.factor( df[,1] ) &
         is.factor( df[,2] ) &
         is.numeric( df[,3] )  )
    {
      if (  nlevels( factor( df[,3] ) ) > 3 &
            nlevels( df[,1] ) > 1 &
            nlevels( df[,2] ) > 1 &
            all( table( df[,1], df[,2] ) > 4 ) )
      {
        
        
        if ( nlevels( df2$var1 ) == 2) 
        {
          glm( var1 ~ var2 + var3, data = df2, family = binomial ) -> m1 ;
          glm( var1 ~ var3, data = df2, family = binomial ) -> m2 ;
          glm( var1 ~ 1, data = df2, family = binomial ) -> m3 ;
          
          anova( m1, m2, test = "LRT" )-> ANODE ;
          abs( ANODE$Deviance[2] ) -> LRT.chi ;
          abs( ANODE$Df[2] ) -> LRT.df ;
          ANODE$`Pr(>Chi)`[2] -> LRT.p ;
          
          1 - exp( -2 / nrow( m1$data ) * ( logLik( m1 )[1] - logLik( m3 )[1] ) ) -> Rcs1 ;
          1 - exp( -2 / nrow( m2$data ) * ( logLik( m2 )[1] - logLik( m3 )[1] ) ) -> Rcs2 ;
          (Rcs1 - Rcs2) / (1 - Rcs1)-> f2 ; 
          
          sum( cooks.distance( m1 ) > 4 / nrow( df2 ) ) -> nb.cook ;
          car::vif( m1 ) -> gvif ;
          car::durbinWatsonTest( m1 ) -> dw ;
          summary( m1 )$dispersion -> disp ;
        }
        else
        {
          nnet::multinom( var1 ~  var2 + var3, data = df2 ) -> m1 ;
          nnet::multinom( var1  ~  var3, data = df2 ) -> m2 ;
          nnet::multinom( var1 ~ 1 , data = df2 ) -> m3 ;
          
          anova( m1, m2, test = "Chisq" )-> ANODE ;
          abs( ANODE$`LR stat.`[2] ) -> LRT.chi ;
          abs( ANODE$`   Df`[2] ) -> LRT.df ;
          ANODE$`Pr(Chi)`[2] -> LRT.p ;
          
          1 - exp( -2 / nrow( df2 ) * ( logLik( m1 )[1] - logLik( m3 )[1] ) ) -> Rcs1 ;
          1 - exp( -2 / nrow( df2 ) * ( logLik( m2 )[1] - logLik( m3 )[1] ) ) -> Rcs2 ;
          (Rcs1 - Rcs2) / (1 - Rcs1)-> f2 ; 
          
          NA -> nb.cook ;
          car::vif( m1 ) -> gvif ;
          list( p = NA ) -> dw ;
          NA -> disp ;
        }
        
        
        LRT.p -> p.value ;
        "Analysis Of Deviance with likelihood ratio test with no interaction" -> 
          method ; 
        
        
        c( "quali2quanti1",
           colnames( df )[1], 
           colnames( df )[2],
           colnames( df )[3],
           length( df[,1] ),
           length( g.data[,1] ) - length( df[,1] ),
           p.value,
           method,
           "Analysis Of Deviance with likelihood ratio test with no interaction",
           LRT.chi,
           LRT.df,
           LRT.p,
           f2,
           nb.cook,
           gvif[1],
           gvif[2],
           gvif[5],
           gvif[6],
           dw$p,
           disp
        ) -> 
          output.c ;
        
        c( "quali2quanti1", "var1", "var2", "var3",
           "N", "Missing",
           "p-value", "Method",
           "ANODE method",
           "ANODE Chi-squared",
           "ANODE degree of freedom",
           "ANODE p-value",
           "Cohen f-squared of var2 on Cox and Snell Pseudo R-squared",
           "Number of observations with a cook distance above cut-off",
           "Generalized Variance-Inflation Factor Var2",
           "Generalized Variance-Inflation Factor Var3",
           "Generalized Variance-Inflation Factor^[1/(2*df)] Var2",
           "Generalized Variance-Inflation Factor^[1/(2*df)] Var3",
           "Durbin-Watson Test for Autocorrelated Errors p-value",
           "Dispersion"
        ) -> 
          names( output.c ) ;
        
        if ( !is.null( pvalue.round ) ) 
        {  
          p.round( as.numeric( output.c[ which( names( output.c ) == 
                                                  "p-value" ) ] ),
                   digits = pvalue.round ) ->
            output.c[ which( names( output.c ) == "p-value" ) ] ;
          
          p.round( as.numeric( output.c[ which( names( output.c ) == 
                                                  "ANODE p-value" ) ] ),
                   digits = pvalue.round ) ->
            output.c[ which( names( output.c ) == "ANODE p-value" ) ] ;
          
          p.round( as.numeric( output.c[ which( names( output.c ) == 
                                                  "Durbin-Watson Test for Autocorrelated Errors p-value" ) ] ),
                   digits = pvalue.round ) ->
            output.c[ which( names( output.c ) == "Durbin-Watson Test for Autocorrelated Errors p-value" ) ] ;
        }
        
        if ( !is.null( round ) ) 
        { 
          round( as.numeric( output.c[ which( names( output.c ) == 
                                                "ANODE Chi-squared" ) ] ),
                 digits = round ) ->
            output.c[ which( names( output.c ) == "ANODE Chi-squared" ) ] ;
          
          round( as.numeric( output.c[ which( names( output.c ) == 
                                                "Cohen f-squared of var2 on Cox and Snell Pseudo R-squared" ) ] ),
                 digits = round ) ->
            output.c[ which( names( output.c ) == "Cohen f-squared of var2 on Cox and Snell Pseudo R-squared" ) ] ;
          
          round( as.numeric( output.c[ which( names( output.c ) == 
                                                "Generalized Variance-Inflation Factor Var2" ) ] ),
                 digits = round ) ->
            output.c[ which( names( output.c ) == "Generalized Variance-Inflation Factor Var2" ) ] ;
          
          round( as.numeric( output.c[ which( names( output.c ) == 
                                                "Generalized Variance-Inflation Factor Var3" ) ] ),
                 digits = round ) ->
            output.c[ which( names( output.c ) == "Generalized Variance-Inflation Factor Var3" ) ] ;
          
          round( as.numeric( output.c[ which( names( output.c ) == 
                                                "Generalized Variance-Inflation Factor^[1/(2*df)] Var2" ) ] ),
                 digits = round ) ->
            output.c[ which( names( output.c ) == "Generalized Variance-Inflation Factor^[1/(2*df)] Var2" ) ] ;
          
          round( as.numeric( output.c[ which( names( output.c ) == 
                                                "Generalized Variance-Inflation Factor^[1/(2*df)] Var3" ) ] ),
                 digits = round ) ->
            output.c[ which( names( output.c ) == "Generalized Variance-Inflation Factor^[1/(2*df)] Var3" ) ] ;
          
        } 
      }
      
    }
    
    # Two factors and one numeric, second way ( n ~ f + f )
    if ( is.numeric( df[,1] ) &
         is.factor( df[,2] ) &
         is.factor( df[,3] ) )
    {
      if ( nlevels( factor( df[,1] ) ) > 3 &
           nlevels( df[,2] ) > 1 &
           nlevels( df[,3] ) > 1 &
           all( table( df[,2], df[,3] ) > 4 )
      )
      {
        lm( var1 ~ var2 + var3, data = df2 ) -> m1 ;
        lm( var1 ~ var3, data = df2 ) -> m2 ;
        try( car::Anova( m1, type = "3", white.adjust = White.correct ) ) -> ANOVA ;  
        if ( any( class( ANOVA ) == "try-error" ) )
        { 
          ANOVA$F <- c( "error", "error" ) ;
          ANOVA$Df <- c( "error", "error" ) ;
          ANOVA$Df <- c( "error", "error", "error", "error" ) ;
          ANOVA$`Pr(>F)` <- c( "error", "error" ) ;
        }
        car::Anova( m1, type = "3", white.adjust = FALSE ) -> ANOVA2 ;
        if ( White.correct ) { Fstat <- ANOVA$F[2] } else { Fstat <- ANOVA$`F value`[2] }
        ANOVA2$`Sum Sq`[2] / (ANOVA2$`Sum Sq`[2] + ANOVA2$`Sum Sq`[4]) -> eta2 ;
        (summary( m1 )$r.squared - summary( m2 )$r.squared) / 
          (1 - summary( m1 )$r.squared) -> f2 ;
        
        ScheirerRayHare.test( df[,1], df[,2], df[,3] ) -> SHR ; 
        
        sum( cooks.distance( m1 ) > 4 / nrow( df2 ) ) -> nb.cook ;
        car::vif( m1 ) -> gvif ;
        car::durbinWatsonTest( m1 ) -> dw ;
        car::ncvTest( m1 ) -> ncv ;
        residuals( m1 ) -> residuals1 ;
        if ( length( residuals1 ) < 5000 ) 
        { shapiro.test( residuals1 ) -> shapiro.res ; }  else
        { list( "p.value" = NA ) -> shapiro.res ; }
        nortest::ad.test( residuals1 ) -> anderson.res ;
        moments::jarque.test( residuals1 ) -> jarque.res ;
        try( car::residualPlots( m1, plot = FALSE ), silent = T ) -> resPlots ;
        
        if ( class( resPlots ) == "try-error" )
        { 
          data.frame( rep( "Not computable", 3), rep( "Not computable", 3) ) -> resPlots ;
          rownames(resPlots) <- c( "1", "2", "Tukey test") ;
          colnames(resPlots) <- c( "1", "Pr(>|Test stat|)" ) ;
        } 
        
        
        ANOVA$`Pr(>F)`[2] -> p.value ;
        paste(  "Analysis of variance of type 3 with no interaction;",
                "White correction",
                White.correct ) -> method ; 
        
        
        c( "quanti1quali2",
           colnames( df )[1], 
           colnames( df )[2],
           colnames( df )[3],
           length( df[,1] ),
           length( g.data[,1] ) - length( df[,1] ),
           p.value,
           method,
           "Analysis of variance of type 3 with no interaction",
           White.correct,
           Fstat,
           ANOVA$Df[2],
           ANOVA$Df[4],
           ANOVA$`Pr(>F)`[2],
           "Scheire Ray Hare test with no interaction",
           SHR[,"H"][1],
           SHR[,"Df"][1],
           SHR[,"pvalue"][1],
           eta2,
           f2,
           nb.cook,
           gvif[1],
           gvif[2],
           gvif[5],
           gvif[6],
           dw$p,
           ncv$p,
           shapiro.res$p.value,
           anderson.res$p.value,
           jarque.res$p.value,
           resPlots[ "Tukey test", "Pr(>|Test stat|)"]
        ) -> 
          output.c ;
        
        c( "quanti1quali2", "var1", "var2", "var3",
           "N", "Missing",
           "p-value", "Method",
           "ANOVA method",
           "White adjustment for heteroscedasticity",
           "ANOVA F statistic",
           "ANOVA Degree of freedom numerator",
           "ANOVA Degree of freedom denominator",
           "ANOVA p-value",
           "Scheire Ray Hare test method",
           "SHR H statistic",
           "SHR degree of freedom",
           "SHR p-value",
           "Partial eta-squared",
           "Cohen f-squared of var2 on R-squared",
           "Number of observations with a cook distance above cut-off",
           "Generalized Variance-Inflation Factor Var2",
           "Generalized Variance-Inflation Factor Var3",
           "Generalized Variance-Inflation Factor^[1/(2*df)] Var2",
           "Generalized Variance-Inflation Factor^[1/(2*df)] Var3",
           "Durbin-Watson Test for Autocorrelated Errors p-value",
           "Score Test for Non-Constant Error Variance p-value",
           "Shapiro-Wilk normality test on residuals p-value",
           "Jarque-Bera normality test on residuals p-value",
           "Anderson-Darling normality test on residuals p-value",
           "Tukey's test for nonadditivity p-value"
        ) -> 
          names( output.c ) ;
        
        if ( !is.null( pvalue.round ) ) 
        {  
          p.round( as.numeric( output.c[ which( names( output.c ) == 
                                                  "p-value" ) ] ),
                   digits = pvalue.round ) ->
            output.c[ which( names( output.c ) == "p-value" ) ] ;
          
          p.round( as.numeric( output.c[ which( names( output.c ) == 
                                                  "ANOVA p-value" ) ] ),
                   digits = pvalue.round ) ->
            output.c[ which( names( output.c ) == "ANOVA p-value" ) ] ;
          
          p.round( as.numeric( output.c[ which( names( output.c ) == 
                                                  "SHR p-value" ) ] ),
                   digits = pvalue.round ) ->
            output.c[ which( names( output.c ) == "SHR p-value" ) ] ;
          
          p.round( as.numeric( output.c[ which( names( output.c ) == 
                                                  "Durbin-Watson Test for Autocorrelated Errors p-value" ) ] ),
                   digits = pvalue.round ) ->
            output.c[ which( names( output.c ) == "Durbin-Watson Test for Autocorrelated Errors p-value" ) ] ;
          
          p.round( as.numeric( output.c[ which( names( output.c ) == 
                                                  "Score Test for Non-Constant Error Variance p-value" ) ] ),
                   digits = pvalue.round ) ->
            output.c[ which( names( output.c ) == "Score Test for Non-Constant Error Variance p-value" ) ] ;
          
          p.round( as.numeric( output.c[ which( names( output.c ) == 
                                                  "Shapiro-Wilk normality test on residuals p-value" ) ] ),
                   digits = pvalue.round ) ->
            output.c[ which( names( output.c ) == "Shapiro-Wilk normality test on residuals p-value" ) ] ;
          
          p.round( as.numeric( output.c[ which( names( output.c ) == 
                                                  "Jarque-Bera normality test on residuals p-value" ) ] ),
                   digits = pvalue.round ) ->
            output.c[ which( names( output.c ) == "Jarque-Bera normality test on residuals p-value" ) ] ;
          
          p.round( as.numeric( output.c[ which( names( output.c ) == 
                                                  "Anderson-Darling normality test on residuals p-value" ) ] ),
                   digits = pvalue.round ) ->
            output.c[ which( names( output.c ) == "Anderson-Darling normality test on residuals p-value" ) ] ;
          
          p.round( as.numeric( output.c[ which( names( output.c ) == 
                                                  "Tukey's test for nonadditivity p-value" ) ] ),
                   digits = pvalue.round ) ->
            output.c[ which( names( output.c ) == "Tukey's test for nonadditivity p-value" ) ] ;
          
        }
        
        if ( !is.null( round ) ) 
        { 
          round( as.numeric( output.c[ which( names( output.c ) == 
                                                "ANOVA F statistic" ) ] ),
                 digits = round ) ->
            output.c[ which( names( output.c ) == "ANOVA F statistic" ) ] ;
          
          round( as.numeric( output.c[ which( names( output.c ) == 
                                                "SHR H statistic" ) ] ),
                 digits = round ) ->
            output.c[ which( names( output.c ) == "SHR H statistic" ) ] ;
          
          round( as.numeric( output.c[ which( names( output.c ) == 
                                                "Partial eta-squared" ) ] ),
                 digits = round ) ->
            output.c[ which( names( output.c ) == "Partial eta-squared" ) ] ;
          
          round( as.numeric( output.c[ which( names( output.c ) == 
                                                "Cohen f-squared of var2 on R-squared" ) ] ),
                 digits = round ) ->
            output.c[ which( names( output.c ) == "Cohen f-squared of var2 on R-squared" ) ] ;
          
          round( as.numeric( output.c[ which( names( output.c ) == 
                                                "Generalized Variance-Inflation Factor Var2" ) ] ),
                 digits = round ) ->
            output.c[ which( names( output.c ) == "Generalized Variance-Inflation Factor Var2" ) ] ;
          
          round( as.numeric( output.c[ which( names( output.c ) == 
                                                "Generalized Variance-Inflation Factor Var3" ) ] ),
                 digits = round ) ->
            output.c[ which( names( output.c ) == "Generalized Variance-Inflation Factor Var3" ) ] ;
          
          round( as.numeric( output.c[ which( names( output.c ) == 
                                                "Generalized Variance-Inflation Factor^[1/(2*df)] Var2" ) ] ),
                 digits = round ) ->
            output.c[ which( names( output.c ) == "Generalized Variance-Inflation Factor^[1/(2*df)] Var2" ) ] ;
          
          round( as.numeric( output.c[ which( names( output.c ) == 
                                                "Generalized Variance-Inflation Factor^[1/(2*df)] Var3" ) ] ),
                 digits = round ) ->
            output.c[ which( names( output.c ) == "Generalized Variance-Inflation Factor^[1/(2*df)] Var3" ) ] ;
          
        } 
      }
      
    }
    
    # Two factors and one numeric, thrid way ( f ~ n + f )
    if ( is.factor( df[,1] ) &
         is.numeric( df[,2] ) &
         is.factor( df[,3] )  )
    {
      if (
        nlevels( factor( df[,2] ) ) > 3 &
        nlevels( df[,1] ) > 1 &
        nlevels( df[,3] ) > 1 &
        all( table( df[,1], df[,3] ) > 4 )
      )
      {
        lm( var2 ~ var1 + var3, data = df2 ) -> m1 ;
        lm( var2 ~ var3, data = df2 ) -> m2 ;
        try( car::Anova( m1, type = "3", white.adjust = White.correct ) ) -> ANOVA ;  
        if ( any( class( ANOVA ) == "try-error" ) )
        { 
          ANOVA$F <- c( "error", "error" ) ;
          ANOVA$Df <- c( "error", "error" ) ;
          ANOVA$Df <- c( "error", "error", "error", "error" ) ;
          ANOVA$`Pr(>F)` <- c( "error", "error" ) ;
        }
        car::Anova( m1, type = "3", white.adjust = FALSE ) -> ANOVA2 ;
        if ( White.correct ) { Fstat <- ANOVA$F[2] } else { Fstat <- ANOVA$`F value`[2] }
        ANOVA2$`Sum Sq`[2] / (ANOVA2$`Sum Sq`[2] + ANOVA2$`Sum Sq`[4]) -> eta2 ;
        (summary( m1 )$r.squared - summary( m2 )$r.squared) / 
          (1 - summary( m1 )$r.squared) -> f2 ;
        
        ScheirerRayHare.test( df[,2], df[,1], df[,3] ) -> SHR ; 
        
        sum( cooks.distance( m1 ) > 4 / nrow( df2 ) ) -> nb.cook ;
        car::vif( m1 ) -> gvif ;
        car::durbinWatsonTest( m1 ) -> dw ;
        car::ncvTest( m1 ) -> ncv ;
        residuals( m1 ) -> residuals1 ;
        if ( length( residuals1 ) < 5000 ) 
        { shapiro.test( residuals1 ) -> shapiro.res ; }  else
        { list( "p.value" = NA ) -> shapiro.res ; }
        nortest::ad.test( residuals1 ) -> anderson.res ;
        moments::jarque.test( residuals1 ) -> jarque.res ;
        try( car::residualPlots( m1, plot = FALSE ), silent = T ) -> resPlots ;
        
        if ( class( resPlots ) == "try-error" )
        { 
          data.frame( rep( "Not computable", 3), rep( "Not computable", 3) ) -> resPlots ;
          rownames(resPlots) <- c( "1", "2", "Tukey test") ;
          colnames(resPlots) <- c( "1", "Pr(>|Test stat|)" ) ;
        } 
        
        
        ANOVA$`Pr(>F)`[2] -> p.value ;
        paste(  "Analysis of variance of type 3 with no interaction;",
                "White correction",
                White.correct ) -> method ;
        
        
        c( "quanti1quali2",
           colnames( df )[2], 
           colnames( df )[1],
           colnames( df )[3],
           length( df[,1] ),
           length( g.data[,1] ) - length( df[,1] ),
           p.value,
           method,
           "Analysis of variance of type 3 with no interaction",
           White.correct,
           Fstat,
           ANOVA$Df[2],
           ANOVA$Df[4],
           ANOVA$`Pr(>F)`[2],
           "Scheire Ray Hare test with no interaction",
           SHR[,"H"][1],
           SHR[,"Df"][1],
           SHR[,"pvalue"][1],
           eta2,
           f2,
           nb.cook,
           gvif[1],
           gvif[2],
           gvif[5],
           gvif[6],
           dw$p,
           ncv$p,
           shapiro.res$p.value,
           anderson.res$p.value,
           jarque.res$p.value,
           resPlots[ "Tukey test", "Pr(>|Test stat|)"],
           resPlots[ 1, "Pr(>|Test stat|)"],
           resPlots[ 2, "Pr(>|Test stat|)"]
        ) -> 
          output.c ;
        
        c( "quanti1quali2", "var1", "var2", "var3",
           "N", "Missing",
           "p-value", "Method",
           "ANOVA method",
           "White adjustment for heteroscedasticity",
           "ANOVA F statistic",
           "ANOVA Degree of freedom numerator",
           "ANOVA Degree of freedom denominator",
           "ANOVA p-value",
           "Scheire Ray Hare test method",
           "SHR H statistic",
           "SHR degree of freedom",
           "SHR p-value",
           "Partial eta-squared",
           "Cohen f-squared of var2 on R-squared",
           "Number of observations with a cook distance above cut-off",
           "Generalized Variance-Inflation Factor Var2",
           "Generalized Variance-Inflation Factor Var3",
           "Generalized Variance-Inflation Factor^[1/(2*df)] Var2",
           "Generalized Variance-Inflation Factor^[1/(2*df)] Var3",
           "Durbin-Watson Test for Autocorrelated Errors p-value",
           "Score Test for Non-Constant Error Variance p-value",
           "Shapiro-Wilk normality test on residuals p-value",
           "Jarque-Bera normality test on residuals p-value",
           "Anderson-Darling normality test on residuals p-value",
           "Tukey's test for nonadditivity p-value",
           "Curvature Test p-value for Var2",
           "Curvature Test p-value for Var3"
        ) -> 
          names( output.c ) ;
        
        if ( !is.null( pvalue.round ) ) 
        {  
          p.round( as.numeric( output.c[ which( names( output.c ) == 
                                                  "p-value" ) ] ),
                   digits = pvalue.round ) ->
            output.c[ which( names( output.c ) == "p-value" ) ] ;
          
          p.round( as.numeric( output.c[ which( names( output.c ) == 
                                                  "ANOVA p-value" ) ] ),
                   digits = pvalue.round ) ->
            output.c[ which( names( output.c ) == "ANOVA p-value" ) ] ;
          
          p.round( as.numeric( output.c[ which( names( output.c ) == 
                                                  "SHR p-value" ) ] ),
                   digits = pvalue.round ) ->
            output.c[ which( names( output.c ) == "SHR p-value" ) ] ;
          
          p.round( as.numeric( output.c[ which( names( output.c ) == 
                                                  "Durbin-Watson Test for Autocorrelated Errors p-value" ) ] ),
                   digits = pvalue.round ) ->
            output.c[ which( names( output.c ) == "Durbin-Watson Test for Autocorrelated Errors p-value" ) ] ;
          
          p.round( as.numeric( output.c[ which( names( output.c ) == 
                                                  "Score Test for Non-Constant Error Variance p-value" ) ] ),
                   digits = pvalue.round ) ->
            output.c[ which( names( output.c ) == "Score Test for Non-Constant Error Variance p-value" ) ] ;
          
          p.round( as.numeric( output.c[ which( names( output.c ) == 
                                                  "Shapiro-Wilk normality test on residuals p-value" ) ] ),
                   digits = pvalue.round ) ->
            output.c[ which( names( output.c ) == "Shapiro-Wilk normality test on residuals p-value" ) ] ;
          
          p.round( as.numeric( output.c[ which( names( output.c ) == 
                                                  "Jarque-Bera normality test on residuals p-value" ) ] ),
                   digits = pvalue.round ) ->
            output.c[ which( names( output.c ) == "Jarque-Bera normality test on residuals p-value" ) ] ;
          
          p.round( as.numeric( output.c[ which( names( output.c ) == 
                                                  "Anderson-Darling normality test on residuals p-value" ) ] ),
                   digits = pvalue.round ) ->
            output.c[ which( names( output.c ) == "Anderson-Darling normality test on residuals p-value" ) ] ;
          
          p.round( as.numeric( output.c[ which( names( output.c ) == 
                                                  "Tukey's test for nonadditivity p-value" ) ] ),
                   digits = pvalue.round ) ->
            output.c[ which( names( output.c ) == "Tukey's test for nonadditivity p-value" ) ] ;
          
          p.round( as.numeric( output.c[ which( names( output.c ) == 
                                                  "Curvature Test p-value for Var2" ) ] ),
                   digits = pvalue.round ) ->
            output.c[ which( names( output.c ) == "Curvature Test p-value for Var2" ) ] ;
          
          p.round( as.numeric( output.c[ which( names( output.c ) == 
                                                  "Curvature Test p-value for Var3" ) ] ),
                   digits = pvalue.round ) ->
            output.c[ which( names( output.c ) == "Curvature Test p-value for Var3" ) ] ;
          
        }
        
        if ( !is.null( round ) ) 
        { 
          round( as.numeric( output.c[ which( names( output.c ) == 
                                                "ANOVA F statistic" ) ] ),
                 digits = round ) ->
            output.c[ which( names( output.c ) == "ANOVA F statistic" ) ] ;
          
          round( as.numeric( output.c[ which( names( output.c ) == 
                                                "SHR H statistic" ) ] ),
                 digits = round ) ->
            output.c[ which( names( output.c ) == "SHR H statistic" ) ] ;
          
          round( as.numeric( output.c[ which( names( output.c ) == 
                                                "Partial eta-squared" ) ] ),
                 digits = round ) ->
            output.c[ which( names( output.c ) == "Partial eta-squared" ) ] ;
          
          round( as.numeric( output.c[ which( names( output.c ) == 
                                                "Cohen f-squared of var2 on R-squared" ) ] ),
                 digits = round ) ->
            output.c[ which( names( output.c ) == "Cohen f-squared of var2 on R-squared" ) ] ;
          
          round( as.numeric( output.c[ which( names( output.c ) == 
                                                "Generalized Variance-Inflation Factor Var2" ) ] ),
                 digits = round ) ->
            output.c[ which( names( output.c ) == "Generalized Variance-Inflation Factor Var2" ) ] ;
          
          round( as.numeric( output.c[ which( names( output.c ) == 
                                                "Generalized Variance-Inflation Factor Var3" ) ] ),
                 digits = round ) ->
            output.c[ which( names( output.c ) == "Generalized Variance-Inflation Factor Var3" ) ] ;
          
          round( as.numeric( output.c[ which( names( output.c ) == 
                                                "Generalized Variance-Inflation Factor^[1/(2*df)] Var2" ) ] ),
                 digits = round ) ->
            output.c[ which( names( output.c ) == "Generalized Variance-Inflation Factor^[1/(2*df)] Var2" ) ] ;
          
          round( as.numeric( output.c[ which( names( output.c ) == 
                                                "Generalized Variance-Inflation Factor^[1/(2*df)] Var3" ) ] ),
                 digits = round ) ->
            output.c[ which( names( output.c ) == "Generalized Variance-Inflation Factor^[1/(2*df)] Var3" ) ] ;
          
        } 
      }
      
    }
    
    # No test possible
    if ( is.null( output.c ) )
    {
      c( "other", 
         colnames( df )[1], 
         colnames( df )[2], 
         colnames( df )[3], 
         "Tests are not possible" ) -> 
        output.c ;
    }
    
    return( output.c ) ;
  }
  
  # activate packages
  download.packages( "furrr", "moments", "nortest", "coin",
                     "car", "nnet" ) ;
  
  # Merge tables 
  merge( x, y, by = by ) -> g.data ;
  
  merge( g.data, z, by = by ) -> g.data ;
  
  # Job
  
  #pbmc
  furrr::future_map( 
                1:dim(x)[2],
                     fun.a,
                     x = x,
                     y = y,
                     g.data = g.data,
                     na.rm = na.rm, 
                     White.correct = White.correct,
                     Continuity.correct = Continuity.correct, 
                     pvalue.round = pvalue.round, 
                     round = round,
                     nsim = nsim,
                     .options = furrr::furrr_options( seed = T ), .progress = T 
  ) |>
    rbind.force(  empty = "" )  ->
    output ;
  
  # Naming
  rbind.force( c( "quali3", "var1/DV", "var2/IV", "var3/adjustment",
                  "N", "Missing",
                  "p-value", "Method",
                  "Woolf method",
                  "Woolf Chi-squared",
                  "Woolf degree of freedom",
                  "Woolf p-value",
                  "Cochran-Mantel-Haenszel method",
                  "Continuity correction",
                  "CHM M-squared",
                  "CMH degree of freedom",
                  "CMH p-value",
                  "CMH Monte Carlo simulation method",
                  "CMH Monte Carlo distribution",
                  "CMH Monte Carlo number of simulations",
                  "CMH Monte Carlo M-squared",
                  "CMH Monte Carlo p-value",
                  "ANODE method",
                  "ANODE chi-squared",
                  "ANODE degree of freedom",
                  "ANODE p-value",
                  "Mean Cramer's V",
                  "Common odds ratio",
                  "Cohen f-squared of var2 on Cox and Snell Pseudo R-squared",
                  "Number of observations with a cook distance above cut-off",
                  "Generalized Variance-Inflation Factor Var2",
                  "Generalized Variance-Inflation Factor Var3",
                  "Generalized Variance-Inflation Factor^[1/(2*df)] Var2",
                  "Generalized Variance-Inflation Factor^[1/(2*df)] Var3",
                  "Durbin-Watson Test for Autocorrelated Errors p-value",
                  "Dispersion" ),
               output[ output[,1] == "quali3", ],
               c( "quanti3", "var1", "var2", "var3",
                  "N", "Missing",
                  "p-value", "Method",
                  "var1 Shapiro p-value",
                  "var1 Anderson-Darling p-value",
                  "var1 Jarque-Bera p-value",
                  "var2 Shapiro p-value",
                  "var2 Anderson-Darling p-value",
                  "var2 Jarque-Bera p-value",
                  "var1 & var2 normal",
                  "Pearson method for partial correlation",
                  "T ratio",
                  "Degree of freeedom",
                  "Pearson p-value",
                  "Spearman method for partial correlation",
                  "Spearman T statistic",
                  "Degree of freeedom",
                  "Spearman p-value",
                  "ANOVA method",
                  "White adjustment for heteroscedasticity",
                  "ANOVA F statistic",
                  "ANOVA Degree of freedom numerator",
                  "ANOVA Degree of freedom denominator",
                  "ANOVA p-value",
                  "Pearson r correlation coefficient",
                  "R-squared coefficient of determinationt",
                  "Spearman rho correlation coefficient",
                  "Partial eta-squared",
                  "Cohen f-squared of var2 on R-squared",
                  "Number of observations with a cook distance above cut-off",
                  "Variance-Inflation Factor Var2",
                  "Variance-Inflation Factor Var3",
                  "Durbin-Watson Test for Autocorrelated Errors p-value",
                  "Score Test for Non-Constant Error Variance p-value",
                  "Shapiro-Wilk normality test on residuals p-value",
                  "Jarque-Bera normality test on residuals p-value",
                  "Anderson-Darling normality test on residuals p-value",
                  "Tukey's test for nonadditivity p-value",
                  "Curvature Test p-value for Var2",
                  "Curvature Test p-value for Var3" ),
               output[ output[,1] == "quanti3", ],
               c( "quanti2quali1", "var1/DV", "var2/IV", "var3/adjustment",
                  "N", "Missing",
                  "p-value", "Method",
                  "ANOVA method",
                  "White adjustment for heteroscedasticity",
                  "ANOVA F statistic",
                  "ANOVA Degree of freedom numerator",
                  "ANOVA Degree of freedom denominator",
                  "ANOVA p-value",
                  "Partial eta-squared",
                  "Cohen f-squared of var2 on R-squared",
                  "Number of observations with a cook distance above cut-off",
                  "Generalized Variance-Inflation Factor Var2",
                  "Generalized Variance-Inflation Factor Var3",
                  "Generalized Variance-Inflation Factor^[1/(2*df)] Var2",
                  "Generalized Variance-Inflation Factor^[1/(2*df)] Var3",
                  "Durbin-Watson Test for Autocorrelated Errors p-value",
                  "Score Test for Non-Constant Error Variance p-value",
                  "Shapiro-Wilk normality test on residuals p-value",
                  "Jarque-Bera normality test on residuals p-value",
                  "Anderson-Darling normality test on residuals p-value",
                  "Tukey's test for non-additivity p-value",
                  "Curvature Test p-value for Var2",
                  "Curvature Test p-value for Var3" ),
               output[ output[,1] == "quanti2quali1", ],
               c( "quali2quanti1", "var1/DV", "var2/IV", "var3/adjustment",
                  "N", "Missing",
                  "p-value", "Method",
                  "ANODE method",
                  "ANODE Chi-squared",
                  "ANODE degree of freedom",
                  "ANODE p-value",
                  "Cohen f-squared of var2 on Cox and Snell Pseudo R-squared",
                  "Number of observations with a cook distance above cut-off",
                  "Generalized Variance-Inflation Factor Var2",
                  "Generalized Variance-Inflation Factor Var3",
                  "Generalized Variance-Inflation Factor^[1/(2*df)] Var2",
                  "Generalized Variance-Inflation Factor^[1/(2*df)] Var3",
                  "Durbin-Watson Test for Autocorrelated Errors p-value",
                  "Dispersion" ), 
               output[ output[,1] == "quali2quanti1", ],
               c( "quanti1quali2", "var1/DV", "var2/IV", "var3/adjustment",
                  "N", "Missing",
                  "p-value", "Method",
                  "ANOVA method",
                  "White adjustment for heteroscedasticity",
                  "ANOVA F statistic",
                  "ANOVA Degree of freedom numerator",
                  "ANOVA Degree of freedom denominator",
                  "ANOVA p-value",
                  "Scheire Ray Hare test method",
                  "SHR H statistic",
                  "SHR degree of freedom",
                  "SHR p-value",
                  "Partial eta-squared",
                  "Cohen f-squared of var2 on R-squared",
                  "Number of observations with a cook distance above cut-off",
                  "Generalized Variance-Inflation Factor Var2",
                  "Generalized Variance-Inflation Factor Var3",
                  "Generalized Variance-Inflation Factor^[1/(2*df)] Var2",
                  "Generalized Variance-Inflation Factor^[1/(2*df)] Var3",
                  "Durbin-Watson Test for Autocorrelated Errors p-value",
                  "Score Test for Non-Constant Error Variance p-value",
                  "Shapiro-Wilk normality test on residuals p-value",
                  "Jarque-Bera normality test on residuals p-value",
                  "Anderson-Darling normality test on residuals p-value",
                  "Tukey's test for non-additivity p-value" ),  
               output[ output[,1] == "quanti1quali2", ],
               c( "other", "var1", "var2", "var3", rep( "-", 5 ) ),
               c( "other",
                  "No test if:", 
                  "just 1 level for factor;",
                  "less than 3 observation for each cell in contingency tab",
                  "less than 5 observations by level for 1 numeric & 1 factor;",
                  "less than 8 observations for 2 numerics;", "Less than 4 differents values for numerics;" ),
               output[ output[,1] == "other", ],
               output[ output[,1] == "identical", ],
               empty = ""
  ) ->
    output ; 
  
  
  if ( dim(  output[ output[,1] == "quali3", ] )[1] == 1 )
  { output[ output[,1] != "quali3", ] -> output ; }
  
  if ( dim(  output[ output[,1] == "quanti3", ] )[1] == 1 )
  { output[ output[,1] != "quanti3", ] -> output ; }
  
  if ( dim(  output[ output[,1] == "quanti2quali1", ] )[1] == 1 )
  { output[ output[,1] != "quanti2quali1", ] -> output ; }
  
  if ( dim(  output[ output[,1] == "quali2quanti1", ] )[1] == 1 )
  { output[ output[,1] != "quali2quanti1", ] -> output ; }
  
  if ( dim(  output[ output[,1] == "quanti1quali2", ] )[1] == 1 )
  { output[ output[,1] != "quanti1quali2", ] -> output ; }
  
  if ( dim(  output[ output[,1] == "other", ] )[1] == 2 )
  { output[ output[,1] != "other", ] -> output ; }
  
  if ( remove.by  )
  { output[ output[,2] != by, ] -> output ; }
  
  if ( remove.x.y.z )
  { 
    gsub( ".x", "", output[,2] ) -> output[,2] ; 
    gsub( ".y", "", output[,2] ) -> output[,2] ; 
    gsub( ".x", "", output[,3] ) -> output[,3] ;
    gsub( ".y", "", output[,3] ) -> output[,3] ;
    gsub( ".z", "", output[,4] ) -> output[,4] ;
  }
  
  c( "Class", "var1/DV", "var2/IV", "var3/adjustment",
     paste( rep( "col", 37), 5:dim( output )[2], sep = "" ) ) -> 
    colnames( output ) ;
  
  # end parallel
  future::plan("sequential")
  
  return( output )
}

# 1.4.7 Function to perform interaction testing
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Interactions.Test <- function( dv, iv, data1, family1, ncores = NULL )
{
  
  # parallel
  if ( !is.null( ncores ) ) { future::plan( "multisession",  workers = ncores ) }
  
  # internal functions
  Formula.Generator <- function( outcome, terms )
  {
    # check inputs 
    if ( !is.character(outcome) ) { stop( "outcome is not a string.") }
    if ( !is.character(terms) ) { stop( "terms is not a string.") }
    
    # makre formula 
    paste0( terms[1:(length(terms) - 1)], " + ") -> tmp1 ;
    
    "" -> tmp2 ;
    for (a in 1:length(tmp1))
    {
      paste0( tmp2, tmp1[a]) ->
        tmp2 ;
    }
    
    paste0( outcome,
            " ~ ",
            tmp2,
            terms[length(terms)]
    ) ->
      output ;
    
    return( as.formula(output) ) 
  }
  
  download.packages <- function( PackagesNames, ... )
  {
    # Get a vector with packages names 
    packages1 <- c( PackagesNames, ... ) ;
    
    # Install packages
    for (a in 1:length( packages1 ) )
    {
      try( find.package( packages1[a]), silent = TRUE ) -> test ;
      
      if ( class( test ) == "try-error" )
      { print( packages1[a] ) ; 
        install.packages(  packages1[a] ) ;
      } 
    }
  } ;
  
  rbind.force <- function( data, ..., keep.col = FALSE, empty = NA ) 
  {
    # Unify data
    list( data, ... ) -> input ;
    
    # include list elements
    repeat 
    {
      if (  !any( unlist( lapply( input, class ) ) == "list" ) ) { break }  
      
      which( unlist( lapply( input, class ) ) == "list" )[1] -> a ;
      input[[a]] -> tmp ;
      input[[a]] <- NA ;
      c( input[1:a],  tmp, input[ (a + 1):length( input ) ] ) -> 
        input ;
    }
    
    input[ !is.na( input ) ] ->
      input ;
    
    # delete NULL data and transformt vector in data.frame
    for ( a in 1:length( input ) )
    {
      if ( is.null( dim( input[[a]] ) ) )
      {
        if ( is.null( input[[a]] ) )
        {
          input[[a]] <- NA ;
        } else
        {
          data.frame( matrix( input[[a]], nrow = 1 ),
                      stringsAsFactors = FALSE ) -> input[[a]] ; 
        }
      }
      
      if ( all( dim( input[[a]] ) == 0 ) )
      {
        input[[a]] <- NA ;
      }
    }
    
    input[ !is.na( input ) ] ->
      input ;
    
    # test data class
    if ( !all( unlist( lapply( input, is.data.frame ) ) |
               unlist( lapply( input, is.matrix ) ) |
               unlist( lapply( input, is.vector ) ) ) )
    { stop( "Some argument are not data.frame, neither vector" ) ;
      ; } ;
    
    # Set primer
    input[[1]] -> output ; 
    
    # job in case we keep columns 
    if ( keep.col & length( input ) >1 )
    {
      for ( a in 2:length( input ) )
      { 
        output -> x ;
        input[[a]] -> y ; 
        
        for (a in 1:dim(x)[2]) { x[,a] <- as.character(x[,a])}
        for (a in 1:dim(y)[2]) { y[,a] <- as.character(y[,a])}
        
        x.diff <- setdiff(colnames(x), colnames(y))
        y.diff <- setdiff(colnames(y), colnames(x))
        
        if( dim(x)[1] > 0 ) { x[, c(as.character(y.diff))] <- empty ; }
        if( dim(y)[1] > 0 ) { y[, c(as.character(x.diff))] <- empty ; }
        
        rbind(x, y) -> output ;
      } 
    }
    
    # job in case we do not keep columns
    if ( !keep.col & length( input ) >1 )
    {
      for ( a in 2:length( input ) )
      { 
        output -> x ;
        input[[a]] -> y ; 
        
        colnames(x) <- paste( "X",
                              1:dim( x )[2], 
                              sep = "" ) ;
        colnames(y) <- paste( "X",
                              1:dim( y )[2], 
                              sep = "" ) ;
        
        for (a in 1:dim(x)[2]) { x[,a] <- as.character(x[,a])}
        for (a in 1:dim(y)[2]) { y[,a] <- as.character(y[,a])}
        
        x.diff <- setdiff(colnames(x), colnames(y))
        y.diff <- setdiff(colnames(y), colnames(x))
        
        if( dim(x)[1] > 0 ) { x[, c(as.character(y.diff))] <- empty ; }
        if( dim(y)[1] > 0 ) { y[, c(as.character(x.diff))] <- empty ; }
        
        rbind(x, y) -> output ;
      } 
    }
    
    return( output ) ;
  } 
  
  fun.a <- function(a)
  {
    lapply( (a+1):length(iv),
                fun.b, a = a) 
  }
  
  fun.b <- function(b, a)
  {
    # terms definition
    term1 <- iv[a] ;
    term2 <- iv[b] ;
    interaction1 <- paste0( term1, ":", term2 );
    formula0 <- Formula.Generator( dv, c( term1, term2 ) );
    formula1 <- Formula.Generator( dv, c( term1, term2, interaction1 ) );
    
    # run regression
    model0 <- glm( formula0, data = data1, family = family1 ) ;
    model1 <- glm( formula1, data = data1, family = family1 ) ;
    
    # run model comparison
    cbind( anova( model0, model1, test = "LRT"  ) )[2,] |>
      (function(x) c( interaction1, x) )() |>
      unlist() ->
      outcome.b ; 
    
    return(outcome.b)
  }
  
  # packages
  download.packages( "furrr", "purrr" )
  
  # run 
  furrr::future_map(
    1:(length(iv) - 1 ),
    fun.a,
    .options = furrr::furrr_options(seed = TRUE), .progress = T 
  ) |>
    rbind.force() ->
    outcome ;
  
  # outcome
  colnames( outcome ) <- c( "Name", "Residuals", "Residual Deviance", "DF", "Deviance", "p" ) ;
  
  # end parallel
  future::plan("sequential")
  
  return( outcome )
}

# 1.5 Other special functions
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 1.5.1 rtime
#~~~~~~~~~~~~
rtime <- function( from, to, format = "%d/%m/%Y" )
{
  as.Date( from, format = format ) -> D1 ;
  as.Date( to, format = format ) -> D2 ;
  
  as.Date( 0:( D2 - D1), 
           origin = from, 
           format = "%d/%m/%Y" )
}

# 1.5.2 Function to perform multiple regressions cluster robust
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Multiple.Regressions.ClusterRobust <- function( 
    data,
    cluster.ID = "",
    na.omit = TRUE,
    outcomes, 
    families,
    changing.predictors,
    fixed.predictors = "",
    FULL = TRUE,
    ANOVA.ANODE = TRUE,
    HMF.test = TRUE,
    conf.level = 0.95,
    pvalue.round = 3,
    round = 2,
    PLOT = FALSE, 
    ExportName = paste( getwd(),
                        "/",
                        sep = ""), 
    parallel.outcomes = TRUE,
    ncores = NULL
)
{
  # input quality controls 
  if ( !is.data.frame( data ) ) { stop ( "data is not of dataframe type" ) } ;
  if ( any( is.na( data ) ) ) { warning( "data countains NA" ) } ;
  if ( tibble::is_tibble( data ) ) { data.frame( data ) -> data ; }
  if ( cluster.ID == "" ) { warning( "cluster var must be defined" ) } ;
  if ( !is.logical( na.omit ) ) { stop( "na.omit is not a logical" ) } ;
  if ( !is.list( outcomes ) ) { stop( "outcomes is not a list" ) } ;
  if ( !is.character( unlist( outcomes ) ) ) { stop( "outcomes doesn't countain character" ) } ;
  if ( !is.character( families ) ) { stop( "families is not a vector of character type" ) } ;
  if ( !all( families %in% c( "multinomial", "gaussian", "binomial", "poisson", "quasibinomial", "quasipoisson" ) ) ) 
  { stop( "families contains a non supported distribution" ) } ;
  if ( !is.list( changing.predictors ) ) { stop( "changing.predictors is not a list" ) } ;
  if ( !is.character( unlist( changing.predictors ) ) ) { stop( "changing.predictors doesn't countain character" ) } ;
  if ( !is.character( fixed.predictors ) ) { stop( "fixed.predictors is not a vector of character type" ) } ;
  if ( !is.logical( FULL ) ) { stop( "FULL is not a logical" ) } ;
  if ( !is.logical( ANOVA.ANODE ) ) { stop( "ANOVA.ANODE is not a logical" ) } ;
  if ( !is.logical( HMF.test ) ) { stop( "HMF.test is not a logical" ) } ;
  if ( !is.numeric( conf.level ) ) { stop( "conf.level is not numeric" ) } ;
  if ( !( is.numeric( pvalue.round ) | 
          is.null( pvalue.round ) ) ) { stop( "pvalue.round is neither numeric, neither NULL" );    } ;
  if ( !( is.numeric( round ) | 
          is.null( round ) ) ) { stop( "round is neither numeric, neither NULL" );    } ;
  if ( !is.logical( PLOT ) ) { stop( "PLOT is not a logical" ) } ;
  if ( !is.character( ExportName ) ) { stop( "ExportName is not a vector of character type" ) } ;
  if ( !is.logical( parallel.outcomes ) ) { stop( "parallel.outcomes is not a logical" ) } ;
  if ( !is.null(ncores) & !is.numeric(ncores) ) { stop( "ncores is not null nor numeric" ) }
  
  # Message
  print( "Clustered sandwich estimators are used to adjust inference when errors are correlated within (but not between) clusters. \n Cameron AC, Gelbach JB, Miller DL (2011). “Robust Inference with Multiway Clustering”, Journal of Business & Ecomomic Statistics, 29(2), 238–249. doi:10.1198/jbes.2010.07136 \n HC1 for lm objects and HC0 otherwise ; HC0: original White-corrected coefficient covariance matrix ; White, H. (1980) A heteroskedastic consistent covariance matrix estimator and a direct test of heteroskedasticity. Econometrica 48, 817–838. ; HC1: Long, J. S. and Ervin, L. H. (2000) Using heteroscedasity consistent standard errors in the linear regression model. The American Statistician 54, 217–224. ")
  # parallel
  if ( !is.null( ncores ) ) { future::plan( "multisession",  workers = ncores ) }
  
  # Domestic functions
  download.packages <- function( PackagesNames, ... )
  {
    # Get a vector with packages names 
    packages1 <- c( PackagesNames, ... ) ;
    
    # Install packages
    for (a in 1:length( packages1 ) )
    {
      try( find.package( packages1[a]), silent = TRUE ) -> test ;
      
      if ( class( test ) == "try-error" )
      { print( packages1[a] ) ; 
        install.packages(  packages1[a] ) ;
      } 
    }
  } ;
  
  rbind.force <- function( data, ..., keep.col = FALSE, empty = NA ) 
  {
    # Unify data
    list( data, ... ) -> input ;
    
    # include list elements
    repeat 
    {
      if (  !any( unlist( lapply( input, class ) ) == "list" ) ) { break }  
      
      which( unlist( lapply( input, class ) ) == "list" )[1] -> a ;
      input[[a]] -> tmp ;
      input[[a]] <- NA ;
      c( input[1:a],  tmp, input[ (a + 1):length( input ) ] ) -> 
        input ;
    }
    
    input[ !is.na( input ) ] ->
      input ;
    
    # delete NULL data and transformt vector in data.frame
    for ( a in 1:length( input ) )
    {
      if ( is.null( dim( input[[a]] ) ) )
      {
        if ( is.null( input[[a]] ) )
        {
          input[[a]] <- NA ;
        } else
        {
          data.frame( matrix( input[[a]], nrow = 1 ),
                      stringsAsFactors = FALSE ) -> input[[a]] ; 
        }
      }
      
      if ( all( dim( input[[a]] ) == 0 ) )
      {
        input[[a]] <- NA ;
      }
    }
    
    input[ !is.na( input ) ] ->
      input ;
    
    # test data class
    if ( !all( unlist( lapply( input, is.data.frame ) ) |
               unlist( lapply( input, is.matrix ) ) |
               unlist( lapply( input, is.vector ) ) ) )
    { stop( "Some argument are not data.frame, neither vector" ) ;
      ; } ;
    
    # Set primer
    input[[1]] -> output ; 
    
    # job in case we keep columns 
    if ( keep.col & length( input ) >1 )
    {
      for ( a in 2:length( input ) )
      { 
        output -> x ;
        input[[a]] -> y ; 
        
        for (a in 1:dim(x)[2]) { x[,a] <- as.character(x[,a])}
        for (a in 1:dim(y)[2]) { y[,a] <- as.character(y[,a])}
        
        x.diff <- setdiff(colnames(x), colnames(y))
        y.diff <- setdiff(colnames(y), colnames(x))
        
        if( dim(x)[1] > 0 ) { x[, c(as.character(y.diff))] <- empty ; }
        if( dim(y)[1] > 0 ) { y[, c(as.character(x.diff))] <- empty ; }
        
        rbind(x, y) -> output ;
      } 
    }
    
    # job in case we do not keep columns
    if ( !keep.col & length( input ) >1 )
    {
      for ( a in 2:length( input ) )
      { 
        output -> x ;
        input[[a]] -> y ; 
        
        colnames(x) <- paste( "X",
                              1:dim( x )[2], 
                              sep = "" ) ;
        colnames(y) <- paste( "X",
                              1:dim( y )[2], 
                              sep = "" ) ;
        
        for (a in 1:dim(x)[2]) { x[,a] <- as.character(x[,a])}
        for (a in 1:dim(y)[2]) { y[,a] <- as.character(y[,a])}
        
        x.diff <- setdiff(colnames(x), colnames(y))
        y.diff <- setdiff(colnames(y), colnames(x))
        
        if( dim(x)[1] > 0 ) { x[, c(as.character(y.diff))] <- empty ; }
        if( dim(y)[1] > 0 ) { y[, c(as.character(x.diff))] <- empty ; }
        
        rbind(x, y) -> output ;
      } 
    }
    
    return( output ) ;
  } 
  
  cbind.force <- function( data, ... , keep.row = FALSE, empty = NA ) 
  {
    # Unify data
    list( data, ... ) -> input ;
    
    # include list elements
    repeat 
    {
      if (  !any( unlist( lapply( input, class ) ) == "list" ) ) { break }  
      
      which( unlist( lapply( input, class ) ) == "list" )[1] -> a ;
      input[[a]] -> tmp ;
      input[[a]] <- NA ;
      c( input[1:a],  tmp, input[ (a + 1):length( input ) ] ) -> 
        input ;
    }
    
    input[ !is.na( input ) ] ->
      input ;
    
    # delete NULL data and transform vector in data.frame
    for ( a in 1:length( input ) )
    {
      if ( is.null( dim( input[[a]] ) ) )
      {
        if ( is.null( input[[a]] ) )
        {
          input[[a]] <- NA ;
        } else
        {
          data.frame( input[[a]],
                      stringsAsFactors = FALSE ) -> input[[a]] ; 
          "vector" -> colnames(  input[[a]] ) ;
        }
      }
      
      if ( all( dim( input[[a]] ) == 0 ) )
      {
        input[[a]] <- NA ;
      }
    }
    
    input[ !is.na( input ) ] ->
      input ;
    
    # test data class
    if ( !all( unlist( lapply( input, is.data.frame ) ) |
               unlist( lapply( input, is.matrix ) ) |
               unlist( lapply( input, is.vector ) ) ) )
    { stop( "Some argument are not data.frame, neither vector" ) ;
      ; } ;
    
    # Set primer
    input[[1]] -> output ; 
    
    # job in case we keep columns 
    if ( keep.row & length( input ) > 1 )
    {
      for ( a in 2:length( input ) )
      { 
        output -> x ;
        input[[a]] -> y ; 
        
        for (a in 1:dim(x)[2]) { x[,a] <- as.character(x[,a])}
        for (a in 1:dim(y)[2]) { y[,a] <- as.character(y[,a])}
        
        x.diff <- setdiff(rownames(x), rownames(y))
        y.diff <- setdiff(rownames(y), rownames(x))
        
        if( dim(x)[2] > 0 ) { x[ c(as.character(y.diff)), ] <- empty ; }
        if( dim(y)[2] > 0 ) { y[ c(as.character(x.diff)), ] <- empty ; }
        
        cbind(x, y) -> output ;
      } 
    }
    
    # job in case we do not keep columns
    if ( !keep.row & length( input ) > 1 )
    {
      for ( a in 2:length( input ) )
      { 
        output -> x ;
        input[[a]] -> y ; 
        
        if ( dim( x )[1] > 0 ) 
        {
          rownames(x) <- paste( "X",
                                1:dim( x )[1], 
                                sep = "" ) ;
        }
        
        if ( dim( y )[1] > 0 ) 
        {
          rownames(y) <- paste( "X",
                                1:dim( y )[1], 
                                sep = "" ) ;
        }
        
        
        
        for (a in 1:dim(x)[2]) { x[,a] <- as.character(x[,a])}
        for (a in 1:dim(y)[2]) { y[,a] <- as.character(y[,a])}
        
        x.diff <- setdiff(rownames(x), rownames(y))
        y.diff <- setdiff(rownames(y), rownames(x))
        
        if( dim(x)[2] > 0 ) { x[ c(as.character(y.diff)), ] <- empty ; }
        if( dim(y)[2] > 0 ) { y[ c(as.character(x.diff)), ] <- empty ; }
        
        cbind(x, y) -> output ;
      } 
    }
    
    return( output ) ;
  } ;
  
  String.Contatener <- function( vector, separator )
  {   
    # exclude NA
    na.omit( vector ) -> vector ;
    
    # selection of length for loop
    if ( length( vector ) >= 2) 
    { 
      # stock fisrt element
      tmp.val1 <- vector[1] ;
      
      # loop to concatenate the nect elements
      for ( a in 2:length( vector ) ) 
      { 
        tmp.val1 <- paste( tmp.val1, vector[a], sep = separator ) ; 
      } ;
    } 
    else
    {
      tmp.val1 <- vector ;
    } ;
    
    return( tmp.val1 ) ;
  } ;
  
  p.round <- function( data, digits = 3 )
  {
    if (digits == 1)
    { "" -> tmp1 ; } else 
    { rep( "0", digits - 1 ) -> tmp1 ; }
    
    "0." -> tmp2 ;
    for( a in 1:length(tmp1) )
    {
      paste( tmp2, tmp1[a], sep = "" ) -> tmp2 ;
    }
    
    paste( tmp2, "1", sep = "" ) -> pval ;
    
    for ( a in 1:length(data) )
    {
      if ( !is.na( data[a] ) )
      {
        if ( data[a] >= as.numeric( pval ) )
        {
          round( data[a], digits = digits ) -> data[a] ;
        }
      }
    }
    
    data[ data < as.numeric( pval ) ] <- paste( "< ", pval, sep = "" ) ;
    
    return( data ) ;
  }
  
  IFELSE <- function( condition, true, false )
  {
    if (condition)
    {
      return( true )
    } else
    {
      return( false )
    }
  }
  
  cohen.f2 <- function( model, pseudo.R2 = FALSE, family )
  {
    attr(terms(model), 'term.labels') -> terms1 ; 
    as.character( terms(model) )[2] -> outcome ;
    
    NULL -> f2 ;
    
    if ( !pseudo.R2 )
    {
      for ( a in 1:length(terms1) )
      {
        if ( length(terms1) == 1 )
        { 
          stats::update( model, reformulate( "1" ) ) -> model.bis ;
        } else
        {
          stats::update( model, reformulate( terms1[-a] ) ) -> model.bis ; 
        }
        
        c( f2, 
           (summary( model )$r.squared -  summary( model.bis  )$r.squared ) / (1 - summary( model )$r.squared) ) -> 
          f2 ;
      }
    }  
    
    if ( pseudo.R2 & any( class( model ) == "glm" ) )
    {
      for ( a in 1:length(terms1) )
      {
        if ( length(terms1) == 1 )
        { 
          stats::update( model, reformulate( "1", outcome ), family = family )-> model.bis ;
        } else
        {
          stats::update( model, reformulate( terms1[-a], outcome ), family = family ) -> model.bis ; 
        }
        
        c( f2, 
           (MuMIn::r.squaredLR( model, stats::update( model, reformulate( "1", outcome ), family = family  ) )[1] -  MuMIn::r.squaredLR( model.bis, stats::update( model, reformulate( "1" ), family = family ) )[1]  ) / (1 -  MuMIn::r.squaredLR( model, stats::update( model, reformulate( "1", outcome ), family = family ) )[1] )  ) -> 
          f2 ;
      }
    }
    
    if ( pseudo.R2 & all( class( model ) != "glm" ) )
    {
      for ( a in 1:length(terms1) )
      {
        if ( length(terms1) == 1 )
        { 
          stats::update( model, reformulate( "1", outcome ) )-> model.bis ;
        } else
        {
          stats::update( model, reformulate( terms1[-a], outcome ) ) -> model.bis ; 
        }
        
        c( f2, 
           (MuMIn::r.squaredLR( model, stats::update( model, reformulate( "1", outcome )  ) )[1] -  MuMIn::r.squaredLR( model.bis, stats::update( model, reformulate( "1" ) ) )[1]  ) / (1 -  MuMIn::r.squaredLR( model, stats::update( model, reformulate( "1", outcome ) ) )[1] )  ) -> 
          f2 ;
      }
    }
    
    terms1 -> names( f2 ) ;
    
    return( f2 )
  }
  
  Systematic.FP <- function( output, predictors, family, data, na.omit )
  {
    if( any( grepl( ":", predictors ) ) )
    {
      predictors[ !grepl( ":", predictors ) ] -> predictors ; 
    }
    
    require( mfp )
    data |>
      base::subset( select = predictors ) |>
      dplyr::select_if( is.numeric ) |>
      colnames() -> 
      pred.num ;
    
    c( "Predictors", "df.initial", "select", "alpha", 
       "df.final", "power1", "power2" ) ->
      return1 ;
    
    for ( a in pred.num )
    {
      paste( "fp(",
             a,
             ",df = 4, select = 1, scale = TRUE)") -> 
        fp ;
      
      if ( na.omit == TRUE ) { na.omit( data ) -> data } 
      
      reformulate( c(fp, predictors[ which( predictors != a) ] ), output ) |>
        mfp::mfp( 
          family = family,
          data = data ) -> 
        tmp.mfp ;
      
      tmp.mfp$fptable[a,] |>
        as.matrix() |>
        (function(x) c( a,x) )() |>
        (function(x) rbind( return1, x ) )() ->
        return1 ;
    }
    
    NULL -> rownames(return1) ;
    
    return( return1 )
  }
  
  residuals.polr <- function( model )
  {
    factor( model$model[,1] ) -> multinom.var ;
    
    NULL -> disjonctif.table ;
    
    for ( a in 1:nlevels( multinom.var ) )
    {
      as.character( multinom.var ) -> tmp.var ;
      
      paste( levels(multinom.var)[a], "a", sep = "" ) -> 
        tmp.var[ tmp.var == levels(multinom.var)[a] ] ;
      0 -> tmp.var[ tmp.var != paste( levels(multinom.var)[a], "a", sep = "" ) ] ;
      1 -> tmp.var[ tmp.var == paste( levels(multinom.var)[a], "a", sep = "" ) ] ;
      cbind( disjonctif.table, 
             as.numeric( as.character( tmp.var ) ) ) -> 
        disjonctif.table ;
      
      levels(multinom.var)[a] -> 
        colnames( disjonctif.table )[ ncol( disjonctif.table ) ] ;
    }
    
    disjonctif.table - model$fitted.values -> output ;
    
    return( output )
  }
  
  Normality.Plot.Unique <- function( vector, name )
  {
    par( mfrow = c( 2, 2), oma = c( 0, 0, 2, 0) )
    
    # Clean missing value
    na.omit( vector ) -> vector ;
    as.numeric( vector ) -> vector ;
    
    # plot histogram
    hist( vector, main = "Histogram", xlab = "Variable", col = "blue" ) ;
    round( moments::kurtosis( vector ), digits = 2 ) -> tmp.val1 ;
    round( moments::skewness( vector ), digits = 2 ) -> tmp.val2 ;
    paste( "Kurtosis: ", tmp.val1, " ; ", "Skewness: ", tmp.val2, sep = "" ) -> tmp.name1 ;
    title( sub = tmp.name1 ) ;
    
    # plot density 
    plot( density( vector ), 
          main = "Density plot", xlab = "Variable", col = "blue" ) ;
    curve( dnorm( x, mean( vector ), sd( vector ) ), add = TRUE, col = "red", lwd = 2, lty = 2 ) ;
    abline( v = mean( vector ), col = "blue", lwd = 2, lty = 2) ;
    abs( range( vector )[2] - range( vector )[1] ) / 20 -> legend.distance1 ;
    abs( range( density( vector )$y )[2] - range( density( vector )$y )[1] ) / 20 -> legend.distance2 ;
    text( x = mean( vector ) + legend.distance1, y = legend.distance2, expression( mu ), col = "blue" ) ;
    legend( x = "topright", lty = c( 1, 2 ), col = c( "blue", "red" ), c( "Sample", "Normal" ), cex = 0.6 ) ;
    round( moments::jarque.test( vector )$p.value, digits = 3 ) -> tmp.val1 ;
    if ( tmp.val1 < 0.001 ) { tmp.val1 <- "< 0.001"} ;
    paste( "Jarque-Bera test p value: ", tmp.val1 ) -> tmp.name1 ;
    if ( tmp.val1 == "< 0.001" | tmp.val1 < 0.05 ) 
    { title( sub = tmp.name1, col.sub = "green", font.sub = 2 ) ; }
    else
    { title( sub = tmp.name1 ) ; } ;
    
    # plot ecdf 
    plot( ecdf( vector ), main = "Empirical cumulative distribution plot", xlab = "Variable", 
          ylab = "Density", col = "blue", ylim = c( -0.2, 1.2 ) )
    plot( add = TRUE, ecdf( rnorm( 10000, mean = mean( vector ), sd = sd( vector ) ) ), col = "red" ) ;
    abline( h = 0.5, lty = 2, lwd = 1, col = "grey80" )
    legend( x = "bottomright", lty = c( 1, 1 ),col = c( "blue", "red" ), c( "Sample", "Normal" ), cex = 0.6 ) ;
    round( nortest::ad.test( vector )$p.value, digits = 3 ) -> tmp.val1 ;
    if ( tmp.val1 < 0.001 ) { tmp.val1 <- "< 0.001"} ;
    paste( "Anderson-Darling test p value: ", tmp.val1, sep = "" ) -> tmp.name1 ;
    if ( tmp.val1 == "< 0.001" | tmp.val1 < 0.05 ) 
    { title( sub = tmp.name1, col.sub = "green", font.sub = 2 ) ; }
    else
    { title( sub = tmp.name1 ) ; } ;
    
    # plot qq 
    qqnorm( vector, col = "blue" ) ;
    qqline( vector, col = "red" ) ;
    legend( x = "bottomright", lty = c( 1 ),col = c( "red" ), c( "Henry's line" ), cex = 0.6 ) ;
    if ( length( vector ) > 5000 )
    {
      "Shapiro-Wilk test not performed (N > 5000 )" -> tmp.name1 ;
      title( sub = tmp.name1 ) ;
    } else
    {
      round( shapiro.test( vector )$p.value, digits = 3 ) -> tmp.val1 ;
      if ( tmp.val1 < 0.001 ) { tmp.val1 <- "< 0.001"} ;
      paste( "Shapiro-Wilk test p value: ", tmp.val1, sep = "" ) -> tmp.name1 ;
      if ( tmp.val1 == "< 0.001" | tmp.val1 < 0.05 ) 
      { title( sub = tmp.name1, col.sub = "green", font.sub = 2 ) ; }
      else
      { title( sub = tmp.name1 ) ; } ;
    }
    
    # put title 
    tmp.name2 <- paste( "Noramlity Study of", name, sep = " " ) ;
    mtext( text =  tmp.name2, outer = TRUE, cex = 1.5 ) ;
  }
  
  Formula.Maker <- function( outcome, fixed.effects = "", interactions = "", random.effects = "", 
                             random.interactions = list(""), covariance = TRUE, DeleteTerms = NULL )
  {
    # Cheking inuts
    if ( !all( random.interactions == "" ) )
    {
      if ( length(random.interactions) != length(random.effects) ) 
      { print( "Missing random interactions arguments" ) ;}
    } ;
    
    # Integration of fixed effects
    if ( !all( fixed.effects == "" ) ) 
    { 
      if ( length( which(fixed.effects == "" ) ) > 0 )
      {
        fixed.effects[-which(fixed.effects == "")] -> Predictors ; 
      }
      else
      {
        fixed.effects  -> Predictors ; 
      }    
    }
    else
    { "1" -> Predictors } ;
    
    # Integration of interactions
    if ( all( interactions != "" ) )
    {
      for ( a in 1:length( interactions ) )
      {
        paste( interactions[[a]][1], ":", interactions[[a]][2], sep = "" ) -> tmp.val1
        c( Predictors, tmp.val1 ) -> Predictors ; 
      } ;
    } ;
    
    # Integration of random effects
    if ( all( random.effects != "" ) )
    {
      for ( a in 1:length( random.effects) )
      {
        if ( all( random.interactions == "" ) )
        {
          paste( "(1 | ", random.effects[a], ")", sep = "" ) -> tmp.val1 ;
          c( Predictors, tmp.val1 ) -> Predictors ;
        } ;
      } ;
    } ;
    
    # Integration of random interactions 
    if ( any( random.interactions != "" ) )
    {
      if ( covariance )
      {
        for ( a in 1:length(random.effects) )
        {
          if ( all( random.interactions[[a]] != "1" ) )
          {
            "(1" -> tmp.val1 ;
            for ( b in 1:length( random.interactions[[a]] ) )
            {
              if ( random.interactions[[a]][b] != "" )
              {
                paste( tmp.val1, " + ", random.interactions[[a]][b], sep = "" ) -> tmp.val1 ;
              } ;
            } ;
            paste( tmp.val1, " | ", random.effects[a], ")", sep = "" ) -> tmp.val2 ;
            c( Predictors, tmp.val2 ) -> Predictors ;
          }
          if ( all( random.interactions[[a]] == "1" ) )
          {
            paste( "(1", " | ", random.effects[a], ")", sep = "" ) -> tmp.val2 ;
            c( Predictors, tmp.val2 ) -> Predictors ;
          } ;
        } ;
      } ;
      
      if ( !covariance )
      {
        for ( a in 1:length( random.effects) )
        {
          paste( "(1 | ", random.effects[a], ")", sep = "" ) -> tmp.val1 ;
          c( Predictors, tmp.val1 ) -> Predictors ;
          for ( b in 1:length(random.interactions[[a]]) )
          {
            if ( random.interactions[[a]][b] != "" )
            {
              paste( "(", random.interactions[[a]][b], " || ", random.effects[a], ")", sep = "" ) -> tmp.val1 ;
              c( Predictors, tmp.val1 ) -> Predictors ;
            } ;
          } ;
        } ;
      } ;
    } ;
    
    # Deletion of terms 
    if ( all( !is.null( DeleteTerms ) ) )
    {
      if ( class(DeleteTerms) == "numeric" )
      {
        Predictors[ -DeleteTerms ] -> Predictors ;
      } ;
      if ( class(DeleteTerms) == "character" )
      {
        Predictors[ !( Predictors %in% DeleteTerms ) ] -> Predictors ;
      } ;
    } ;
    
    # Generation of formula  
    reformulate( Predictors, outcome ) -> Formula ; 
    
    return( Formula ) ;
  } ;
  
  hmftest.systematic <- function( formula2 , data ) 
  {
    formula2 |>
      as.character() ->
      formula2.ch ;
    
    if ( grepl( ":", formula2.ch[3]) )
    {
      return( "No hmf test for models with interactions" )
    }
    
    reformulate( paste0( "0 | ", formula2.ch[3]), formula2.ch[2] ) ->
      formula2.new  ;
    
    dfidx::dfidx( data, shape = "wide", choice = formula2.ch[2] ) ->
      data.new ;
    
    mlogit::mlogit( formula2.new, 
                    data = data.new 
    ) -> model.new ; 
    
    c( "var", "Chisq", "df", "p-value" ) -> output ; 
    
    for (a in 2:nlevels( data[, formula2.ch[2] ] ) )
    { 
      mlogit::mlogit( formula2.new, 
                      data = data.new,
                      alt.subset = levels( data[, formula2.ch[2] ] )[-a]
      ) -> model.alt ;
      
      try( mlogit::hmftest( model.new, model.alt ) ) ->
        tmp ;
      
      if (attr( tmp,"class") == "try-error" )
      {
        "" -> output ; 
      } else
      {
        rbind( output, 
               c( levels( data[, formula2.ch[2] ] )[a], 
                  IFELSE( is.null( round ), 
                          tmp$statistic,
                          round( tmp$statistic, round ) ) ,
                  tmp$parameter,
                  IFELSE( is.null( pvalue.round ), 
                          tmp$p.value, p.round( tmp$p.value, pvalue.round ) ) )
        ) -> 
          output ;
      }
      
    }
    
    return( data.frame(output) )
  }
  
  Multinomial.SubsetLevels <- function( formula2 , data, round  )
  {
    formula2 |>
      as.character() ->
      formula2.ch ;
    
    nnet::multinom( reformulate(as.character(formula2)[3], 
                                as.character(formula2)[2] ), 
                    data = data,
                    Hess = TRUE ) -> m1 
    
    
    cbind( paste0( rownames(summary(m1)$coefficients),
                   ": Base model" ),
           IFELSE( !is.null(round),
                   round( summary(m1)$coefficients, 
                          round ),
                   summary(m1)$coefficients ) 
    ) -> output ;
    
    if ( nlevels( data[, formula2.ch[2] ] ) > 3 )
    {
      rbind.force( output,
                   rbind.force(  lapply( 2:nlevels( data[, formula2.ch[2] ] ), 
                                         FUN = function(a)
                                         {
                                           data[ data[, formula2.ch[2] ] != 
                                                   levels( data[, formula2.ch[2] ] )[a],] ->
                                             data2
                                           
                                           factor( data2[, formula2.ch[2] ] ) ->
                                             data2[, formula2.ch[2] ]
                                           
                                           nnet::multinom( reformulate(as.character(formula2)[3], 
                                                                       as.character(formula2)[2] ), 
                                                           data = data2,
                                                           Hess = TRUE ) -> m1 
                                           
                                           cbind( paste0( rownames(summary(m1)$coefficients),
                                                          ": -", 
                                                          levels( data[, formula2.ch[2] ] )[a] ,
                                                          " model" ),
                                                  IFELSE( !is.null(round),
                                                          round( summary(m1)$coefficients, 
                                                                 round ),
                                                          summary(m1)$coefficients ) 
                                           ) 
                                         }) ), empty = "" ) -> 
        output ;
    } else
    {
      rbind.force( output,
                   rbind.force( lapply( 2:nlevels( data[, formula2.ch[2] ] ), 
                                        FUN = function(a)
                                        {
                                          data[ data[, formula2.ch[2] ] != 
                                                  levels( data[, formula2.ch[2] ] )[a],] ->
                                            data2
                                          
                                          factor( data2[, formula2.ch[2] ] ) ->
                                            data2[, formula2.ch[2] ]
                                          
                                          nnet::multinom( reformulate(as.character(formula2)[3], 
                                                                      as.character(formula2)[2] ), 
                                                          data = data2,
                                                          Hess = TRUE ) -> m1 
                                          
                                          cbind( paste0( levels( data2[, formula2.ch[2] ] )[2],
                                                         ": -", 
                                                         levels( data[, formula2.ch[2] ] )[a] ,
                                                         " model" ),
                                                 t(IFELSE( !is.null(round),
                                                           round( summary(m1)$coefficients, 
                                                                  round ),
                                                           summary(m1)$coefficients ) )
                                          ) 
                                        }) ),
                   empty = "" )  -> 
        output ;
    }
    
    output |>
      data.frame() |>
      dplyr::arrange( X1 ) |>
      t() |>
      (function(x)  cbind( c( "Outcome levels ->", m1$coefnames ), 
                           x ) )() -> output
    
    return( data.frame(output) )
  }
  
  pairs2 <- function( y, X, ExportName, n )
  {
    data.frame(y) |>
      lapply(as.numeric) |>
      data.frame() -> y
    data.frame(X) |>
      lapply(as.numeric) |>
      data.frame() -> X
    
    (ncol(X) / n) |> trunc() -> npairs
    (ncol(X) %% n) -> addpairs
    
    if ( npairs != 0 )
    {
      for (a in 0:(npairs - 1) )
      {
        png( paste( ExportName,
                    "Pair_Graphics",
                    "_", a +1,
                    ".png",
                    sep = "" ) )
        y |>
          cbind(X[, (1 + n * a):(
            n * (a + 1) ) ]) |>
          pairs( cex.labels = 0.8, main = paste( "Pairs graphic", a + 1 ) )
        dev.off() ;
      }
    }
    
    if ( addpairs != 0 )
    {
      png( paste( ExportName,
                  "Pair_Graphics",
                  "_", (npairs + 1),
                  ".png",
                  sep = "" ) )
      y |>
        cbind(  subset( X, select = (1 + n * npairs):ncol(X) ) ) |>
        pairs(  cex.labels = 0.8, main = paste( "Pairs graphic", npairs + 1 ) )
      dev.off() ;
    }
  }
  
  termplot2 <- function( model, ExportName )
  {
    ( (ncol( model$model  ) - 1) / 9) |> trunc() -> n ;
    ( (ncol( model$model  ) - 1) %% 9) -> o ;
    
    if ( n != 0 )
    {
      for (a in 1:n )
      {
        png( paste( ExportName,
                    "RegressionsTerms_vs_Predictors_",
                    a,
                    ".png",
                    sep = "" ) )
        layout( matrix( 1:9, ncol=3, byrow=T ) )
        par( oma = c( 0, 0, 2, 0) )
        termplot( model, 
                  terms = attr( terms( model ),"term.labels")[((a - 1) * 9 + 1):(a  * 9)],
                  ask = FALSE,
                  partial.resid = TRUE, 
                  se = TRUE, 
                  smooth = panel.smooth )
        mtext( text =  paste( "Regression terms vs Predictors", a ), 
               outer = TRUE, cex = 1.5 ) ;
        dev.off() ;
      }
    }
    
    if ( o != 0 )
    {
      png( paste( ExportName,
                  "RegressionsTerms_vs_Predictors_",
                  n + 1,
                  ".png",
                  sep = "" ) )
      layout( matrix( 1:9, ncol=3, byrow=T ) )
      par( oma = c( 0, 0, 2, 0) )
      termplot( model, 
                terms = attr( terms( model ),"term.labels")[(n * 9 + 1):(n * 9 + o)],
                ask = FALSE,
                partial.resid = TRUE, 
                se = TRUE, 
                smooth = panel.smooth )
      mtext( text =  paste( "Regression terms vs Predictors", n + 1), 
             outer = TRUE, cex = 1.5 ) ;
      dev.off() ;
    }
    
  } ;
  
  residualPlots2 <- function( model, ExportName )
  {
    ( (ncol( model$model  ) - 1) / 9) |> trunc() -> n ;
    ( (ncol( model$model  ) - 1) %% 9) -> o ;
    
    if ( n != 0 )
    {
      for (a in 1:n )
      {
        png( paste( ExportName,
                    "Pearson_Residuals_vs_Independant_Vars",
                    a,
                    ".png",
                    sep = "" ) )
        layout( matrix( 1:9, ncol=3, byrow=T ) )
        par( oma = c( 0, 0, 2, 0) )
        car::residualPlot( model, 
                           terms = reformulate( attr( terms( model ),"term.labels")[((a - 1) * 9 + 1):(a  * 9)] ),
                           tests = FALSE, 
                           fitted = FALSE, 
                           ask = FALSE, 
                           type = "rstandard" )
        mtext( text =  paste( "Pearson Residuals vs Independant Vars", a), 
               outer = TRUE, cex = 1.5 ) ;
        dev.off() ;
      }
    }
    
    if ( o != 0 )
    {
      png( paste( ExportName,
                  "Pearson_Residuals_vs_Independant_Vars",
                  n + 1,
                  ".png",
                  sep = "" ) )
      layout( matrix( 1:9, ncol=3, byrow=T ) )
      par( oma = c( 0, 0, 2, 0) )
      car::residualPlot( model, 
                         terms = reformulate( attr( terms( model ),"term.labels")[(n * 9 + 1):(n * 9 + o)] ),
                         tests = FALSE, 
                         fitted = FALSE, 
                         ask = FALSE, 
                         type = "rstandard" )
      mtext( text =  paste( "Pearson Residuals vs Independant Vars", n + 1), 
             outer = TRUE, cex = 1.5 ) ;
      dev.off() ;
    }
  }
  
  avPlots2 <- function( model, ExportName )
  {
    ( (length( names(model$coefficients) ) - 1) / 9) |> trunc() -> n ;
    ( (length( names(model$coefficients)  ) - 1) %% 9) -> o ;
    
    if ( n != 0 )
    {
      for (a in 1:n )
      {
        png( paste( ExportName,
                    "Added-Variable_Plots",
                    a,
                    ".png",
                    sep = "" ) )
        layout( matrix( 1:9, ncol=3, byrow=T ) )
        par( oma = c( 0, 0, 2, 0) )
        for (b in names(model$coefficients)[-1][((a - 1) * 9 + 1):(a  * 9)])
        {
          car::avPlot( model, 
                       variable =  b
          ) ;
        }
        mtext( text =  paste( "Added-Variable Plots", a ), 
               outer = TRUE, cex = 1.5 ) ;
        dev.off() ;
      }
    }
    
    if ( o != 0 )
    {
      png( paste( ExportName,
                  "Added-Variable_Plots",
                  n + 1,
                  ".png",
                  sep = "" ) )
      layout( matrix( 1:9, ncol=3, byrow=T ) )
      par( oma = c( 0, 0, 2, 0) )
      for (b in names(model$coefficients)[-1][(n * 9 + 1):(n * 9 + o)])
      {
        car::avPlot( model, 
                     variable =  b
        ) ;
      }
      mtext( text =  paste( "Added-Variable Plots", n + 1 ), 
             outer = TRUE, cex = 1.5 ) ;
      dev.off() ;
    }
  }
  
  crPlots2 <- function( model, ExportName )
  {
    ( (ncol( model$model  ) - 1) / 9) |> trunc() -> n ;
    ( (ncol( model$model  ) - 1) %% 9) -> o ;
    
    if ( n != 0 )
    {
      for (a in 1:n )
      {
        png( paste( ExportName,
                    "Component-Residuals_Plots",
                    a,
                    ".png",
                    sep = "" ) )
        layout( matrix( 1:9, ncol=3, byrow=T ) )
        par( oma = c( 0, 0, 2, 0) )
        car::crPlots( model, 
                      terms = reformulate( attr( terms( model ),"term.labels")[((a - 1) * 9 + 1):(a  * 9)] ),
                      ask = FALSE, main = "" )
        mtext( text =  paste( "Component-Residuals Plots", a), 
               outer = TRUE, cex = 1.5 ) ;
        dev.off() ;
      }
    }
    
    if ( o != 0 )
    {
      png( paste( ExportName,
                  "Component-Residuals_Plots",
                  n + 1,
                  ".png",
                  sep = "" ) )
      layout( matrix( 1:9, ncol=3, byrow=T ) )
      par( oma = c( 0, 0, 2, 0) )
      car::crPlots( model, 
                    terms = reformulate( attr( terms( model ),"term.labels")[(n * 9 + 1):(n * 9 + o)] ),
                    ask = FALSE, main = "" )
      mtext( text =  paste( "Component-Residuals Plots", n + 1), 
             outer = TRUE, cex = 1.5 ) ;
      dev.off() ;
    }
  }
  
  
  Lm.Analysis <- function( outcome, predictors, 
                           data, 
                           na.omit = TRUE,
                           FULL = TRUE, 
                           selected.predictors = NULL,
                           ANOVA = FALSE 
  )
  {
    # Formula
    Formula.Maker( outcome, predictors ) -> 
      formula ;
    
    # model
    if ( na.omit == TRUE ) { 
      na.omit( data ) -> data } 
    
    lm( formula, data = data ) ->
      m1 ;
    
    m1 |>
      (function(x) list( model = x )  )() -> 
      output ;
    
    m1 |> summary() -> summary1 ;
    
    m1 |> 
      lmtest::coeftest( 
        vcov. = sandwich::vcovCL, 
        cluster = as.formula( paste0( "~", cluster.ID ) ) 
      ) -> summary.corrected1 ;
    
    m1 |>
      #car::Confint( level = conf.level ) |>
      ( function(x)
        cbind( 
          Estimate = x$coefficients,
          lmtest::coefci( x, vcov. = sandwich::vcovCL, 
                          cluster = as.formula( paste0( "~", cluster.ID ) ),
                          level = conf.level )
        )
      )() |>
      as.data.frame() |>
      (function(x) IFELSE( is.null( round ),
                           x,
                           round( x, round ) ) )() |>
      (function(x) cbind( Predictors = rownames(x), x ) )() |>
      (function(x) rbind.force( colnames(x), x ) )() -> 
      confint.corrected1 ;
    
    m1 |>
      ( function(x) {
        car::Anova( x,
                    type = "3",
                    vcov. = 
                      sandwich::vcovCL( x,
                                        cluster = as.formula( paste0( "~", cluster.ID ) ) ) 
        ) }
      )() ->
      anova.corrected1 ;
    
    # prepare results 
    if (FULL)
    {
      # formula
      "Model:" -> results.tab ;
      
      formula |>
        deparse() |>
        (function(x) rbind.force( results.tab, x, empty = "" ) 
        )() -> results.tab ;
      
      "" |> (function(x) rbind.force( results.tab, x, empty = "" ) 
      )() -> results.tab ;
      
      # missing data
      c( "Observations deleted due to missingness:",
         dim( data )[1] - dim( m1$model )[1] ) |>
        (function(x) rbind.force( results.tab, x, empty = "" ) 
        )() -> 
        results.tab ;
      
      "" |> (function(x) rbind.force( results.tab, x, empty = "" ) 
      )() -> results.tab ;
      
      
      #  slopes and t.tests
      "Model coefficients and t-tests" |> 
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      summary.corrected1[,1:4] |>
        as.data.frame() |>
        subset( select = -Estimate ) |>
        transform( 
          `Std. Error` =  IFELSE( is.null( round ), 
                                  `Std. Error`,
                                  round( `Std. Error`, round ) ),
          `t value` =  IFELSE( is.null( round ), 
                               `t value`,
                               round( `t value`, round ) ),
          `Pr(>|t|)` =  IFELSE( is.null( pvalue.round ), 
                                `Pr(>|t|)`,
                                p.round( `Pr(>|t|)`, pvalue.round ) ) ) |>
        (function(x) rbind.force( colnames(x), x ) )() |>
        (function(x) cbind( confint.corrected1, x ) )() |>
        (function(x) rbind.force( results.tab, x, empty = "" ) 
        )() -> results.tab ;
      
      "" |> (function(x) rbind.force( results.tab, x, empty = "" ) 
      )() -> results.tab ;
      
      # Anova
      data.frame( Predictors = rownames( anova.corrected1 ),
                  "F" = anova.corrected1$F,
                  "Df" = anova.corrected1$Df,
                  "Pr(>F)" = anova.corrected1$`Pr(>F)`
      )[1:(nrow(anova.corrected1) - 1),] |>
        as.data.frame() |> 
        (function(x) data.frame( 
          Predictors = x$Predictors,
          `Df numerator` = x$Df,
          `Df denominator` = c( rep( m1$df.residual, 
                                     times = dim(x)[1] ) ),
          `F value` =  IFELSE( is.null( round ), 
                               x$F,
                               round( x$F, round ) ), 
          `Pr(>F)` =  IFELSE( is.null( pvalue.round ), 
                              x$`Pr..F.`,
                              p.round( x$`Pr..F.`, pvalue.round ) ) ) 
        )() |>
        cbind( `Cohen's f-squared on R-squared` =  
                 IFELSE( is.null( round ), 
                         c( NA, cohen.f2( m1 ) ),
                         c( NA, round( cohen.f2( m1 ), round )  ) ) 
        ) |>
        cbind( `Partial eta-squared` =  
                 IFELSE( is.null( round ), 
                         c( NA, heplots::etasq( m1 )[1:(
                           nrow( heplots::etasq( m1 ) ) - 1), 1 ] ),
                         c( NA, round( heplots::etasq( m1 )[1:(
                           nrow( heplots::etasq( m1 ) ) - 1), 1 ],
                           round )  ) ) 
        ) |>
        cbind(  AIC =  IFELSE( is.null( round ), 
                               AIC( m1 ),
                               round( AIC( m1 ), round ) ) ) ->
        anova1 ;
      
      "ANOVA (type 3 tests)" |> (function(x) rbind.force( 
        results.tab, x, empty = "" ) )() -> 
        results.tab ;
      
      anova1 |>
        (function(x) rbind.force( c(
          "Predictors", "Df numerator", "Df denominator",               
          "F value", "Pr(>F)", "Cohen's f-squared on R-squared",
          "Partial eta-squared", "AIC"
        ), x) )() |>
        (function(x) rbind.force( results.tab, x, empty = "" ) 
        )() -> results.tab ;
      
      "" |> (function(x) rbind.force( results.tab, x, empty = "" ) 
      )() -> results.tab ;
      
      # Models infos
      c( "Multiple R-squared:", 
         IFELSE( is.null( round ), 
                 summary1$r.squared,
                 round( summary1$r.squared, round ) ),
         "Adjusted R-squared:", 
         IFELSE( is.null( round ), 
                 summary1$adj.r.squared,
                 round( summary1$adj.r.squared, round ) ) ) |>
        (function(x) rbind.force( results.tab, x, empty = "" ) 
        )() -> results.tab ;
      
      c( "AIC:", 
         IFELSE( is.null( round ), 
                 AIC(m1),
                 round( AIC(m1), round ) ),
         "AICc:", 
         IFELSE( is.null( round ), 
                 MuMIn::AICc(m1),
                 round( MuMIn::AICc(m1), round ) ) ) |> 
        (function(x) rbind.force( results.tab, x, empty = "" ) 
        )() -> results.tab ;
      
      "" |> (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      # post hoc analysis with no plots
      # Residuals normality 
      residuals( m1 ) -> residuals1 ;
      if ( length( residuals1 ) < 5000 ) 
      { shapiro.test( residuals1 ) -> shapiro.res ; }  else
      { list( "p.value" = NA ) -> shapiro.res ; }
      nortest::ad.test( residuals1 ) -> anderson.res ;
      moments::jarque.test( residuals1 ) -> jarque.res ;
      
      "Normality tests on Residuals" |> 
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      c( "Shapiro test p-value:", 
         IFELSE( is.null( pvalue.round ), 
                 shapiro.res$p.value,
                 p.round( shapiro.res$p.value, pvalue.round ) ),
         "Anderson-Darling test p-value:", 
         IFELSE( is.null( pvalue.round ), 
                 anderson.res$p.value,
                 p.round( anderson.res$p.value, pvalue.round ) ),
         "Jarque-Bera test p-value:", 
         IFELSE( is.null( pvalue.round ), 
                 jarque.res$p.value,
                 p.round( jarque.res$p.value, pvalue.round ) ) ) |> 
        (function(x) rbind.force( results.tab, x, empty = "" ) 
        )() -> results.tab ;
      
      "" |> (function(x) rbind.force( results.tab, x, empty = "" ) 
      )() -> results.tab ;
      
      # Residuals homosedasticity 
      "Homosedasticity tests on Residuals" |> 
        (function(x) rbind.force( results.tab, x, empty = "" ) 
        )() -> results.tab ;
      
      c( "Score test for Non-Constant Error Variance p-value:", 
         IFELSE( is.null( pvalue.round ), 
                 car::ncvTest( m1 )$p,
                 p.round( car::ncvTest( m1 )$p, pvalue.round ) ),
         "Breusch-Pagan test p-value:", 
         IFELSE( is.null( pvalue.round ), 
                 lmtest::bptest(m1)$p.value,
                 p.round( lmtest::bptest(m1)$p.value, pvalue.round ) ) )  |> 
        (function(x) rbind.force( results.tab, x, empty = "" ) 
        )() -> results.tab ;
      
      "" |> (function(x) rbind.force( results.tab, x, empty = "" ) 
      )() -> results.tab ;
      
      # Residuals independancy 
      "Independancy of Residuals" |> 
        (function(x) rbind.force( results.tab, x, empty = "" )
        )() -> results.tab ;
      
      set.seed( 123) ;
      car::durbinWatsonTest( m1 ) -> dw1 ; 
      c( "Durbin-Watson statistic (1.5 - 2.5):",
         IFELSE( is.null( round ), 
                 dw1$dw,
                 round( car::durbinWatsonTest( m1 )$p, round ) ),
         "Durbin-Watson test p-value:", 
         IFELSE( is.null( pvalue.round ), 
                 dw1$p,
                 p.round( car::durbinWatsonTest( m1 )$p, pvalue.round 
                 ) ) ) |> 
        (function(x) rbind.force( results.tab, x, empty = "" ) 
        )() -> results.tab ;
      
      "" |> (function(x) rbind.force( results.tab, x, empty = "" ) 
      )() -> results.tab ;
      
      #  Multicollinearity
      if ( length( attr( terms(m1),"term.labels") ) > 1 )
      {
        c( "Multicollinearity check" ) |> 
          (function(x) rbind.force( results.tab, x, empty = "" )
          )() -> results.tab ;
        
        c( "(generalized) Variance Inflation Factors:" ) |> 
          (function(x) rbind.force( results.tab, x, empty = "" ) 
          )() -> results.tab ;
        
        car::vif( m1 ) |>
          (function(x) IFELSE( is.null( round ), 
                               x,
                               round( x, round ) ) )() |>
          as.data.frame() |>
          (function(x) cbind( Predictors = rownames(x), x ) )()  -> 
          tmp.vif ;
        
        if ( ncol( tmp.vif ) == 2 ) { "VIF" -> colnames( tmp.vif )[2] }
        
        tmp.vif |>
          (function(x) rbind.force( colnames(x), x ) )() |>
          (function(x) rbind.force( results.tab, x, empty = "" ) 
          )() -> results.tab ;
        
        "" |> (function(x) rbind.force( results.tab, x, empty = "" )
        )() -> results.tab ;
        
        # besley
        attr( terms( m1 ),"term.labels" ) -> Vars
        base::subset( data, 
                      select = Vars[ 
                        !( Vars  %in% Vars[ grep( ":", Vars ) ] ) ] 
        ) |>
          dplyr::select_if( is.numeric ) ->
          data2 
        
        VisCollin::colldiag( mod = lm(
          reformulate( colnames(data2),
                       as.character(formula)[2] ),
          data = data), 
          scale = FALSE, 
          center = FALSE, add.intercept = T ) -> 
          besley
        
        "Belsley criteria (computed on numeric predictors only):" |> 
          (function(x) rbind.force( results.tab, x, empty = "" ) 
          )() -> results.tab ;
        
        data.frame( besley$condindx, besley$pi) |>
          (function(x) rbind( colnames(x), x ) )() |>
          (function(x) rbind.force( results.tab, x, empty = "" ) 
          )() -> results.tab ;
        
        "" |> (function(x) rbind.force( results.tab, x, empty = "" ) 
        )() -> results.tab ;
        
        # other criteria
        if ( ncol(data2) > 1 )
        {
          "Other criteron on numeric predictors only:" |> 
            (function(x) rbind.force( results.tab, x, empty = "" ) 
            )() -> results.tab ;
          "===================================" |> 
            (function(x) rbind.force( results.tab, x, empty = "" ) 
            )() -> results.tab ;
          
          #omcdiag( data2,
          #           data[,outcome]
          #  )  |> 
          #    capture.output() |>
          #    data.frame() |>
          #    (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
          
          #  imcdiag( data2,
          #          data[,outcome]
          #  )  |> 
          #   capture.output() |>
          #    data.frame() |>
          #    (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
          # "" |>  (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
        }
        
      }
      
      
      #  Linearity and non-addititvity check
      c(  "Linearity and non-addititvity check" ) |> 
        (function(x) rbind.force( results.tab, x, empty = "" ) 
        )() -> results.tab ;
      
      c( "Curvature test and Tukey's test for non-additivity:" ) |> 
        (function(x) rbind.force( results.tab, x, empty = "" ) 
        )() -> results.tab ;
      
      car::residualPlot( m1, plot = FALSE ) |>
        (function(x)  IFELSE( is.null( pvalue.round ), 
                              x[2],
                              p.round( x[2], pvalue.round ) ) )() |>
        (function(x) rbind.force( results.tab, x, empty = "" )
        )() -> results.tab ;
      
      "Best Fractional Polynomial for each numeric predictor:" |> 
        (function(x) rbind.force( results.tab, x, empty = "" ) 
        )() -> results.tab ;
      
      formula |> as.character() -> formula1 ;
      
      Systematic.FP( output = formula1[2], 
                     predictors = attr( terms(m1), 'term.labels'),
                     family = "gaussian", 
                     data = data, 
                     na.omit = na.omit ) |>
        as.data.frame() |>
        (function(x) rbind.force( results.tab, x, empty = "" )
        )() -> results.tab ;
      
      "" |> (function(x) rbind.force( results.tab, x, empty = "" )
      )() -> results.tab ;
      
      # Observation with major influence
      c( "Observation with major influence" ) |> 
        (function(x) rbind.force( results.tab, x, empty = "" ) 
        )() -> results.tab ;
      
      c( "Number of observations",
         "with a Cook distance",
         "over 4 / N:",
         sum( cooks.distance( m1 ) > 4 / nrow( data ) )
      ) |> 
        (function(x) rbind.force( results.tab, x, empty = "" ) 
        )() -> results.tab ;
      
      "" |> (function(x) rbind.force( results.tab, x, empty = "" ) 
      )() -> results.tab ;
      
      c( "Bonferroni Outlier test" ) |> 
        (function(x) rbind.force( results.tab, x, empty = "" ) 
        )() -> results.tab ;
      
      car::outlierTest( m1) |> 
        capture.output() |> 
        matrix(  ncol = 1) |>
        as.data.frame() |>
        (function(x) rbind.force( results.tab, x, empty = "" ) 
        )() -> results.tab ;
      
      "" |> (function(x) rbind.force( results.tab, x, empty = "" ) 
      )() -> results.tab ;
      
      "/////////////////////////////////////////" |> 
        (function(x) rbind.force( results.tab, x, empty = "" ) 
        )() -> results.tab ;
    }
    
    if ( !FULL & ANOVA )
    {
      # Anova
      data.frame( Predictors = rownames( anova.corrected1 ),
                  "F" = anova.corrected1$F,
                  "Df" = anova.corrected1$Df,
                  "Pr(>F)" = anova.corrected1$`Pr(>F)`
      )[1:(nrow(anova.corrected1) - 1),] |>
        as.data.frame() |> 
        (function(x) data.frame( 
          Predictors = x$Predictors,
          `Df numerator` = x$Df,
          `Df denominator` = c( rep( m1$df.residual, 
                                     times = dim(x)[1] ) ),
          `F value` =  IFELSE( is.null( round ), 
                               x$F,
                               round( x$F, round ) ), 
          `Pr(>F)` =  IFELSE( is.null( pvalue.round ), 
                              x$`Pr..F.`,
                              p.round( x$`Pr..F.`, pvalue.round ) ) ) 
        )() |>
        cbind( `Cohen's f-squared on R-squared` =  
                 IFELSE( is.null( round ), 
                         c( NA, cohen.f2( m1 ) ),
                         c( NA, round( cohen.f2( m1 ), round )  ) ) 
        ) |>
        cbind( `Partial eta-squared` =  
                 IFELSE( is.null( round ), 
                         c( NA, heplots::etasq( m1 )[1:(
                           nrow( heplots::etasq( m1 ) ) - 1), 1 ] ),
                         c( NA, round( heplots::etasq( m1 )[1:(
                           nrow( heplots::etasq( m1 ) ) - 1), 1 ],
                           round )  ) ) 
        ) |>
        cbind(  AIC =  IFELSE( is.null( round ), 
                               AIC( m1 ),
                               round( AIC( m1 ), round ) ) ) ->
        tmp.anova ;
      
      # Extraction
      lapply( 1:length(selected.predictors),  
              function(a){ 
                tmp.anova[ grep( selected.predictors[a],  tmp.anova[,1] ), ] } ) |> 
        (function(x) rbind.force( tmp.anova[1,], x, empty = "" ) )() |>
        unique() ->
        results.tab ;
      
      rbind.force( colnames(tmp.anova), results.tab ) ->
        results.tab ;
    }
    
    
    if ( !FULL & !ANOVA )
    {
      # Compute output
      summary.corrected1[,1:4] |>
        as.data.frame() |>
        subset( select = -Estimate ) |>
        transform( 
          `Std. Error` =  IFELSE( is.null( round ), 
                                  `Std. Error`,
                                  round( `Std. Error`, round ) ),
          `t value` =  IFELSE( is.null( round ), 
                               `t value`,
                               round( `t value`, round ) ),
          `Pr(>|t|)` =  IFELSE( is.null( pvalue.round ), 
                                `Pr(>|t|)`,
                                p.round( `Pr(>|t|)`, pvalue.round ) ) ) |>
        (function(x) rbind.force( colnames(x), x ) )() |>
        (function(x) cbind( confint.corrected1, x ) )() -> 
        tmp.student ;
      
      # Extraction
      lapply( 1:length(selected.predictors),  
              function(a){ 
                tmp.student[ grep( selected.predictors[a],  tmp.student[,1] ), ] } 
      ) |> 
        (function(x)  rbind.force( tmp.student[1,], x, empty = "" ) )() |>
        unique() ->
        results.tab ;
    }
    
    # output 
    NULL -> rownames( results.tab ) ;
    NULL -> colnames( results.tab ) ;
    
    c( output, list( results.tab = results.tab ) ) -> 
      output ;
    
    return( output )
  }
  
  Glm.Analysis <- function( outcome, predictors, 
                            family,
                            data, 
                            na.omit = TRUE,
                            FULL = TRUE, 
                            selected.predictors = NULL,
                            ANODE = FALSE 
  )
  {
    # Formula
    if ( length( outcome ) == 2 ) 
    { paste( "cbind(", outcome[1], ",", outcome[2], ")" ) -> outcome ;
      as.formula( paste(outcome, 
                        " ~ ", 
                        as.character( reformulate( predictors ) )[2] ) 
      ) -> 
        formula ; 
    } else
    {
      Formula.Maker( outcome, predictors ) -> 
        formula ;
    }
    
    # model
    if ( na.omit == TRUE ) { na.omit( data ) -> data } 
    
    glm( formula, family = family, data = data ) ->
      m1 ;
    
    m1 |> 
      (function(x) list( model = x ) )() -> 
      output ;
    
    m1 |> summary() -> summary1 ;
    
    m1 |> 
      lmtest::coeftest( 
        vcov. = sandwich::vcovCL, 
        cluster = as.formula( paste0( "~", cluster.ID ) ) 
      ) -> summary.corrected1 ;
    
    m1 |>
      #car::Confint( level = conf.level ) |>
      ( function(x)
        cbind( 
          Estimate = x$coefficients,
          lmtest::coefci( x, vcov. = sandwich::vcovCL, 
                          cluster = as.formula( paste0( "~", cluster.ID ) ),
                          level = conf.level )
        )
      )() |>
      as.data.frame()|>
      exp() |>
      (function(x) IFELSE( is.null( round ),
                           x,
                           round( x, round ) ) )() |>
      (function(x) cbind( Predictors = rownames(x), x ) )() |>
      (function(x) rbind.force( colnames(x), x ) )() -> 
      confint.corrected1 ;
    
    confint.corrected1[1,2:4] <- c( "exp(Estimate)", 
                                    paste0("exp(", 
                                           (1 - conf.level ) / 2 * 100,
                                           "%CI)"),
                                    paste0("exp(", 
                                           100 - (1 - conf.level ) / 2 * 100,
                                           "%CI)")
    ) ;
    
    m1 |>
      ( function(x) {
        car::Anova( x,
                    type = "3",
                    vcov. = 
                      sandwich::vcovCL( x,
                                        cluster = as.formula( paste0( "~", cluster.ID ) ) ) 
        ) }
      )() ->
      anova.corrected1 ;
    
    # prepare results 
    if (FULL)
    {
      # formula
      "Model:" -> results.tab ;
      
      formula |> 
        deparse() |> 
        (function(x) rbind.force( results.tab, x, empty = "" ) 
        )() -> results.tab ;
      
      "" |> (function(x) rbind.force( results.tab, x, empty = "" ) 
      )() -> results.tab ;
      
      # missing data
      c( "Observations deleted due to missingness:",
         dim( data )[1] - dim( m1$model )[1] ) |> 
        (function(x) rbind.force( results.tab, x, empty = "" ) 
        )() -> results.tab ;
      
      "" |> (function(x) rbind.force( results.tab, x, empty = "" ) 
      )() -> results.tab ;
      
      #  slopes and t.tests
      "Model coefficients and t-tests" |> 
        (function(x) rbind.force( results.tab, x, empty = "" ) 
        )() -> results.tab ;
      
      data.frame( `Std. Error` =  IFELSE( is.null( round ), 
                                          summary.corrected1[,2],
                                          round( summary.corrected1[,2], round ) ),
                  `z value` =  IFELSE( is.null( round ), 
                                       summary.corrected1[,3],
                                       round( summary.corrected1[,3], round ) ),
                  `Pr(>|z|)` =  IFELSE( is.null( pvalue.round ), 
                                        summary.corrected1[,4],
                                        p.round( summary.corrected1[,4], pvalue.round ) ) ) |>
        (function(x) rbind.force( colnames(summary.corrected1)[-1], x ) )()|>
        (function(x) cbind( confint.corrected1, x )  )() |>
        (function(x) rbind.force( results.tab, x, empty = "" ) 
        )() -> results.tab ;
      
      "" |> (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      c( "Degrees of freedom:", summary1$df[2],
         "Number of Coefficients:", summary1$df[1] ) |> 
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      "" |> (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      # Anova
      data.frame( Predictors = rownames( anova.corrected1 ), 
                  `LR Chisq` =  IFELSE( is.null( round ), 
                                        anova.corrected1$`LR Chisq`,
                                        round( anova.corrected1$`LR Chisq`, round ) ),
                  `Chisq Df` = anova.corrected1$Df,
                  `Residual Df` = m1$df.residual,
                  `Pr(>Chisq)` =  IFELSE( 
                    is.null( pvalue.round ), 
                    anova.corrected1$`Pr(>Chisq)`,
                    p.round( anova.corrected1$`Pr(>Chisq)`, 
                             pvalue.round ) ) ) |>
        cbind(  `Cohen's f-squared on pseudo-R-squared` = 
                  IFELSE( is.null( round ), 
                          cohen.f2( m1, TRUE, family ),
                          round( cohen.f2( m1, TRUE, family ), 
                                 round ) ) ) |>
        cbind( 
          AIC = IFELSE( is.null( round ), 
                        AIC( m1 ),
                        round( AIC( m1 ), round ) ) )-> 
        anova1 ;
      
      rbind.force( c( "Predictors", "LR Chisq",
                      "Chisq Df", "Residual Df", "Pr(>Chisq)",
                      "Cohen's f-squared on pseudo-R-squared",
                      "AIC" ),
                   anova1
      ) -> tmp.anova ;
      
      "ANODE (type 3 tests)" |> 
        (function(x) rbind.force( results.tab, x, empty = "" ) 
        )() -> results.tab ;
      
      tmp.anova |>
        (function(x) rbind.force( results.tab, x, empty = "" ) 
        )() -> results.tab ;
      
      "" |> (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      # Models infos
      c( "Multiple Cox an Snell pseuod-R-squared:", 
         IFELSE( is.null( round ), 
                 MuMIn::r.squaredLR( m1, stats::update( m1, reformulate( "1" ) ) )[1],
                 round( MuMIn::r.squaredLR( m1, stats::update( m1, reformulate( "1" ) ) )[1], 
                        round ) ),
         "Nagelkerke Adjusted pseudo-R-squared:", 
         IFELSE( is.null( round ), 
                 attr( MuMIn::r.squaredLR( m1, stats::update( m1, reformulate( "1" ) ) ),
                       "adj.r.squared"),
                 round( attr( MuMIn::r.squaredLR( m1, stats::update( m1, reformulate( "1" ) ) ),
                              "adj.r.squared"), 
                        round ) ) ) |> 
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      c( "AIC:", 
         IFELSE( is.null( round ), 
                 AIC(m1),
                 round( AIC(m1), round ) ),
         "AICc:", 
         IFELSE( is.null( round ), 
                 MuMIn::AICc(m1),
                 round( MuMIn::AICc(m1), round ) ) ) |> 
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      "" |> (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      # post hoc analysis with no plots
      
      # Dispersion 
      c( "Dispersion:", 
         IFELSE( is.null( round ), 
                 summary( m1 )$dispersion ,
                 round(  summary( m1 )$dispersion , round ) ) ) |> 
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      "" |> (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      #  Multicollinearity
      if ( length( attr( terms(m1),"term.labels") ) > 1 )
      {
        c( "Multicollinearity check" ) |> 
          (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
        
        c( "(generalized) Variance Inflation Factors:" ) |> 
          (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
        
        car::vif( m1 ) |>
          (function(x) IFELSE( is.null( round ), 
                               x,
                               round( x, round ) ) )() |>
          as.data.frame() |>
          (function(x)   cbind( Predictors = rownames(x), x ) )() -> 
          tmp.vif ;
        
        if ( ncol( tmp.vif ) == 2 ) { "VIF" -> colnames( tmp.vif )[2] }
        
        tmp.vif |>
          (function(x)  rbind.force( colnames(x), x ) )() |>
          (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
        
        "" |> (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
        
        # besley
        attr( terms( m1 ),"term.labels" ) -> Vars
        subset( data, 
                select = Vars[ 
                  !( Vars  %in% Vars[ grep( ":", Vars ) ] ) ] ) |>
          dplyr::select_if( is.numeric ) ->
          data2 
        
        VisCollin::colldiag( mod = glm(
          reformulate( colnames(data2),
                       as.character(formula)[2] ),
          family = family,
          data = data), 
          scale = FALSE, 
          center = FALSE, add.intercept = T ) -> 
          besley
        
        "Belsley criteria (computed on numeric predictors only):" |> (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
        data.frame( besley$condindx, besley$pi) |>
          (function(x) rbind( colnames(x), x ) )() |>
          (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
        "" |> (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      }
      
      #  Linearity and non-addititvity check
      c(  "Linearity and non-addititvity check" ) |> 
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab 
      
      "Best Fractional Polynomial for each numeric predictor:" |> 
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      formula |> as.character() -> formula1 ;
      
      Systematic.FP( output = formula1[2], 
                     predictors = attr( terms(m1), 'term.labels'),
                     family = family, 
                     data = data, 
                     na.omit = na.omit ) |>
        as.data.frame() |>
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      "" |> (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      # Observation with major influence
      c( "Observation with major influence" ) |> 
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      c( "Number of observations",
         "with a Cook distance",
         "over 4 / N:",
         sum( cooks.distance( m1 ) > 4 / nrow( data ) )
      ) |> 
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      "" |> (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      car::outlierTest( m1) |> 
        capture.output() |> 
        matrix(  ncol = 1) |>
        as.data.frame() |>
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      "" |> (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      "/////////////////////////////////////////////////////" |> 
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
    }
    
    if ( !FULL & ANODE )
    {
      # Anova
      data.frame( Predictors = rownames( anova.corrected1 ), 
                  `Chisq Df` = anova.corrected1$Df,
                  `Residual Df` = m1$df.residual,
                  `LR Chisq` =  IFELSE( is.null( round ), 
                                        anova.corrected1$`LR Chisq`,
                                        round( anova.corrected1$`LR Chisq`, round ) ),
                  `Pr(>Chisq)` =  IFELSE( 
                    is.null( pvalue.round ), 
                    anova.corrected1$`Pr(>Chisq)`,
                    p.round( anova.corrected1$`Pr(>Chisq)`, 
                             pvalue.round ) ) ) |>
        cbind(  `Cohen's f-squared on pseudo-R-squared` = 
                  IFELSE( is.null( round ), 
                          cohen.f2( m1, TRUE, family ),
                          round( cohen.f2( m1, TRUE, family ), 
                                 round ) ) ) |>
        cbind( 
          "-" = "",
          AIC = IFELSE( is.null( round ), 
                        AIC( m1 ),
                        round( AIC( m1 ), round ) ) )-> 
        anova1 ;
      
      rbind.force( c( "Predictors",
                      "Chisq Df", "Residual Df",
                      "LR Chisq", "Pr(>Chisq)",
                      "Cohen's f-squared on pseudo-R-squared",
                      "-",
                      "AIC" ),
                   anova1
      ) -> tmp.anova ;
      
      
      # Extraction
      lapply( 1:length(selected.predictors),  
              function(a){ 
                tmp.anova[ grep( selected.predictors[a],  tmp.anova[,1] ), ] } ) |> 
        (function(x) rbind.force( tmp.anova[1,], x, empty = "" ) )() |>
        unique() ->
        results.tab ;
    }
    
    
    if ( !FULL & !ANODE )
    {
      # Compute output
      data.frame( `Std. Error` =  IFELSE( is.null( round ), 
                                          summary.corrected1[,2],
                                          round( summary.corrected1[,2], round ) ),
                  `z value` =  IFELSE( is.null( round ), 
                                       summary.corrected1[,3],
                                       round( summary.corrected1[,3], round ) ),
                  `Pr(>|z|)` =  IFELSE( is.null( pvalue.round ), 
                                        summary.corrected1[,4],
                                        p.round( summary.corrected1[,4], pvalue.round ) ) ) |>
        (function(x) rbind.force( colnames(summary.corrected1)[-1], x ) )()|>
        (function(x) cbind( confint.corrected1, x ) )() -> 
        tmp.student ;
      
      # Extraction
      lapply( 1:length(selected.predictors),  
              function(a){ 
                tmp.student[ grep( selected.predictors[a],  tmp.student[,1] ), ] } ) |> 
        (function(x) rbind.force( tmp.student[1,], x, empty = "" ) )() |>
        unique() ->
        results.tab ;
    }
    
    
    # output 
    NULL -> rownames( results.tab ) ;
    NULL -> colnames( results.tab ) ;
    
    c( output, list( results.tab = results.tab ) ) -> 
      output ;
    
    return( output )
  }
  
  Multinom.Analysis <- function( outcome, predictors,
                                 data, 
                                 HMF.test = TRUE,
                                 na.omit = TRUE,
                                 FULL = TRUE, 
                                 selected.predictors = NULL,
                                 ANODE = FALSE 
  )
  {
    # Formula
    Formula.Maker( outcome, predictors ) -> 
      formula ;
    
    # model
    if ( na.omit == TRUE ) { na.omit( data ) -> data } 
    
    nnet::multinom( formula, data = data ) -> m1 ;
    
    formula |>
      as.character() ->
      formula2.ch ;
    
    reformulate( paste0( "0 | ", formula2.ch[3]), formula2.ch[2] ) ->
      formula2.new  ;
    
    dfidx::dfidx( data, shape = "wide", choice = formula2.ch[2] ) ->
      data.new ;
    
    mlogit::mlogit( formula2.new, 
                    data = data.new 
    ) -> m1.bis ; 
    
    m1 |> 
      (function(x) list( model = x ) )() -> 
      output ;
    
    m1.bis |> summary() -> summary1 ;
    
    m1.bis |> 
      lmtest::coeftest( 
        vcov. = sandwich::vcovCL( m1.bis,  cluster = data[, cluster.ID] )
      ) -> summary.corrected1 ;
    
    m1.bis |>
      ( function(x)
        cbind( 
          Estimate = summary.corrected1[,1],
          lmtest::coefci( x,
                          vcov. = sandwich::vcovCL( x,  
                                                    cluster = data[, cluster.ID] ),
                          level = conf.level )
        )
      )() |>
      as.data.frame() |>
      exp() |>
      (function(x) IFELSE( is.null( round ),
                           x,
                           round( x, round ) ) )() |>
      (function(x) cbind( Predictors = rownames(x), x ) )() |>
      (function(x) rbind.force( colnames(x), x ) )() -> 
      confint.corrected1 ;
    
    confint.corrected1[1,2:4] <- c( "exp(Estimate)", 
                                    paste0("exp(", 
                                           (1 - conf.level ) / 2 * 100,
                                           "%CI)"),
                                    paste0("exp(", 
                                           100 - (1 - conf.level ) / 2 * 100,
                                           "%CI)")
    ) ;
    
    m1 |>
      ( function(x) {
        car::Anova( x,
                    type = "3",
                    vcov. = sandwich::vcovCL(m1.bis,  # ATTENTION m1.bis
                                             cluster = data[, cluster.ID] )
        ) 
      }
      )() ->
      anova.corrected1 ;
    
    # prepare results 
    if (FULL)
    {
      # formula
      "Model:" -> results.tab ;
      
      formula |> 
        deparse() |> 
        (function(x) rbind.force( results.tab, x, empty = "" )
        )() -> results.tab ;
      
      "" |> (function(x) rbind.force( results.tab, x, empty = "" ) 
      )() -> results.tab ;
      
      # missing data
      c( "Observations deleted due to missingness:",
         dim( data )[1] - dim( m1$residuals )[1] ) |> 
        (function(x) rbind.force( results.tab, x, empty = "" ) 
        )() -> results.tab ;
      
      "" |> (function(x) rbind.force( results.tab, x, empty = "" ) 
      )() -> results.tab ;
      
      #  slopes and t.tests
      "Model coefficients and t-tests" |> 
        (function(x) rbind.force( results.tab, x, empty = "" )
        )() -> results.tab ;
      
      summary.corrected1[,2:3] |> 
        (function(x) IFELSE( is.null( round ),
                             x,
                             round( x, round ) ) )() |>
        (function(x) cbind( x, 
                            "Pr(>|t|)" = IFELSE(
                              is.null( pvalue.round ),
                              summary.corrected1[,4],
                              p.round( summary.corrected1[,4], 
                                       pvalue.round ) )
        ) )() |>
        (function(x) rbind.force( colnames(x), x ) )() |>
        (function(x) cbind( confint.corrected1, x) )() |>
        (function(x) rbind.force( results.tab, x, empty = "" )
        )() -> results.tab ;
      
      "" |> (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      c( "Number of Coefficients:", dim(summary1$standard.errors)[1] * dim(summary1$standard.errors)[2] ) |> 
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      "" |> (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      # Anova
      anova.corrected1 |>
        (function(x) cbind( Predictors = rownames(x), x ) )()|>
        dplyr::transmute( Predictors = Predictors,
                          `LR Chisq` =  IFELSE( is.null( round ), 
                                                `LR Chisq`,
                                                round( `LR Chisq`, round ) ),
                          `Chisq Df` = Df,
                          `Residual Df` = dim( m1$residuals)[1] - 
                            length(summary1$coefficients),
                          `Pr(>Chisq)` =  IFELSE( is.null( pvalue.round ), 
                                                  `Pr(>Chisq)`,
                                                  p.round( `Pr(>Chisq)`, pvalue.round ) ) ) |>
        cbind(   `Cohen's f-squared on pseudo-R-squared` =  IFELSE( is.null( round ), 
                                                                    cohen.f2( m1, TRUE ),
                                                                    round( cohen.f2( m1, TRUE ), 
                                                                           round ) ) ) |>
        cbind(  
          "-" = "",
          AIC = IFELSE( is.null( round ), 
                        AIC( m1 ),
                        round( AIC( m1 ), round ) )) ->
        anova1 ;
      
      rbind.force( colnames(anova1),
                   anova1,
                   empty = "" ) ->
        tmp.anova ;
      
      "ANODE (type 3 tests)" |> 
        (function(x) rbind.force( results.tab, x, empty = "" ) 
        )() -> results.tab ;
      
      tmp.anova |>
        (function(x) rbind.force( results.tab, x, empty = "" ) 
        )() -> results.tab ;
      
      "" |> (function(x) rbind.force( results.tab, x, empty = "" ) 
      )() -> results.tab ;
      
      # Models infos
      c( "Multiple Cox an Snell pseuod-R-squared:", 
         IFELSE( is.null( round ), 
                 MuMIn::r.squaredLR( m1, stats::update( m1, 
                                                 reformulate( "1" ) ) )[1],
                 round( MuMIn::r.squaredLR( m1, 
                                            stats::update( m1, reformulate( "1" ) ) )[1], 
                        round ) ),
         "Nagelkerke Adjusted pseudo-R-squared:", 
         IFELSE( is.null( round ), 
                 attr( MuMIn::r.squaredLR( m1, 
                                           stats::update( m1, reformulate( "1" ) ) ),
                       "adj.r.squared"),
                 round( attr( MuMIn::r.squaredLR( m1, 
                                                  stats::update( m1, reformulate( "1" ) ) ),
                              "adj.r.squared"), 
                        round ) ) ) |> 
        (function(x) rbind.force( results.tab, x, empty = "" ) 
        )() -> results.tab ;
      
      c( "AIC:", 
         IFELSE( is.null( round ), 
                 AIC(m1),
                 round( AIC(m1), round ) ),
         "AICc:", 
         IFELSE( is.null( round ), 
                 MuMIn::AICc(m1),
                 round( MuMIn::AICc(m1), round ) ) ) |> 
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      "" |> (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      # post hoc analysis with no plots
      
      #  Multicollinearity
      c( "Multicollinearity check" ) |> 
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      c( "(generalized) Variance Inflation Factors:", "No intercept include for computations: vifs may not be sensible" ) |> 
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      if ( length( attr( terms( formula ),"term.labels" ) ) == 1 )
      {
        data.frame( "no possible because just 1 predictor" ) -> tmp.mc ;
      } else
      {
        "" -> tmp.mc
        # vif
        car::vif( m1 ) |>
          (function(x) IFELSE( is.null( round ), 
                               x,
                               round( x, round ) ) )() |>
          as.data.frame() |>
          (function(x)  cbind( Predictors = rownames(x), x ) )() -> 
          tmp.vif ;
        
        if ( ncol( tmp.vif ) == 2 ) { "VIF" -> colnames( tmp.vif )[2] }
        
        tmp.vif |>
          (function(x) rbind.force( colnames(x), x ) )() |>
          (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
        "" |> (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
        
        # besley
        attr( terms( m1 ),"term.labels" ) -> Vars
        base::subset( data, 
                      select = Vars[ 
                        !( Vars  %in% Vars[ grep( ":", Vars ) ] ) ] ) |>
          dplyr::select_if( is.numeric ) ->
          data2 
        
        VisCollin::colldiag( mod = nnet::multinom(
          reformulate( colnames(data2),
                       as.character(formula)[2] ),
          data = data,
          model = T ), 
          scale = FALSE, 
          center = FALSE, add.intercept = T ) -> 
          besley
        
        "Belsley criteria (computed on numeric predictors only):" |> (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
        data.frame( besley$condindx, besley$pi ) |>
          (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
        "" |> (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      }
      
      tmp.mc |>
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      "" |> (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      # Independence of Irrelevant Alternatives assumption : Hauslab-McFadden test
      c( "Independence of Irrelevant Alternatives assumption" ) |> 
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      if ( HMF.test )
      {
        c( "Hauslab-McFadden test:" ) |> 
          (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
        
        hmftest.systematic( formula, data ) |>
          data.frame() |>
          (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ; 
        
        "" |> (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      }
      
      c( "Substracting each levels of outcome:" ) |> 
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      Multinomial.SubsetLevels( formula, data, round = round ) |>
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      "" |> (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      "/////////////////////////////////////////////////////" |> 
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
    }
    
    if ( !FULL & ANODE )
    {
      # Anova
      anova.corrected1 |>
        (function(x) cbind( Predictors = rownames(x), x ) )()|>
        dplyr::transmute( Predictors = Predictors,
                          `Chisq Df` = Df,
                          `Residual Df` = dim( m1$residuals)[1] - 
                            length(summary1$coefficients),
                          `LR Chisq` =  IFELSE( is.null( round ), 
                                                `LR Chisq`,
                                                round( `LR Chisq`, round ) ),
                          `Pr(>Chisq)` =  IFELSE( is.null( pvalue.round ), 
                                                  `Pr(>Chisq)`,
                                                  p.round( `Pr(>Chisq)`, pvalue.round ) ) ) |>
        cbind(   `Cohen's f-squared on pseudo-R-squared` =  IFELSE( is.null( round ), 
                                                                    cohen.f2( m1, TRUE ),
                                                                    round( cohen.f2( m1, TRUE ), 
                                                                           round ) ) ) |>
        cbind(  
          "-" = "",
          AIC = IFELSE( is.null( round ), 
                        AIC( m1 ),
                        round( AIC( m1 ), round ) )) ->
        anova1 ;
      
      rbind.force( colnames(anova1),
                   anova1,
                   empty = "" ) ->
        tmp.anova ;
      
      # Extraction
      lapply( 1:length(selected.predictors),  
              function(a){ 
                tmp.anova[ grep( selected.predictors[a],  tmp.anova[,1] ), ] } ) |> 
        (function(x) rbind.force( tmp.anova[1,], x, empty = "" ) )() |>
        unique() ->
        results.tab ;
    }
    
    
    if ( !FULL & !ANODE )
    {
      #  slopes and t.tests
      summary.corrected1[,2:3] |> 
        (function(x) IFELSE( is.null( round ),
                             x,
                             round( x, round ) ) )() |>
        (function(x) cbind( x, 
                            "Pr(>|t|)" = IFELSE(
                              is.null( pvalue.round ),
                              summary.corrected1[,4],
                              p.round( summary.corrected1[,4], 
                                       pvalue.round ) )
        ) )() |>
        (function(x) rbind.force( colnames(x), x ) )() |>
        (function(x) cbind( confint.corrected1, x) )()  -> 
        tmp.student ;
      
      # Extraction
      lapply( 1:length(selected.predictors),  
              function(a){ 
                tmp.student[ grep( selected.predictors[a],  tmp.student[,1] ), ] } ) |> 
        (function(x) rbind.force( tmp.student[1,], x, empty = "" ) )() |>
        unique() ->
        results.tab ;
    }
    
    
    # output 
    NULL -> rownames( results.tab ) ;
    NULL -> colnames( results.tab ) ;
    
    c( output, list( results.tab = results.tab ) ) -> 
      output ;
    
    return( output )
  }
  
  Ordinal.Analysis <- function( outcome, predictors,  
                                data, 
                                na.omit = TRUE,
                                FULL = TRUE, 
                                selected.predictors = NULL,
                                ANODE = FALSE 
  )
  {
    # Formula
    Formula.Maker( outcome, predictors ) -> 
      formula ;
    
    # model
    formula -> formula1 ;
    
    data -> data.clm ;
    
    if ( na.omit == TRUE ) { na.omit( data ) -> data } 
    
    MASS::polr( formula1, data = data, Hess = TRUE ) ->
      m1 ;
    
    try( ordinal::clm( formula1, data = data.clm ), silent = T  ) -> clm1
    
    m1 |> summary() -> summary1 ;
    
    summary1$coefficients |>
      as.data.frame() |>
      (function(x) data.frame( Predictors = rownames(x),
                               Estimate = x$Value,
                               lb = x$Value - qnorm( (1 - conf.level) / 2, lower.tail = FALSE ) * x$`Std. Error`,
                               ub = x$Value + qnorm( (1 - conf.level) / 2, lower.tail = FALSE ) * x$`Std. Error` 
      ) 
      )() -> ci ;
    
    c( paste( (1 - conf.level) / 2 * 100, "%" ),
       paste( (1 -(1 - conf.level) / 2 ) * 100, "%" )  ) ->
      colnames( ci )[3:4] ;
    ci[,1] -> rownames( ci ) ;
    
    ci[,-1] |>
      exp() |>
      (function(x) IFELSE( is.null( round ),
                           x,
                           round( x ) ) )() |>
      as.data.frame() |> 
      (function(x) cbind( Predictors = rownames(x), x ) )() |> 
      (function(x) rbind.force( c( colnames(x)[1], 
                                   paste( "exp of", 
                                          colnames(x)[-1] ) ), 
                                x ) )() -> 
      confint1 ;
    
    # prepare results 
    if (FULL)
    {
      # formula
      "Model:" -> results.tab ;
      
      formula |> 
        deparse() |> 
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      "" |> (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      # missing data
      c( "Observations deleted due to missingness:",
         dim( data )[1] - dim( m1$model )[1] ) |> 
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      "" |> (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      #  slopes and t.tests
      "Model coefficients and t-tests" |> 
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      summary1 |> 
        coef() |>
        as.data.frame() |>  
        dplyr::transmute( `Std. Error` =  IFELSE( is.null( round ), 
                                                  `Std. Error`,
                                                  round( `Std. Error`, round ) ),
                          `--` = "",
                          `z value` =  IFELSE( is.null( round ), 
                                               Value / `Std. Error`,
                                               round( Value / `Std. Error`, round ) ),
                          `Pr(>|z|)` =  IFELSE( is.null( pvalue.round ), 
                                                pnorm( abs( Value / `Std. Error` ), 
                                                       lower.tail = FALSE ) * 2,
                                                p.round( pnorm( abs( Value / `Std. Error` ), 
                                                                lower.tail = FALSE ) * 2,
                                                         pvalue.round ) ) ) |>
        (function(x) rbind.force( colnames(x), x) )()  |>
        (function(x)  cbind( confint1, x )  )() |>
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      "" |> (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      c( "Degrees of freedom:", summary1$df.residual,
         "Number of Coefficients:", length(coef(m1)) + length(m1$zeta) ) |> 
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      "" |> (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      # Anova
      m1 |>
        car::Anova( type = 3) |>
        as.data.frame() |>
        (function(x) cbind( Predictors = rownames(x), x ) )() |>
        dplyr::transmute( Predictors = Predictors,
                          `LR Chisq` =  IFELSE( is.null( round ), 
                                                `LR Chisq`,
                                                round( `LR Chisq`, round ) ),
                          `Chisq Df` = Df,
                          `Residual Df` = m1$df.residual,
                          `--` = "",
                          `Pr(>Chisq)` =  IFELSE( is.null( pvalue.round ), 
                                                  `Pr(>Chisq)`,
                                                  p.round( `Pr(>Chisq)`, pvalue.round ) ) ) |>
        cbind(  `Cohen's f-squared on pseudo-R-squared` =  IFELSE( is.null( round ), 
                                                                   cohen.f2( m1, TRUE ),
                                                                   round( cohen.f2( m1, TRUE ), 
                                                                          round ) ) ) |>
        cbind( 
          `--` = "",
          AIC = IFELSE( is.null( round ), 
                        AIC( m1 ),
                        round( AIC( m1 ), round ) )) ->
        anova1 ;
      
      # fusion anova and CI
      c( confint1[1,], 
         colnames(anova1)[-1] ) |>
        matrix( nrow = 1 ) -> 
        tmp.anova ;
      
      for ( a in as.character(anova1$Predictors) )
      {
        c( confint1[1,], 
           colnames(anova1)[-1] ) |>
          matrix( nrow = 1 ) -> 
          tmp.anova ;
        
        for ( a in as.character(anova1$Predictors) )
        {
          confint1[grep( a, confint1[,1] ) , ] -> tmp.ci1
          
          anova1[grep( a, anova1[,1] ) , ] -> tmp.anova1
          
          if ( !grepl( ":", a ) )
          {
            if ( length( grep( ":", tmp.ci1[,1] ) ) > 0 )
            {
              tmp.ci1[ -grep( ":", tmp.ci1[,1] ) , ] -> tmp.ci1
              
              tmp.anova1[ -grep( ":", 
                                 as.character( tmp.anova1[,1] ) 
              ),  ] -> 
                tmp.anova1
            }
          }
          
          if ( grepl( ":", a ) )
          {
            strsplit( a, ":" ) |>
              unlist() ->
              sub.names.interaction
            
            confint1 -> tmp.ci1
            for ( b in sub.names.interaction )
            {
              tmp.ci1[grep( b, tmp.ci1[,1] ) , ] -> tmp.ci1
            }
          }
          
          cbind.force( tmp.ci1,
                       tmp.anova1[, -1 ],
                       empty = "" ) |>
            (function(x) rbind.force( tmp.anova,
                                      x,
                                      empty = "" ) )() ->
            tmp.anova ;
        }
      }
      
      "ANODE (type 3 tests)" |> 
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      tmp.anova |>
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      "" |> (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      # Models infos
      c( "Multiple Cox an Snell pseuod-R-squared:", 
         IFELSE( is.null( round ), 
                 MuMIn::r.squaredLR( m1, stats::update( m1, reformulate( "1" ) ) )[1],
                 round( MuMIn::r.squaredLR( m1, stats::update( m1, reformulate( "1" ) ) )[1], 
                        round ) ),
         "Nagelkerke Adjusted pseudo-R-squared:", 
         IFELSE( is.null( round ), 
                 attr( MuMIn::r.squaredLR( m1, stats::update( m1, reformulate( "1" ) ) ),
                       "adj.r.squared"),
                 round( attr( MuMIn::r.squaredLR( m1, stats::update( m1, reformulate( "1" ) ) ),
                              "adj.r.squared"), 
                        round ) ) ) |> 
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      c( "AIC:", 
         IFELSE( is.null( round ), 
                 AIC(m1),
                 round( AIC(m1), round ) ),
         "AICc:", 
         IFELSE( is.null( round ), 
                 MuMIn::AICc(m1),
                 round( MuMIn::AICc(m1), round ) ) ) |> 
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      "" |> (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      # post hoc analysis with no plots
      
      #  Multicollinearity
      c( "Multicollinearity check" ) |> 
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      c( "(generalized) Variance Inflation Factors:", "No intercept: vifs may not be sensible" ) |> 
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      if ( length( attr( terms( formula ),"term.labels" ) ) == 1 )
      {
        data.frame( "no possible because just 1 predictor" ) -> tmp.mc ;
      } else
      {
        "" -> tmp.mc
        # vif
        car::vif( m1 ) |>
          (function(x) IFELSE( is.null( round ), 
                               x,
                               round( round ) ) )() |>
          as.data.frame() |>
          (function(x) cbind( Predictors = rownames(x), x ) )() -> 
          tmp.vif ;
        
        if ( ncol( tmp.vif ) == 2 ) { "VIF" -> colnames( tmp.vif )[2] }
        
        tmp.vif |>
          (function(x) rbind.force( colnames(x), x) )() |>
          (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
        "" |> (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
        
        # besley
        attr( terms( m1 ),"term.labels" ) -> Vars
        subset( data, 
                select = Vars[ 
                  !( Vars  %in% Vars[ grep( ":", Vars ) ] ) ] ) |>
          dplyr::select_if( is.numeric ) ->
          data2 
        
        VisCollin::colldiag( mod = MASS::polr(
          reformulate( colnames(data2),
                       as.character(formula)[2] ),
          data = data ), 
          scale = FALSE, 
          center = FALSE, add.intercept = T ) -> 
          besley
        
        "Belsley criteria (computed on numeric predictors only):" |> (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
        data.frame( besley$condindx, besley$pi) |>
          (function(x) rbind( colnames(x), x ) )() |>
          (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
        "" |> (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
        
      }
      
      tmp.mc |>
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      "" |> (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      # Proportional odds assumptions
      c( "Proportional odds assumption" ) |> 
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      c( "Test of Brant:" ) |> 
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      if ( length( grep( ":", attr( terms( m1 ), "term.labels" ) ) ) == 0 &
           length( attr( terms( m1 ), "term.labels" )  ) > 1)
      {
        brant.perso(m1) |> 
          as.matrix() |> 
          (function(x) data.frame( rownames(x), x) )() |>
          setNames( c( "Predictors", "Chisq", "df", "p" ) ) |> 
          (function(x) data.frame( Predictors = x$Predictors, "Chisq" = IFELSE( is.null(round), 
                                                                                x[,"Chisq"], 
                                                                                round( x[,"Chisq"], round) ),
                                   "p" = IFELSE( is.null( pvalue.round ), 
                                                 x[,"p"], 
                                                 p.round( x[,"p"], pvalue.round ) )
          ) )() |> 
          (function(x) rbind( colnames(x), x ) )() |> 
          (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
        "" |> (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      } else
      {
        "test is not applicable because presence of interacions or because just 1 predictor" |> 
          (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
        "" |> (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      }
      
      c( "Nominal test:" ) |> 
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      if (attr( clm1,"class") == "try-error" )
      {
        "Nominal test not computable" -> output ; 
      } else
      {
        nominal_test.perso( clm1, formula1, data.clm ) |>
          setNames( c( "Predictors", "Df", "logLik", "AIC", "LRT", "Pr(>Chi)" ) ) |> 
          (function(x) data.frame( "logLik" = IFELSE( is.null(round), 
                                                      x[,"logLik"], 
                                                      round( x[,"logLik"], round) ),
                                   "AIC" = IFELSE( is.null(round), 
                                                   x[,"AIC"], 
                                                   round( x[,"AIC"], round) ),
                                   "LRT" = IFELSE( is.null(round), 
                                                   x[,"LRT"], 
                                                   round( x[,"LRT"], round) ),
                                   "Pr(>Chi)" = IFELSE( is.null( pvalue.round ), 
                                                        x[,"Pr(>Chi)"], 
                                                        p.round( x[,"Pr(>Chi)"], pvalue.round ) )
          ) )() |> 
          (function(x) rbind( colnames(x), x ) )() |> 
          (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      }
      
      
      "" |> (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      "/////////////////////////////////////////////////////" |> 
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
    }
    
    if ( !FULL & ANODE )
    {
      # Anova
      m1 |>
        car::Anova( type = 3) |>
        as.data.frame() |>
        (function(x) cbind( Predictors = rownames(x), x ) )() |>
        dplyr::transmute( Predictors = Predictors,
                          `LR Chisq` =  IFELSE( is.null( round ), 
                                                `LR Chisq`,
                                                round( `LR Chisq`, round ) ),
                          `Chisq Df` = Df,
                          `Residual Df` = m1$df.residual,
                          `--` = "",
                          `Pr(>Chisq)` =  IFELSE( is.null( pvalue.round ), 
                                                  `Pr(>Chisq)`,
                                                  p.round( `Pr(>Chisq)`, pvalue.round ) ) ) |>
        cbind(  `Cohen's f-squared on pseudo-R-squared` =  IFELSE( is.null( round ), 
                                                                   cohen.f2( m1, TRUE ),
                                                                   round( cohen.f2( m1, TRUE ), 
                                                                          round ) ) ) |>
        cbind( 
          `--` = "",
          AIC = IFELSE( is.null( round ), 
                        AIC( m1 ),
                        round( AIC( m1 ), round ) )) ->
        anova1 ;
      
      # fusion anova and CI
      c( confint1[1,], 
         colnames(anova1)[-1] ) |>
        matrix( nrow = 1 ) -> 
        tmp.anova ;
      
      for ( a in as.character(anova1$Predictors) )
      {
        c( confint1[1,], 
           colnames(anova1)[-1] ) |>
          matrix( nrow = 1 ) -> 
          tmp.anova ;
        
        for ( a in as.character(anova1$Predictors) )
        {
          confint1[grep( a, confint1[,1] ) , ] -> tmp.ci1
          
          anova1[grep( a, anova1[,1] ) , ] -> tmp.anova1
          
          if ( !grepl( ":", a ) )
          {
            if ( length( grep( ":", tmp.ci1[,1] ) ) > 0 )
            {
              tmp.ci1[ -grep( ":", tmp.ci1[,1] ) , ] -> tmp.ci1
              
              tmp.anova1[ -grep( ":", 
                                 as.character( tmp.anova1[,1] ) 
              ),  ] -> 
                tmp.anova1
            }
          }
          
          if ( grepl( ":", a ) )
          {
            strsplit( a, ":" ) |>
              unlist() ->
              sub.names.interaction
            
            confint1 -> tmp.ci1
            for ( b in sub.names.interaction )
            {
              tmp.ci1[grep( b, tmp.ci1[,1] ) , ] -> tmp.ci1
            }
          }
          
          cbind.force( tmp.ci1,
                       tmp.anova1[, -1 ],
                       empty = "" ) |>
            (function(x) rbind.force( tmp.anova,
                                      x,
                                      empty = "" ) )() ->
            tmp.anova ;
        }
      }
      
      # Extraction
      lapply( 1:length(selected.predictors),  
              function(a){ 
                tmp.anova[ grep( selected.predictors[a],  tmp.anova[,1] ), ] } ) |> 
        (function(x) rbind.force( tmp.anova[1,], x, empty = "" ) )() |>
        unique() ->
        results.tab ;
    }
    
    if ( !FULL & !ANODE )
    {
      # Compute output
      summary1 |> 
        coef() |>
        as.data.frame() |>  
        (function(x) data.frame( `Std. Error` =  IFELSE( is.null( round ), 
                                                         x$`Std. Error`,
                                                         round( x$`Std. Error`, round ) ),
                                 `--` = "",
                                 `z value` =  IFELSE( is.null( round ), 
                                                      x$Value / x$`Std. Error`,
                                                      round( x$Value / x$`Std. Error`, round ) ),
                                 `Pr(>|z|)` =  IFELSE( is.null( pvalue.round ), 
                                                       pnorm( abs( x$Value / x$`Std. Error` ), 
                                                              lower.tail = FALSE ) * 2,
                                                       p.round( pnorm( abs( x$Value / x$`Std. Error` ), 
                                                                       lower.tail = FALSE ) * 2,
                                                                pvalue.round ) ) ) )() |>
        (function(x) rbind.force( colnames(x), x) )()  |>
        (function(x) cbind( confint1, x ) )()  -> 
        tmp.student ;
      
      # Extraction
      lapply( 1:length(selected.predictors),  
              function(a){ 
                tmp.student[ grep( selected.predictors[a],  tmp.student[,1] ), ] 
              } ) |> 
        (function(x) rbind.force( tmp.student[1,], x, empty = "" ) )() |>
        unique() ->
        results.tab ;
    }
    
    
    # output 
    NULL -> rownames( results.tab ) ;
    NULL -> colnames( results.tab ) ;
    
    list( model = m1,  results.tab = results.tab  ) -> 
      output ;
    
    return( output )
  }
  
  Lm.Plot <- function( model, ExportName )
  {
    # Pair graphics on variables 
    pairs2( subset( model$model, select = 1), 
            subset( model$model, select = -1), 
            ExportName, 4 )
    
    # Terms plot
    if ( length( attr( terms(model),"term.labels") ) < 7 &
         all( !grepl( ":", attr( terms(model),"term.labels") ) ) )
    {
      termplot2( model, ExportName) ;
    }
    
    # Normality Study
    png( paste( ExportName,
                "Normality_Study_of_Studendized_Residuals",
                ".png",
                sep = "" ) )
    MASS::studres( model ) |> Normality.Plot.Unique( "Studendized Residuals") ;
    dev.off() ;
    
    # Residuals vs IV
    residualPlots2( model, ExportName ) ;
    
    # Added variables plot 
    avPlots2( model, ExportName) ;
    
    # Residuals vs Fitted
    png( paste( ExportName,
                "Residuals_vs_Fitted",
                ".png",
                sep = "" ),
         width = 270,
         height = 600 )
    par( mfrow = c( 3, 1), oma = c( 0, 0, 2, 0) )
    plot( model , c(1), ask = FALSE, sub.caption = "")
    car::residualPlot( model, type = "rstandard", col.quad = "red", 
                       ylab = "Standardized reisudals",
                       main = "Standardized residual vs Fitted")
    plot( model , c(3), ask = FALSE, sub.caption = "")
    mtext( text =  "Residuals vs Fitted Graphics", 
           outer = TRUE, cex = 1.5 ) ;
    dev.off() ;
    
    # Component + residuals  plot 
    if ( all( !grepl( ":", attr( terms(model),"term.labels") ) ) )
    {
      crPlots2( model, ExportName )
    }
    
    #  Cook's distance and Leverage graphics 
    png( paste( ExportName,
                "Cooksdistance_and_Leverage_Graphics",
                ".png",
                sep = "" ),
         width = 270,
         height = 600 )
    par( mfrow = c( 3, 1), oma = c( 0, 0, 2, 0) )
    plot( model , c(5:6), ask = FALSE, sub.caption = "")
    dotchart( sort( sort( cooks.distance( model ), decreasing = T )[1:15] ), 
              main = "Top 15 Cook's distances", 
              xlab = "Cook distance", 
              sub = paste( "cutoff:", 
                           round( 4 / (length( cooks.distance( model ) ) ), 2 ) ) )
    abline( v = 4 / (length( nrow( model$model ) ) ), 
            col = "red" )
    mtext( text =  "Cook's distance and Leverage Graphics", 
           outer = TRUE, cex = 1.2 ) ;
    dev.off() ;
    
    # Influences graphics 
    png( paste( ExportName,
                "Influence_Plots",
                ".png",
                sep = "" ) )
    car::infIndexPlot( model, main =  "Influence Index Plot" )
    dev.off() ;
  }
  
  Glm.Plot <- function( model, ExportName )
  {
    # Pair graphics on variables 
    data.frame( model$fitted.values ) |>
      magrittr::set_colnames( paste( "fitted.LogOR",
                                     as.character( terms(model) )[2],
                                     sep = ".")  ) |>
      pairs2( 
        subset( model$model, select = -1), 
        ExportName, 4 )
    
    # Terms plot
    if ( length( attr( terms(model),"term.labels") ) < 7  &
         all( !grepl( ":", attr( terms(model),"term.labels") ) ) )
    {
      termplot2(model, ExportName )
    }
    
    # Added variables plot 
    model |> avPlots2( ExportName) ;
    
    # Compornent + residuals  plot 
    if ( all( !grepl( ":", attr( terms(model),"term.labels") ) ) )
    {
      crPlots2( model, ExportName )
    }
    
    # Residuals vs Fitted
    png( paste( ExportName,
                "Residuals_vs_Fitted",
                ".png",
                sep = "" ),
         width = 270,
         height = 600 )
    par( mfrow = c( 3, 1), oma = c( 0, 0, 2, 0) )
    plot( model , c(1), ask = FALSE, sub.caption = "")
    car::residualPlot( model, col.quad = "red")
    plot( model$fitted.values,
          sqrt( abs( residuals( model, type = "pearson" ) ) ),
          ylab = "sqrt( | Pearson's reisduals | )",
          xlab =  "Fitted values",
          main = "Scale-Location"
    )
    car::loessLine( model$fitted.values,
                    sqrt( abs( residuals( model, type = "pearson" ) ) ),
                    col = "red" )
    mtext( text =  "Residuals vs Fitted Graphics", 
           outer = TRUE, cex = 1.5 ) ;
    dev.off() ;
    
    #  Cook's distance and Leverage graphics 
    png( paste( ExportName,
                "Cooksdistance_and_Leverage_Graphics",
                ".png",
                sep = "" ),
         width = 270,
         height = 600 )
    par( mfrow = c( 3, 1), oma = c( 0, 0, 2, 0) )
    plot( model , c(5:6), ask = FALSE, sub.caption = "")
    dotchart( sort( sort( cooks.distance( model ), decreasing = T )[1:15] ), 
              main = "Top 15 Cook's distances", 
              xlab = "Cook distance", 
              sub = paste( "cutoff:", 
                           round( 4 / (length( cooks.distance( model ) ) ), 2 ) ) )
    abline( v = 4 / (length( cooks.distance( model ) ) ), 
            col = "red" )
    mtext( text =  "Cook's distance and Leverage Graphics", 
           outer = TRUE, cex = 1.2 ) ;
    dev.off() ;
    
    # Influences graphics 
    png( paste( ExportName,
                "Influence_Plots",
                ".png",
                sep = "" ) )
    car::infIndexPlot( model )
    dev.off() ;
  }
  
  Multinom.Plot <- function( model, data, ExportName )
  {
    # Pair graphics on variables 
    attr( terms( model ),"term.labels" ) -> Vars
    
    data.frame( model$fitted.values ) |>
      (function(x) magrittr::set_colnames( x, paste( "fitted.LogOR",
                                                     colnames(x),
                                                     sep = ".")  ) )() |>
      pairs2( 
        data.frame(
          subset( data, 
                  select = Vars[ 
                    !( Vars  %in% Vars[ grep( ":", Vars ) ] ) ] )), 
        ExportName, 2 )
    
    # Residuals vs Fitted
    model$fitted.values |>
      as.data.frame() |>
      tidyr::gather( key = Levels, value = Fitted  ) -> 
      Fitted1 ;
    
    model$residuals |>
      as.data.frame() |>
      tidyr::gather( key = levels1, value = Residuals  ) |>
      dplyr::select( -levels1 ) -> 
      Resid1 ;
    
    cbind( Fitted1, Resid1 ) |> 
      ggplot() +
      geom_point( aes( x = Fitted, y = Residuals ) ) +
      facet_grid( . ~ Levels, scales = "free" ) +
      labs( title = "Residuals vs Fitted for cumulative link models" ) -> 
      g1 ;
    
    paste( ExportName,
           "Residuals_vs_Fitted",
           ".png",
           sep = "" ) |>
      ggsave( g1, width = 8, height = 3 ) ;
  }
  
  Ordinal.Plot <- function( model, ExportName )
  {
    # Pair graphics on variables 
    data.frame( model$fitted.values ) |>
      (function(x) magrittr::set_colnames( x, paste( "fitted.LogOR",
                                                     colnames(x),
                                                     sep = ".")  ) )() |>
      pairs2( 
        subset( model$model, select = -1), 
        ExportName, 2 )
    
    # Residuals vs Fitted
    model$fitted.values |>
      as.data.frame() |>
      tidyr::gather( key = Levels, value = Fitted  ) -> 
      Fitted1 ;
    
    model |>
      residuals.polr() |>
      as.data.frame() |>
      tidyr::gather( key = levels1, value = Residuals  ) |>
      dplyr::select( -levels1 ) -> 
      Resid1 ;
    
    cbind( Fitted1, Resid1 ) |> 
      ggplot() +
      geom_point( aes( x = Fitted, y = Residuals ) ) +
      facet_grid( . ~ Levels, scales = "free" ) +
      labs( title = "Residuals vs Fitted for the cumulative link models" ) -> 
      g1 ;
    
    paste( ExportName,
           "Residuals_vs_Fitted",
           ".png",
           sep = "" ) |>
      ggsave( g1, width = 8, height = 3 ) ;
  }
  
  fun.a <- function( a )
  {
    
    lapply( 1:length( changing.predictors ),
            fun.b,
            a = a ) |>
      rbind.force(
        empty = "" ) ->
      output.a
    
    return( output.a )
  }
  
  fun.a.parallel <- function( a )
  {
    
    furrr::future_map( 1:length( changing.predictors ),
                       fun.b,
                       a = a,
                       .options = furrr::furrr_options(seed = TRUE), .progress = T 
    ) |>
      rbind.force(
        empty = "" ) ->
      output.a
    
    return( output.a )
  }
  
  fun.b <- function( b, a )
  {
    #print( "a : ") ;  print( a ); print( "b : ") ; print(b)
    
    # Prepare base name for graphics
    paste0( ExportName,
            families[a], "_",
            outcomes[[a]],
            "_Model_",
            b,
            "_"
    ) -> BasePlotName ;
    
    # Do job selecting modeling family
    if ( families[a] == "gaussian" )
    {
      Lm.Analysis(  outcome = outcomes[[a]],
                    predictors = c( changing.predictors[[b]],
                                    fixed.predictors ),
                    data = data, 
                    na.omit = na.omit,
                    FULL = FULL, 
                    selected.predictors = changing.predictors[[b]],
                    ANOVA = ANOVA.ANODE ) -> 
        tmp.output
      
      if ( PLOT )
      {
        Lm.Plot( tmp.output$model,
                 BasePlotName )
      }
    }
    
    if ( families[a] %in%  c( "binomial", "poisson", "quasibinomial", "quasipoisson" ) )
    {
      Glm.Analysis(  outcome = outcomes[[a]],
                     predictors = c( changing.predictors[[b]],
                                     fixed.predictors ),
                     family = families[a],
                     data = data, 
                     na.omit = na.omit,
                     FULL = FULL, 
                     selected.predictors = changing.predictors[[b]],
                     ANODE = ANOVA.ANODE ) -> 
        tmp.output
      
      if ( PLOT )
      {
        Glm.Plot( tmp.output$model,
                  BasePlotName )
      }
    }
    
    if ( families[a] == "multinomial" )
    {
      Multinom.Analysis(  outcome = outcomes[[a]],
                          predictors = c( changing.predictors[[b]],
                                          fixed.predictors ),
                          data = data, 
                          HMF.test = HMF.test,
                          na.omit = na.omit,
                          FULL = FULL, 
                          selected.predictors = changing.predictors[[b]],
                          ANODE = ANOVA.ANODE ) -> 
        tmp.output
      
      if ( PLOT )
      {
        Multinom.Plot( tmp.output$model,
                       data = data,
                       BasePlotName )
      }
    }
    
    if ( families[a] == "ordinal" )
    {
      Ordinal.Analysis(  outcome = outcomes[[a]],
                         predictors = c( changing.predictors[[b]],
                                         fixed.predictors ),
                         data = data, 
                         na.omit = na.omit,
                         FULL = FULL, 
                         selected.predictors = changing.predictors[[b]],
                         ANODE = ANOVA.ANODE ) -> 
        tmp.output
      
      if ( PLOT )
      {
        Ordinal.Plot( tmp.output$model,
                      BasePlotName )
      }
    }
    
    # output
    tmp.output$results.tab -> output.b ;
    
    cbind( Outcome = outcomes[[a]], 
           Families = families[a],
           Predictors = String.Contatener( c( changing.predictors[[b]],
                                              fixed.predictors),
                                           separator = "." ),
           output.b ) -> 
      output.b ;
    
    return( output.b )
  }
  
  # Active Packages 
  download.packages( "furrr", "nnet", "MASS", "ordinal",
                     "MuMIn", "car", "sandwich",
                     "heplots", "lmtest", "mfp", 
                     "moments", "nortest", "dplyr", "tidyr", 
                     "magrittr",
                     "ggplot2", "mlogit", "dfidx", "brant", 
                     "VisCollin",
                     "mctest", "ggplot2" )
  
  require( ggplot2 )
  
  # NA
  if ( na.omit == TRUE ) { na.omit( data ) -> data } 
  
  # job
  if ( parallel.outcomes )
  {
    furrr::future_map(
      1:length( outcomes  ), 
      fun.a,
      .options = furrr::furrr_options(seed = TRUE), .progress = T 
    ) |>
      rbind.force( 
        empty = "" ) -> 
      output ;
  }
  else
  {
    purrr::map(
      1:length( outcomes  ), 
      fun.a.parallel
    ) |>
      rbind.force( 
        empty = "" ) -> 
      output ;
  }
  
  # end parallel
  future::plan("sequential")
  
  # Output 
  return( output )
}

Multiple.Regressions.ClusterRobust.weighted <- function( 
    data,
    cluster.ID = "",
    weights,
    na.omit = TRUE,
    outcomes, 
    families,
    changing.predictors,
    fixed.predictors = "",
    FULL = TRUE,
    ANOVA.ANODE = TRUE,
    HMF.test = TRUE,
    conf.level = 0.95,
    pvalue.round = 3,
    round = 2,
    PLOT = FALSE, 
    ExportName = paste( getwd(),
                        "/",
                        sep = ""), 
    parallel.outcomes = TRUE,
    ncores = NULL
)
{
  # input quality controls 
  if ( !is.data.frame( data ) ) { stop ( "data is not of dataframe type" ) } ;
  if ( any( is.na( data ) ) ) { warning( "data countains NA" ) } ;
  if ( tibble::is_tibble( data ) ) { data.frame( data ) -> data ; }
  if ( cluster.ID == "" ) { warning( "cluster var must be defined" ) } ;
  if ( !is.numeric( weights ) ) { stop( "weights is not a vector of numeric type" ) } ;
  if ( !is.logical( na.omit ) ) { stop( "na.omit is not a logical" ) } ;
  if ( !is.list( outcomes ) ) { stop( "outcomes is not a list" ) } ;
  if ( !is.character( unlist( outcomes ) ) ) { stop( "outcomes doesn't countain character" ) } ;
  if ( !is.character( families ) ) { stop( "families is not a vector of character type" ) } ;
  if ( !all( families %in% c( "multinomial", "gaussian", "binomial", "poisson", "quasibinomial", "quasipoisson" ) ) ) 
  { stop( "families contains a non supported distribution" ) } ;
  if ( !is.list( changing.predictors ) ) { stop( "changing.predictors is not a list" ) } ;
  if ( !is.character( unlist( changing.predictors ) ) ) { stop( "changing.predictors doesn't countain character" ) } ;
  if ( !is.character( fixed.predictors ) ) { stop( "fixed.predictors is not a vector of character type" ) } ;
  if ( !is.logical( FULL ) ) { stop( "FULL is not a logical" ) } ;
  if ( !is.logical( ANOVA.ANODE ) ) { stop( "ANOVA.ANODE is not a logical" ) } ;
  if ( !is.logical( HMF.test ) ) { stop( "HMF.test is not a logical" ) } ;
  if ( !is.numeric( conf.level ) ) { stop( "conf.level is not numeric" ) } ;
  if ( !( is.numeric( pvalue.round ) | 
          is.null( pvalue.round ) ) ) { stop( "pvalue.round is neither numeric, neither NULL" );    } ;
  if ( !( is.numeric( round ) | 
          is.null( round ) ) ) { stop( "round is neither numeric, neither NULL" );    } ;
  if ( !is.logical( PLOT ) ) { stop( "PLOT is not a logical" ) } ;
  if ( !is.character( ExportName ) ) { stop( "ExportName is not a vector of character type" ) } ;
  if ( !is.logical( parallel.outcomes ) ) { stop( "parallel.outcomes is not a logical" ) } ;
  if ( !is.null(ncores) & !is.numeric(ncores) ) { stop( "ncores is not null nor numeric" ) }
  
  # Message
  print( "Clustered sandwich estimators are used to adjust inference when errors are correlated within (but not between) clusters. \n Cameron AC, Gelbach JB, Miller DL (2011). “Robust Inference with Multiway Clustering”, Journal of Business & Ecomomic Statistics, 29(2), 238–249. doi:10.1198/jbes.2010.07136 \n HC1 for lm objects and HC0 otherwise ; HC0: original White-corrected coefficient covariance matrix ; White, H. (1980) A heteroskedastic consistent covariance matrix estimator and a direct test of heteroskedasticity. Econometrica 48, 817–838. ; HC1: Long, J. S. and Ervin, L. H. (2000) Using heteroscedasity consistent standard errors in the linear regression model. The American Statistician 54, 217–224. ")
  
  # Inactive
  
  # parallel
  if ( !is.null( ncores ) ) { future::plan( "multisession",  workers = ncores ) }
  
  # Domestic functions
  download.packages <- function( PackagesNames, ... )
  {
    # Get a vector with packages names 
    packages1 <- c( PackagesNames, ... ) ;
    
    # Install packages
    for (a in 1:length( packages1 ) )
    {
      try( find.package( packages1[a]), silent = TRUE ) -> test ;
      
      if ( class( test ) == "try-error" )
      { print( packages1[a] ) ; 
        install.packages(  packages1[a] ) ;
      } 
    }
  } ;
  
  rbind.force <- function( data, ..., keep.col = FALSE, empty = NA ) 
  {
    # Unify data
    list( data, ... ) -> input ;
    
    # include list elements
    repeat 
    {
      if (  !any( unlist( lapply( input, class ) ) == "list" ) ) { break }  
      
      which( unlist( lapply( input, class ) ) == "list" )[1] -> a ;
      input[[a]] -> tmp ;
      input[[a]] <- NA ;
      c( input[1:a],  tmp, input[ (a + 1):length( input ) ] ) -> 
        input ;
    }
    
    input[ !is.na( input ) ] ->
      input ;
    
    # delete NULL data and transformt vector in data.frame
    for ( a in 1:length( input ) )
    {
      if ( is.null( dim( input[[a]] ) ) )
      {
        if ( is.null( input[[a]] ) )
        {
          input[[a]] <- NA ;
        } else
        {
          data.frame( matrix( input[[a]], nrow = 1 ),
                      stringsAsFactors = FALSE ) -> input[[a]] ; 
        }
      }
      
      if ( all( dim( input[[a]] ) == 0 ) )
      {
        input[[a]] <- NA ;
      }
    }
    
    input[ !is.na( input ) ] ->
      input ;
    
    # test data class
    if ( !all( unlist( lapply( input, is.data.frame ) ) |
               unlist( lapply( input, is.matrix ) ) |
               unlist( lapply( input, is.vector ) ) ) )
    { stop( "Some argument are not data.frame, neither vector" ) ;
      ; } ;
    
    # Set primer
    input[[1]] -> output ; 
    
    # job in case we keep columns 
    if ( keep.col & length( input ) >1 )
    {
      for ( a in 2:length( input ) )
      { 
        output -> x ;
        input[[a]] -> y ; 
        
        for (a in 1:dim(x)[2]) { x[,a] <- as.character(x[,a])}
        for (a in 1:dim(y)[2]) { y[,a] <- as.character(y[,a])}
        
        x.diff <- setdiff(colnames(x), colnames(y))
        y.diff <- setdiff(colnames(y), colnames(x))
        
        if( dim(x)[1] > 0 ) { x[, c(as.character(y.diff))] <- empty ; }
        if( dim(y)[1] > 0 ) { y[, c(as.character(x.diff))] <- empty ; }
        
        rbind(x, y) -> output ;
      } 
    }
    
    # job in case we do not keep columns
    if ( !keep.col & length( input ) >1 )
    {
      for ( a in 2:length( input ) )
      { 
        output -> x ;
        input[[a]] -> y ; 
        
        colnames(x) <- paste( "X",
                              1:dim( x )[2], 
                              sep = "" ) ;
        colnames(y) <- paste( "X",
                              1:dim( y )[2], 
                              sep = "" ) ;
        
        for (a in 1:dim(x)[2]) { x[,a] <- as.character(x[,a])}
        for (a in 1:dim(y)[2]) { y[,a] <- as.character(y[,a])}
        
        x.diff <- setdiff(colnames(x), colnames(y))
        y.diff <- setdiff(colnames(y), colnames(x))
        
        if( dim(x)[1] > 0 ) { x[, c(as.character(y.diff))] <- empty ; }
        if( dim(y)[1] > 0 ) { y[, c(as.character(x.diff))] <- empty ; }
        
        rbind(x, y) -> output ;
      } 
    }
    
    return( output ) ;
  } 
  
  cbind.force <- function( data, ... , keep.row = FALSE, empty = NA ) 
  {
    # Unify data
    list( data, ... ) -> input ;
    
    # include list elements
    repeat 
    {
      if (  !any( unlist( lapply( input, class ) ) == "list" ) ) { break }  
      
      which( unlist( lapply( input, class ) ) == "list" )[1] -> a ;
      input[[a]] -> tmp ;
      input[[a]] <- NA ;
      c( input[1:a],  tmp, input[ (a + 1):length( input ) ] ) -> 
        input ;
    }
    
    input[ !is.na( input ) ] ->
      input ;
    
    # delete NULL data and transform vector in data.frame
    for ( a in 1:length( input ) )
    {
      if ( is.null( dim( input[[a]] ) ) )
      {
        if ( is.null( input[[a]] ) )
        {
          input[[a]] <- NA ;
        } else
        {
          data.frame( input[[a]],
                      stringsAsFactors = FALSE ) -> input[[a]] ; 
          "vector" -> colnames(  input[[a]] ) ;
        }
      }
      
      if ( all( dim( input[[a]] ) == 0 ) )
      {
        input[[a]] <- NA ;
      }
    }
    
    input[ !is.na( input ) ] ->
      input ;
    
    # test data class
    if ( !all( unlist( lapply( input, is.data.frame ) ) |
               unlist( lapply( input, is.matrix ) ) |
               unlist( lapply( input, is.vector ) ) ) )
    { stop( "Some argument are not data.frame, neither vector" ) ;
      ; } ;
    
    # Set primer
    input[[1]] -> output ; 
    
    # job in case we keep columns 
    if ( keep.row & length( input ) > 1 )
    {
      for ( a in 2:length( input ) )
      { 
        output -> x ;
        input[[a]] -> y ; 
        
        for (a in 1:dim(x)[2]) { x[,a] <- as.character(x[,a])}
        for (a in 1:dim(y)[2]) { y[,a] <- as.character(y[,a])}
        
        x.diff <- setdiff(rownames(x), rownames(y))
        y.diff <- setdiff(rownames(y), rownames(x))
        
        if( dim(x)[2] > 0 ) { x[ c(as.character(y.diff)), ] <- empty ; }
        if( dim(y)[2] > 0 ) { y[ c(as.character(x.diff)), ] <- empty ; }
        
        cbind(x, y) -> output ;
      } 
    }
    
    # job in case we do not keep columns
    if ( !keep.row & length( input ) > 1 )
    {
      for ( a in 2:length( input ) )
      { 
        output -> x ;
        input[[a]] -> y ; 
        
        if ( dim( x )[1] > 0 ) 
        {
          rownames(x) <- paste( "X",
                                1:dim( x )[1], 
                                sep = "" ) ;
        }
        
        if ( dim( y )[1] > 0 ) 
        {
          rownames(y) <- paste( "X",
                                1:dim( y )[1], 
                                sep = "" ) ;
        }
        
        
        
        for (a in 1:dim(x)[2]) { x[,a] <- as.character(x[,a])}
        for (a in 1:dim(y)[2]) { y[,a] <- as.character(y[,a])}
        
        x.diff <- setdiff(rownames(x), rownames(y))
        y.diff <- setdiff(rownames(y), rownames(x))
        
        if( dim(x)[2] > 0 ) { x[ c(as.character(y.diff)), ] <- empty ; }
        if( dim(y)[2] > 0 ) { y[ c(as.character(x.diff)), ] <- empty ; }
        
        cbind(x, y) -> output ;
      } 
    }
    
    return( output ) ;
  } ;
  
  String.Contatener <- function( vector, separator )
  {   
    # exclude NA
    na.omit( vector ) -> vector ;
    
    # selection of length for loop
    if ( length( vector ) >= 2) 
    { 
      # stock fisrt element
      tmp.val1 <- vector[1] ;
      
      # loop to concatenate the nect elements
      for ( a in 2:length( vector ) ) 
      { 
        tmp.val1 <- paste( tmp.val1, vector[a], sep = separator ) ; 
      } ;
    } 
    else
    {
      tmp.val1 <- vector ;
    } ;
    
    return( tmp.val1 ) ;
  } ;
  
  p.round <- function( data, digits = 3 )
  {
    if (digits == 1)
    { "" -> tmp1 ; } else 
    { rep( "0", digits - 1 ) -> tmp1 ; }
    
    "0." -> tmp2 ;
    for( a in 1:length(tmp1) )
    {
      paste( tmp2, tmp1[a], sep = "" ) -> tmp2 ;
    }
    
    paste( tmp2, "1", sep = "" ) -> pval ;
    
    for ( a in 1:length(data) )
    {
      if ( !is.na( data[a] ) )
      {
        if ( data[a] >= as.numeric( pval ) )
        {
          round( data[a], digits = digits ) -> data[a] ;
        }
      }
    }
    
    data[ data < as.numeric( pval ) ] <- paste( "< ", pval, sep = "" ) ;
    
    return( data ) ;
  }
  
  IFELSE <- function( condition, true, false )
  {
    if (condition)
    {
      return( true )
    } else
    {
      return( false )
    }
  }
  
  cohen.f2 <- function( model, pseudo.R2 = FALSE, family, data )
  {
    attr(terms(model), 'term.labels') -> terms1 ; 
    as.character( terms(model) )[2] -> outcome ;
    
    NULL -> f2 ;
    
    if ( !pseudo.R2 )
    {
      for ( a in 1:length(terms1) )
      {
        if ( length(terms1) == 1 )
        { 
          stats::update( model, reformulate( "1" ), data = data ) -> model.bis 
        } else
        {
          stats::update( model, reformulate( terms1[-a] ) ) -> model.bis ; 
        }
        
        c( f2, 
           (summary( model )$r.squared -  summary( model.bis  )$r.squared ) / (1 - summary( model )$r.squared) ) -> 
          f2 ;
      }
    }  
    
    if ( pseudo.R2 & any( class( model ) == "glm" ) )
    {
      for ( a in 1:length(terms1) )
      {
        if ( length(terms1) == 1 )
        { 
          stats::update( model, reformulate( "1", outcome ),
                  data = data )-> model.bis ;
        } else
        {
          stats::update( model, reformulate( terms1[-a], outcome ), family = family ) -> model.bis ; 
        }
        
        c( f2, 
           (MuMIn::r.squaredLR( model, stats::update( model, reformulate( "1", outcome ), family = family, data = data  ) )[1] -  MuMIn::r.squaredLR( model.bis, stats::update( model, reformulate( "1" ), family = family, data = data ) )[1]  ) / (1 -  MuMIn::r.squaredLR( model, stats::update( model, reformulate( "1", outcome ), family = family, data = data ) )[1] )  ) -> 
          f2 ;
      }
    }
    
    if ( pseudo.R2 & all( class( model ) != "glm" ) )
    {
      for ( a in 1:length(terms1) )
      {
        if ( length(terms1) == 1 )
        { 
          stats::update( model, reformulate( "1", outcome ),
                  data = data ) -> model.bis ;
        } else
        {
          stats::update( model, reformulate( terms1[-a], outcome ) ) -> model.bis ; 
        }
        
        c( f2, 
           (MuMIn::r.squaredLR( model, 
                                stats::update( model, 
                                        reformulate( "1", outcome ),
                                        data = data ) )[1] -  
              MuMIn::r.squaredLR( model.bis, stats::update( model, 
                                                     reformulate( "1" ),
                                                     data = data ) )[1]  ) / 
             (1 -  MuMIn::r.squaredLR( model, stats::update( model, reformulate( "1", outcome ), data = data ) )[1] )  ) -> 
          f2 ;
      }
    }
    
    terms1 -> names( f2 ) ;
    
    return( f2 )
  }
  
  Systematic.FP <- function( output, predictors, family, data, na.omit )
  {
    if( any( grepl( ":", predictors ) ) )
    {
      predictors[ !grepl( ":", predictors ) ] -> predictors ; 
    }
    
    require( mfp )
    data |>
      base::subset( select = predictors ) |>
      dplyr::select_if( is.numeric ) |>
      colnames() -> 
      pred.num ;
    
    c( "Predictors", "df.initial", "select", "alpha", 
       "df.final", "power1", "power2" ) ->
      return1 ;
    
    for ( a in pred.num )
    {
      paste( "fp(",
             a,
             ",df = 4, select = 1, scale = TRUE)") -> 
        fp ;
      
      if ( na.omit == TRUE ) { na.omit( data ) -> data } 
      
      reformulate( c(fp, predictors[ which( predictors != a) ] ), output ) |>
        mfp::mfp( 
          family = family,
          data = data ) -> 
        tmp.mfp ;
      
      tmp.mfp$fptable[a,] |>
        as.matrix() |>
        (function(x) c( a,x) )() |>
        (function(x) rbind( return1, x ) )() ->
        return1 ;
    }
    
    NULL -> rownames(return1) ;
    
    return( return1 )
  }
  
  residuals.polr <- function( model )
  {
    factor( model$model[,1] ) -> multinom.var ;
    
    NULL -> disjonctif.table ;
    
    for ( a in 1:nlevels( multinom.var ) )
    {
      as.character( multinom.var ) -> tmp.var ;
      
      paste( levels(multinom.var)[a], "a", sep = "" ) -> 
        tmp.var[ tmp.var == levels(multinom.var)[a] ] ;
      0 -> tmp.var[ tmp.var != paste( levels(multinom.var)[a], "a", sep = "" ) ] ;
      1 -> tmp.var[ tmp.var == paste( levels(multinom.var)[a], "a", sep = "" ) ] ;
      cbind( disjonctif.table, 
             as.numeric( as.character( tmp.var ) ) ) -> 
        disjonctif.table ;
      
      levels(multinom.var)[a] -> 
        colnames( disjonctif.table )[ ncol( disjonctif.table ) ] ;
    }
    
    disjonctif.table - model$fitted.values -> output ;
    
    return( output )
  }
  
  Normality.Plot.Unique <- function( vector, name )
  {
    par( mfrow = c( 2, 2), oma = c( 0, 0, 2, 0) )
    
    # Clean missing value
    na.omit( vector ) -> vector ;
    as.numeric( vector ) -> vector ;
    
    # plot histogram
    hist( vector, main = "Histogram", xlab = "Variable", col = "blue" ) ;
    round( moments::kurtosis( vector ), digits = 2 ) -> tmp.val1 ;
    round( moments::skewness( vector ), digits = 2 ) -> tmp.val2 ;
    paste( "Kurtosis: ", tmp.val1, " ; ", "Skewness: ", tmp.val2, sep = "" ) -> tmp.name1 ;
    title( sub = tmp.name1 ) ;
    
    # plot density 
    plot( density( vector ), 
          main = "Density plot", xlab = "Variable", col = "blue" ) ;
    curve( dnorm( x, mean( vector ), sd( vector ) ), add = TRUE, col = "red", lwd = 2, lty = 2 ) ;
    abline( v = mean( vector ), col = "blue", lwd = 2, lty = 2) ;
    abs( range( vector )[2] - range( vector )[1] ) / 20 -> legend.distance1 ;
    abs( range( density( vector )$y )[2] - range( density( vector )$y )[1] ) / 20 -> legend.distance2 ;
    text( x = mean( vector ) + legend.distance1, y = legend.distance2, expression( mu ), col = "blue" ) ;
    legend( x = "topright", lty = c( 1, 2 ), col = c( "blue", "red" ), c( "Sample", "Normal" ), cex = 0.6 ) ;
    round( moments::jarque.test( vector )$p.value, digits = 3 ) -> tmp.val1 ;
    if ( tmp.val1 < 0.001 ) { tmp.val1 <- "< 0.001"} ;
    paste( "Jarque-Bera test p value: ", tmp.val1 ) -> tmp.name1 ;
    if ( tmp.val1 == "< 0.001" | tmp.val1 < 0.05 ) 
    { title( sub = tmp.name1, col.sub = "green", font.sub = 2 ) ; }
    else
    { title( sub = tmp.name1 ) ; } ;
    
    # plot ecdf 
    plot( ecdf( vector ), main = "Empirical cumulative distribution plot", xlab = "Variable", 
          ylab = "Density", col = "blue", ylim = c( -0.2, 1.2 ) )
    plot( add = TRUE, ecdf( rnorm( 10000, mean = mean( vector ), sd = sd( vector ) ) ), col = "red" ) ;
    abline( h = 0.5, lty = 2, lwd = 1, col = "grey80" )
    legend( x = "bottomright", lty = c( 1, 1 ),col = c( "blue", "red" ), c( "Sample", "Normal" ), cex = 0.6 ) ;
    round( nortest::ad.test( vector )$p.value, digits = 3 ) -> tmp.val1 ;
    if ( tmp.val1 < 0.001 ) { tmp.val1 <- "< 0.001"} ;
    paste( "Anderson-Darling test p value: ", tmp.val1, sep = "" ) -> tmp.name1 ;
    if ( tmp.val1 == "< 0.001" | tmp.val1 < 0.05 ) 
    { title( sub = tmp.name1, col.sub = "green", font.sub = 2 ) ; }
    else
    { title( sub = tmp.name1 ) ; } ;
    
    # plot qq 
    qqnorm( vector, col = "blue" ) ;
    qqline( vector, col = "red" ) ;
    legend( x = "bottomright", lty = c( 1 ),col = c( "red" ), c( "Henry's line" ), cex = 0.6 ) ;
    if ( length( vector ) > 5000 )
    {
      "Shapiro-Wilk test not performed (N > 5000 )" -> tmp.name1 ;
      title( sub = tmp.name1 ) ;
    } else
    {
      round( shapiro.test( vector )$p.value, digits = 3 ) -> tmp.val1 ;
      if ( tmp.val1 < 0.001 ) { tmp.val1 <- "< 0.001"} ;
      paste( "Shapiro-Wilk test p value: ", tmp.val1, sep = "" ) -> tmp.name1 ;
      if ( tmp.val1 == "< 0.001" | tmp.val1 < 0.05 ) 
      { title( sub = tmp.name1, col.sub = "green", font.sub = 2 ) ; }
      else
      { title( sub = tmp.name1 ) ; } ;
    }
    
    # put title 
    tmp.name2 <- paste( "Noramlity Study of", name, sep = " " ) ;
    mtext( text =  tmp.name2, outer = TRUE, cex = 1.5 ) ;
  }
  
  Formula.Maker <- function( outcome, fixed.effects = "", interactions = "", random.effects = "", 
                             random.interactions = list(""), covariance = TRUE, DeleteTerms = NULL )
  {
    # Cheking inuts
    if ( !all( random.interactions == "" ) )
    {
      if ( length(random.interactions) != length(random.effects) ) 
      { print( "Missing random interactions arguments" ) ;}
    } ;
    
    # Integration of fixed effects
    if ( !all( fixed.effects == "" ) ) 
    { 
      if ( length( which(fixed.effects == "" ) ) > 0 )
      {
        fixed.effects[-which(fixed.effects == "")] -> Predictors ; 
      }
      else
      {
        fixed.effects  -> Predictors ; 
      }    
    }
    else
    { "1" -> Predictors } ;
    
    # Integration of interactions
    if ( all( interactions != "" ) )
    {
      for ( a in 1:length( interactions ) )
      {
        paste( interactions[[a]][1], ":", interactions[[a]][2], sep = "" ) -> tmp.val1
        c( Predictors, tmp.val1 ) -> Predictors ; 
      } ;
    } ;
    
    # Integration of random effects
    if ( all( random.effects != "" ) )
    {
      for ( a in 1:length( random.effects) )
      {
        if ( all( random.interactions == "" ) )
        {
          paste( "(1 | ", random.effects[a], ")", sep = "" ) -> tmp.val1 ;
          c( Predictors, tmp.val1 ) -> Predictors ;
        } ;
      } ;
    } ;
    
    # Integration of random interactions 
    if ( any( random.interactions != "" ) )
    {
      if ( covariance )
      {
        for ( a in 1:length(random.effects) )
        {
          if ( all( random.interactions[[a]] != "1" ) )
          {
            "(1" -> tmp.val1 ;
            for ( b in 1:length( random.interactions[[a]] ) )
            {
              if ( random.interactions[[a]][b] != "" )
              {
                paste( tmp.val1, " + ", random.interactions[[a]][b], sep = "" ) -> tmp.val1 ;
              } ;
            } ;
            paste( tmp.val1, " | ", random.effects[a], ")", sep = "" ) -> tmp.val2 ;
            c( Predictors, tmp.val2 ) -> Predictors ;
          }
          if ( all( random.interactions[[a]] == "1" ) )
          {
            paste( "(1", " | ", random.effects[a], ")", sep = "" ) -> tmp.val2 ;
            c( Predictors, tmp.val2 ) -> Predictors ;
          } ;
        } ;
      } ;
      
      if ( !covariance )
      {
        for ( a in 1:length( random.effects) )
        {
          paste( "(1 | ", random.effects[a], ")", sep = "" ) -> tmp.val1 ;
          c( Predictors, tmp.val1 ) -> Predictors ;
          for ( b in 1:length(random.interactions[[a]]) )
          {
            if ( random.interactions[[a]][b] != "" )
            {
              paste( "(", random.interactions[[a]][b], " || ", random.effects[a], ")", sep = "" ) -> tmp.val1 ;
              c( Predictors, tmp.val1 ) -> Predictors ;
            } ;
          } ;
        } ;
      } ;
    } ;
    
    # Deletion of terms 
    if ( all( !is.null( DeleteTerms ) ) )
    {
      if ( class(DeleteTerms) == "numeric" )
      {
        Predictors[ -DeleteTerms ] -> Predictors ;
      } ;
      if ( class(DeleteTerms) == "character" )
      {
        Predictors[ !( Predictors %in% DeleteTerms ) ] -> Predictors ;
      } ;
    } ;
    
    # Generation of formula  
    reformulate( Predictors, outcome ) -> Formula ; 
    
    return( Formula ) ;
  } ;
  
  hmftest.systematic <- function( formula2 , data ) 
  {
    formula2 |>
      as.character() ->
      formula2.ch ;
    
    if ( grepl( ":", formula2.ch[3]) )
    {
      return( "No hmf test for models with interactions" )
    }
    
    reformulate( paste0( "0 | ", formula2.ch[3]), formula2.ch[2] ) ->
      formula2.new  ;
    
    dfidx::dfidx( data, shape = "wide", choice = formula2.ch[2] ) ->
      data.new ;
    
    mlogit::mlogit( formula2.new, 
                    data = data.new 
    ) -> model.new ; 
    
    c( "var", "Chisq", "df", "p-value" ) -> output ; 
    
    for (a in 2:nlevels( data[, formula2.ch[2] ] ) )
    { 
      mlogit::mlogit( formula2.new, 
                      data = data.new,
                      alt.subset = levels( data[, formula2.ch[2] ] )[-a]
      ) -> model.alt ;
      
      try( mlogit::hmftest( model.new, model.alt ) ) ->
        tmp ;
      
      if (attr( tmp,"class") == "try-error" )
      {
        "" -> output ; 
      } else
      {
        rbind( output, 
               c( levels( data[, formula2.ch[2] ] )[a], 
                  IFELSE( is.null( round ), 
                          tmp$statistic,
                          round( tmp$statistic, round ) ) ,
                  tmp$parameter,
                  IFELSE( is.null( pvalue.round ), 
                          tmp$p.value, p.round( tmp$p.value, pvalue.round ) ) )
        ) -> 
          output ;
      }
      
    }
    
    return( data.frame(output) )
  }
  
  Multinomial.SubsetLevels <- function( formula2 , data, round  )
  {
    formula2 |>
      as.character() ->
      formula2.ch ;
    
    nnet::multinom( reformulate(as.character(formula2)[3], 
                                as.character(formula2)[2] ), 
                    data = data,
                    Hess = TRUE ) -> m1 
    
    
    cbind( paste0( rownames(summary(m1)$coefficients),
                   ": Base model" ),
           IFELSE( !is.null(round),
                   round( summary(m1)$coefficients, 
                          round ),
                   summary(m1)$coefficients ) 
    ) -> output ;
    
    if ( nlevels( data[, formula2.ch[2] ] ) > 3 )
    {
      rbind.force( output,
                   rbind.force(  lapply( 2:nlevels( data[, formula2.ch[2] ] ), 
                                         FUN = function(a)
                                         {
                                           data[ data[, formula2.ch[2] ] != 
                                                   levels( data[, formula2.ch[2] ] )[a],] ->
                                             data2
                                           
                                           factor( data2[, formula2.ch[2] ] ) ->
                                             data2[, formula2.ch[2] ]
                                           
                                           nnet::multinom( reformulate(as.character(formula2)[3], 
                                                                       as.character(formula2)[2] ), 
                                                           data = data2,
                                                           Hess = TRUE ) -> m1 
                                           
                                           cbind( paste0( rownames(summary(m1)$coefficients),
                                                          ": -", 
                                                          levels( data[, formula2.ch[2] ] )[a] ,
                                                          " model" ),
                                                  IFELSE( !is.null(round),
                                                          round( summary(m1)$coefficients, 
                                                                 round ),
                                                          summary(m1)$coefficients ) 
                                           ) 
                                         }) ), empty = "" ) -> 
        output ;
    } else
    {
      rbind.force( output,
                   rbind.force( lapply( 2:nlevels( data[, formula2.ch[2] ] ), 
                                        FUN = function(a)
                                        {
                                          data[ data[, formula2.ch[2] ] != 
                                                  levels( data[, formula2.ch[2] ] )[a],] ->
                                            data2
                                          
                                          factor( data2[, formula2.ch[2] ] ) ->
                                            data2[, formula2.ch[2] ]
                                          
                                          nnet::multinom( reformulate(as.character(formula2)[3], 
                                                                      as.character(formula2)[2] ), 
                                                          data = data2,
                                                          Hess = TRUE ) -> m1 
                                          
                                          cbind( paste0( levels( data2[, formula2.ch[2] ] )[2],
                                                         ": -", 
                                                         levels( data[, formula2.ch[2] ] )[a] ,
                                                         " model" ),
                                                 t(IFELSE( !is.null(round),
                                                           round( summary(m1)$coefficients, 
                                                                  round ),
                                                           summary(m1)$coefficients ) )
                                          ) 
                                        }) ),
                   empty = "" )  -> 
        output ;
    }
    
    output |>
      data.frame() |>
      dplyr::arrange( X1 ) |>
      t() |>
      (function(x)  cbind( c( "Outcome levels ->", m1$coefnames ), 
                           x ) )() -> output
    
    return( data.frame(output) )
  }
  
  pairs2 <- function( y, X, ExportName, n )
  {
    data.frame(y) |>
      lapply(as.numeric) |>
      data.frame() -> y
    data.frame(X) |>
      lapply(as.numeric) |>
      data.frame() -> X
    
    (ncol(X) / n) |> trunc() -> npairs
    (ncol(X) %% n) -> addpairs
    
    if ( npairs != 0 )
    {
      for (a in 0:(npairs - 1) )
      {
        png( paste( ExportName,
                    "Pair_Graphics",
                    "_", a +1,
                    ".png",
                    sep = "" ) )
        y |>
          cbind(X[, (1 + n * a):(
            n * (a + 1) ) ]) |>
          pairs( cex.labels = 0.8, main = paste( "Pairs graphic", a + 1 ) )
        dev.off() ;
      }
    }
    
    if ( addpairs != 0 )
    {
      png( paste( ExportName,
                  "Pair_Graphics",
                  "_", (npairs + 1),
                  ".png",
                  sep = "" ) )
      y |>
        cbind(  subset( X, select = (1 + n * npairs):ncol(X) ) ) |>
        pairs(  cex.labels = 0.8, main = paste( "Pairs graphic", npairs + 1 ) )
      dev.off() ;
    }
  }
  
  termplot2.w <- function( model, ExportName )
  {
    ( (ncol( model$model  ) - 2) / 9) |> trunc() -> n ;
    ( (ncol( model$model  ) - 2) %% 9) -> o ;
    
    if ( n != 0 )
    {
      for (a in 1:n )
      {
        png( paste( ExportName,
                    "RegressionsTerms_vs_Predictors_",
                    a,
                    ".png",
                    sep = "" ) )
        layout( matrix( 1:9, ncol=3, byrow=T ) )
        par( oma = c( 0, 0, 2, 0) )
        termplot( model,
                  terms = attr( terms( model ),"term.labels")[((a - 1) * 9 + 1):(a  * 9)],
                  ask = FALSE,
                  partial.resid = TRUE,
                  se = TRUE,
                  smooth = panel.smooth )
        mtext( text =  paste( "Regression terms vs Predictors", a ),
               outer = TRUE, cex = 1.5 ) ;
        dev.off() ;
      }
    }
    
    if ( o != 0 )
    {
      png( paste( ExportName,
                  "RegressionsTerms_vs_Predictors_",
                  n + 1,
                  ".png",
                  sep = "" ) )
      layout( matrix( 1:9, ncol=3, byrow=T ) )
      par( oma = c( 0, 0, 2, 0) )
      termplot( model,
                terms = attr( terms( model ),"term.labels")[(n * 9 + 1):(n * 9 + o)],
                ask = FALSE,
                partial.resid = TRUE,
                se = TRUE,
                smooth = panel.smooth )
      mtext( text =  paste( "Regression terms vs Predictors", n + 1),
             outer = TRUE, cex = 1.5 ) ;
      dev.off() ;
    }
    
  } ;
  
  residualPlots2.w <- function( model, ExportName )
  {
    ( (ncol( model$model  ) - 2) / 9) |> trunc() -> n ;
    ( (ncol( model$model  ) - 2) %% 9) -> o ;
    
    if ( n != 0 )
    {
      for (a in 1:n )
      {
        png( paste( ExportName,
                    "Pearson_Residuals_vs_Independant_Vars",
                    a,
                    ".png",
                    sep = "" ) )
        layout( matrix( 1:9, ncol=3, byrow=T ) )
        par( oma = c( 0, 0, 2, 0) )
        car::residualPlot( model,
                           terms = reformulate( attr( terms( model ),"term.labels")[((a - 1) * 9 + 1):(a  * 9)] ),
                           tests = FALSE,
                           fitted = FALSE,
                           ask = FALSE,
                           type = "rstandard" )
        mtext( text =  paste( "Pearson Residuals vs Independant Vars", a),
               outer = TRUE, cex = 1.5 ) ;
        dev.off() ;
      }
    }
    
    if ( o != 0 )
    {
      png( paste( ExportName,
                  "Pearson_Residuals_vs_Independant_Vars",
                  n + 1,
                  ".png",
                  sep = "" ) )
      layout( matrix( 1:9, ncol=3, byrow=T ) )
      par( oma = c( 0, 0, 2, 0) )
      car::residualPlot( model,
                         terms = reformulate( attr( terms( model ),"term.labels")[(n * 9 + 1):(n * 9 + o)] ),
                         tests = FALSE,
                         fitted = FALSE,
                         ask = FALSE,
                         type = "rstandard" )
      mtext( text =  paste( "Pearson Residuals vs Independant Vars", n + 1),
             outer = TRUE, cex = 1.5 ) ;
      dev.off() ;
    }
  }
  
  avPlots2.w <- function( model, ExportName )
  {
    ( (length( names(model$coefficients) ) - 2) / 9) |> trunc() -> n ;
    ( (length( names(model$coefficients)  ) - 2) %% 9) -> o ;
    
    if ( n != 0 )
    {
      for (a in 1:n )
      {
        png( paste( ExportName,
                    "Added-Variable_Plots",
                    a,
                    ".png",
                    sep = "" ) )
        layout( matrix( 1:9, ncol=3, byrow=T ) )
        par( oma = c( 0, 0, 2, 0) )
        for (b in names(model$coefficients)[-1][((a - 1) * 9 + 1):(a  * 9)])
        {
          car::avPlot( model,
                       variable =  b
          ) ;
        }
        mtext( text =  paste( "Added-Variable Plots", a ),
               outer = TRUE, cex = 1.5 ) ;
        dev.off() ;
      }
    }
    
    if ( o != 0 )
    {
      png( paste( ExportName,
                  "Added-Variable_Plots",
                  n + 1,
                  ".png",
                  sep = "" ) )
      layout( matrix( 1:9, ncol=3, byrow=T ) )
      par( oma = c( 0, 0, 2, 0) )
      for (b in names(model$coefficients)[-1][(n * 9 + 1):(n * 9 + o)])
      {
        car::avPlot( model,
                     variable =  b
        ) ;
      }
      mtext( text =  paste( "Added-Variable Plots", n + 1 ),
             outer = TRUE, cex = 1.5 ) ;
      dev.off() ;
    }
  }
  
  crPlots2.w <- function( model, ExportName )
  {
    ( (ncol( model$model  ) - 2) / 9) |> trunc() -> n ;
    ( (ncol( model$model  ) - 2) %% 9) -> o ;
    
    if ( n != 0 )
    {
      for (a in 1:n )
      {
        png( paste( ExportName,
                    "Component-Residuals_Plots",
                    a,
                    ".png",
                    sep = "" ) )
        layout( matrix( 1:9, ncol=3, byrow=T ) )
        par( oma = c( 0, 0, 2, 0) )
        car::crPlots( model,
                      terms = reformulate( attr( terms( model ),"term.labels")[((a - 1) * 9 + 1):(a  * 9)] ),
                      ask = FALSE, main = "" )
        mtext( text =  paste( "Component-Residuals Plots", a),
               outer = TRUE, cex = 1.5 ) ;
        dev.off() ;
      }
    }
    
    if ( o != 0 )
    {
      png( paste( ExportName,
                  "Component-Residuals_Plots",
                  n + 1,
                  ".png",
                  sep = "" ) )
      layout( matrix( 1:9, ncol=3, byrow=T ) )
      par( oma = c( 0, 0, 2, 0) )
      car::crPlots( model,
                    terms = reformulate( attr( terms( model ),"term.labels")[(n * 9 + 1):(n * 9 + o)] ),
                    ask = FALSE, main = "" )
      mtext( text =  paste( "Component-Residuals Plots", n + 1),
             outer = TRUE, cex = 1.5 ) ;
      dev.off() ;
    }
  }
  
  
  Lm.Analysis <- function( outcome, predictors, 
                           data, 
                           na.omit = TRUE,
                           FULL = TRUE, 
                           selected.predictors = NULL,
                           ANOVA = FALSE 
  )
  {
    # Formula
    Formula.Maker( outcome, predictors ) -> 
      formula ;
    
    # model
    if ( na.omit == TRUE ) { 
      na.omit( data ) -> data } 
    
    lm( formula, data = data,
        weights = weights ) ->
      m1 ;
    
    m1 |>
      (function(x) list( model = x )  )() -> 
      output ;
    
    m1 |> summary() -> summary1 ;
    
    m1 |> 
      lmtest::coeftest( 
        vcov. = sandwich::vcovCL, 
        cluster = as.formula( paste0( "~", cluster.ID ) ) 
      ) -> summary.corrected1 ;
    
    m1 |>
      #car::Confint( level = conf.level ) |>
      ( function(x)
        cbind( 
          Estimate = x$coefficients,
          lmtest::coefci( x, vcov. = sandwich::vcovCL, 
                          cluster = as.formula( paste0( "~", cluster.ID ) ),
                          level = conf.level )
        )
      )() |>
      as.data.frame() |>
      (function(x) IFELSE( is.null( round ),
                           x,
                           round( x, round ) ) )() |>
      (function(x) cbind( Predictors = rownames(x), x ) )() |>
      (function(x) rbind.force( colnames(x), x ) )() -> 
      confint.corrected1 ;
    
    m1 |>
      ( function(x) {
        car::Anova( x,
                    type = "3",
                    vcov. = 
                      sandwich::vcovCL( x,
                                        cluster = as.formula( paste0( "~", cluster.ID ) ) ) 
        ) }
      )() ->
      anova.corrected1 ;
    
    # prepare results 
    if (FULL)
    {
      # formula
      "Model:" -> results.tab ;
      
      formula |>
        deparse() |>
        (function(x) rbind.force( results.tab, x, empty = "" ) 
        )() -> results.tab ;
      
      "" |> (function(x) rbind.force( results.tab, x, empty = "" ) 
      )() -> results.tab ;
      
      # missing data
      c( "Observations deleted due to missingness:",
         dim( data )[1] - dim( m1$model )[1] ) |>
        (function(x) rbind.force( results.tab, x, empty = "" ) 
        )() -> 
        results.tab ;
      
      "" |> (function(x) rbind.force( results.tab, x, empty = "" ) 
      )() -> results.tab ;
      
      
      #  slopes and t.tests
      "Model coefficients and t-tests" |> 
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      summary.corrected1[,1:4] |>
        as.data.frame() |>
        subset( select = -Estimate ) |>
        transform( 
          `Std. Error` =  IFELSE( is.null( round ), 
                                  `Std. Error`,
                                  round( `Std. Error`, round ) ),
          `t value` =  IFELSE( is.null( round ), 
                               `t value`,
                               round( `t value`, round ) ),
          `Pr(>|t|)` =  IFELSE( is.null( pvalue.round ), 
                                `Pr(>|t|)`,
                                p.round( `Pr(>|t|)`, pvalue.round ) ) ) |>
        (function(x) rbind.force( colnames(x), x ) )() |>
        (function(x) cbind( confint.corrected1, x ) )() |>
        (function(x) rbind.force( results.tab, x, empty = "" ) 
        )() -> results.tab ;
      
      "" |> (function(x) rbind.force( results.tab, x, empty = "" ) 
      )() -> results.tab ;
      
      # Anova
      data.frame( Predictors = rownames( anova.corrected1 ),
                  "F" = anova.corrected1$F,
                  "Df" = anova.corrected1$Df,
                  "Pr(>F)" = anova.corrected1$`Pr(>F)`
      )[1:(nrow(anova.corrected1) - 1),] |>
        as.data.frame() |> 
        (function(x) data.frame( 
          Predictors = x$Predictors,
          `Df numerator` = x$Df,
          `Df denominator` = c( rep( m1$df.residual, 
                                     times = dim(x)[1] ) ),
          `F value` =  IFELSE( is.null( round ), 
                               x$F,
                               round( x$F, round ) ), 
          `Pr(>F)` =  IFELSE( is.null( pvalue.round ), 
                              x$`Pr..F.`,
                              p.round( x$`Pr..F.`, pvalue.round ) ) ) 
        )() |>
        cbind( `Cohen's f-squared on R-squared` =  
                 IFELSE( is.null( round ), 
                         c( NA, cohen.f2( m1, data = data ) ),
                         c( NA, round( cohen.f2( m1, data = data ), round )  ) ) 
        ) |>
        cbind( `Partial eta-squared` =  
                 IFELSE( is.null( round ), 
                         c( NA, heplots::etasq( m1 )[1:(
                           nrow( heplots::etasq( m1 ) ) - 1), 1 ] ),
                         c( NA, round( heplots::etasq( m1 )[1:(
                           nrow( heplots::etasq( m1 ) ) - 1), 1 ],
                           round )  ) ) 
        ) |>
        cbind(  AIC =  IFELSE( is.null( round ), 
                               AIC( m1 ),
                               round( AIC( m1 ), round ) ) ) ->
        anova1 ;
      
      "ANOVA (type 3 tests)" |> (function(x) rbind.force( 
        results.tab, x, empty = "" ) )() -> 
        results.tab ;
      
      anova1 |>
        (function(x) rbind.force( c(
          "Predictors", "Df numerator", "Df denominator",               
          "F value", "Pr(>F)", "Cohen's f-squared on R-squared",
          "Partial eta-squared", "AIC"
        ), x) )() |>
        (function(x) rbind.force( results.tab, x, empty = "" ) 
        )() -> results.tab ;
      
      "" |> (function(x) rbind.force( results.tab, x, empty = "" ) 
      )() -> results.tab ;
      
      # Models infos
      c( "Multiple R-squared:", 
         IFELSE( is.null( round ), 
                 summary1$r.squared,
                 round( summary1$r.squared, round ) ),
         "Adjusted R-squared:", 
         IFELSE( is.null( round ), 
                 summary1$adj.r.squared,
                 round( summary1$adj.r.squared, round ) ) ) |>
        (function(x) rbind.force( results.tab, x, empty = "" ) 
        )() -> results.tab ;
      
      c( "AIC:", 
         IFELSE( is.null( round ), 
                 AIC(m1),
                 round( AIC(m1), round ) ),
         "AICc:", 
         IFELSE( is.null( round ), 
                 MuMIn::AICc(m1),
                 round( MuMIn::AICc(m1), round ) ) ) |> 
        (function(x) rbind.force( results.tab, x, empty = "" ) 
        )() -> results.tab ;
      
      "" |> (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      # post hoc analysis with no plots
      # Residuals normality 
      residuals( m1 ) -> residuals1 ;
      if ( length( residuals1 ) < 5000 ) 
      { shapiro.test( residuals1 ) -> shapiro.res ; }  else
      { list( "p.value" = NA ) -> shapiro.res ; }
      nortest::ad.test( residuals1 ) -> anderson.res ;
      moments::jarque.test( residuals1 ) -> jarque.res ;
      
      "Normality tests on Residuals" |> 
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      c( "Shapiro test p-value:", 
         IFELSE( is.null( pvalue.round ), 
                 shapiro.res$p.value,
                 p.round( shapiro.res$p.value, pvalue.round ) ),
         "Anderson-Darling test p-value:", 
         IFELSE( is.null( pvalue.round ), 
                 anderson.res$p.value,
                 p.round( anderson.res$p.value, pvalue.round ) ),
         "Jarque-Bera test p-value:", 
         IFELSE( is.null( pvalue.round ), 
                 jarque.res$p.value,
                 p.round( jarque.res$p.value, pvalue.round ) ) ) |> 
        (function(x) rbind.force( results.tab, x, empty = "" ) 
        )() -> results.tab ;
      
      "" |> (function(x) rbind.force( results.tab, x, empty = "" ) 
      )() -> results.tab ;
      
      # Residuals homosedasticity 
      "Homosedasticity tests on Residuals" |> 
        (function(x) rbind.force( results.tab, x, empty = "" ) 
        )() -> results.tab ;
      
      c( "Score test for Non-Constant Error Variance p-value:", 
         IFELSE( is.null( pvalue.round ), 
                 car::ncvTest( m1 )$p,
                 p.round( car::ncvTest( m1 )$p, pvalue.round ) ),
         "Breusch-Pagan test p-value:", 
         IFELSE( is.null( pvalue.round ), 
                 lmtest::bptest(m1)$p.value,
                 p.round( lmtest::bptest(m1)$p.value, pvalue.round ) ) )  |> 
        (function(x) rbind.force( results.tab, x, empty = "" ) 
        )() -> results.tab ;
      
      "" |> (function(x) rbind.force( results.tab, x, empty = "" ) 
      )() -> results.tab ;
      
      # Residuals independancy 
      "Independancy of Residuals" |> 
        (function(x) rbind.force( results.tab, x, empty = "" )
        )() -> results.tab ;
      
      set.seed( 123) ;
      car::durbinWatsonTest( m1 ) -> dw1 ; 
      c( "Durbin-Watson statistic (1.5 - 2.5):",
         IFELSE( is.null( round ), 
                 dw1$dw,
                 round( car::durbinWatsonTest( m1 )$p, round ) ),
         "Durbin-Watson test p-value:", 
         IFELSE( is.null( pvalue.round ), 
                 dw1$p,
                 p.round( car::durbinWatsonTest( m1 )$p, pvalue.round 
                 ) ) ) |> 
        (function(x) rbind.force( results.tab, x, empty = "" ) 
        )() -> results.tab ;
      
      "" |> (function(x) rbind.force( results.tab, x, empty = "" ) 
      )() -> results.tab ;
      
      #  Multicollinearity
      if ( length( attr( terms(m1),"term.labels") ) > 1 )
      {
        c( "Multicollinearity check" ) |> 
          (function(x) rbind.force( results.tab, x, empty = "" )
          )() -> results.tab ;
        
        c( "(generalized) Variance Inflation Factors:" ) |> 
          (function(x) rbind.force( results.tab, x, empty = "" ) 
          )() -> results.tab ;
        
        car::vif( m1 ) |>
          (function(x) IFELSE( is.null( round ), 
                               x,
                               round( x, round ) ) )() |>
          as.data.frame() |>
          (function(x) cbind( Predictors = rownames(x), x ) )()  -> 
          tmp.vif ;
        
        if ( ncol( tmp.vif ) == 2 ) { "VIF" -> colnames( tmp.vif )[2] }
        
        tmp.vif |>
          (function(x) rbind.force( colnames(x), x ) )() |>
          (function(x) rbind.force( results.tab, x, empty = "" ) 
          )() -> results.tab ;
        
        "" |> (function(x) rbind.force( results.tab, x, empty = "" )
        )() -> results.tab ;
        
        # besley
        attr( terms( m1 ),"term.labels" ) -> Vars
        base::subset( data, 
                      select = Vars[ 
                        !( Vars  %in% Vars[ grep( ":", Vars ) ] ) ] 
        ) |>
          dplyr::select_if( is.numeric ) ->
          data2 
        
        VisCollin::colldiag( mod = lm(
          reformulate( colnames(data2),
                       as.character(formula)[2] ),
          data = data), 
          scale = FALSE, 
          center = FALSE, add.intercept = T ) -> 
          besley
        
        "Belsley criteria (computed on numeric predictors only):" |> 
          (function(x) rbind.force( results.tab, x, empty = "" ) 
          )() -> results.tab ;
        
        data.frame( besley$condindx, besley$pi) |>
          (function(x) rbind( colnames(x), x ) )() |>
          (function(x) rbind.force( results.tab, x, empty = "" ) 
          )() -> results.tab ;
        
        "" |> (function(x) rbind.force( results.tab, x, empty = "" ) 
        )() -> results.tab ;
        
        # other criteria
        if ( ncol(data2) > 1 )
        {
          "Other criteron on numeric predictors only:" |> 
            (function(x) rbind.force( results.tab, x, empty = "" ) 
            )() -> results.tab ;
          "===================================" |> 
            (function(x) rbind.force( results.tab, x, empty = "" ) 
            )() -> results.tab ;
          
          #omcdiag( data2,
          #           data[,outcome]
          #  )  |> 
          #    capture.output() |>
          #    data.frame() |>
          #    (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
          
          #  imcdiag( data2,
          #          data[,outcome]
          #  )  |> 
          #   capture.output() |>
          #    data.frame() |>
          #    (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
          # "" |>  (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
        }
        
      }
      
      
      #  Linearity and non-addititvity check
      c(  "Linearity and non-addititvity check" ) |> 
        (function(x) rbind.force( results.tab, x, empty = "" ) 
        )() -> results.tab ;
      
      c( "Curvature test and Tukey's test for non-additivity:" ) |> 
        (function(x) rbind.force( results.tab, x, empty = "" ) 
        )() -> results.tab ;
      
      "Best Fractional Polynomial for each numeric predictor:" |> 
        (function(x) rbind.force( results.tab, x, empty = "" ) 
        )() -> results.tab ;
      
      formula |> as.character() -> formula1 ;
      
      Systematic.FP( output = formula1[2], 
                     predictors = attr( terms(m1), 'term.labels'),
                     family = "gaussian", 
                     data = data, 
                     na.omit = na.omit ) |>
        as.data.frame() |>
        (function(x) rbind.force( results.tab, x, empty = "" )
        )() -> results.tab ;
      
      "" |> (function(x) rbind.force( results.tab, x, empty = "" )
      )() -> results.tab ;
      
      # Observation with major influence
      c( "Observation with major influence" ) |> 
        (function(x) rbind.force( results.tab, x, empty = "" ) 
        )() -> results.tab ;
      
      c( "Number of observations",
         "with a Cook distance",
         "over 4 / N:",
         sum( cooks.distance( m1 ) > 4 / nrow( data ) )
      ) |> 
        (function(x) rbind.force( results.tab, x, empty = "" ) 
        )() -> results.tab ;
      
      "" |> (function(x) rbind.force( results.tab, x, empty = "" ) 
      )() -> results.tab ;
      
      c( "Bonferroni Outlier test" ) |> 
        (function(x) rbind.force( results.tab, x, empty = "" ) 
        )() -> results.tab ;
      
      car::outlierTest( m1) |> 
        capture.output() |> 
        matrix(  ncol = 1) |>
        as.data.frame() |>
        (function(x) rbind.force( results.tab, x, empty = "" ) 
        )() -> results.tab ;
      
      "" |> (function(x) rbind.force( results.tab, x, empty = "" ) 
      )() -> results.tab ;
      
      "/////////////////////////////////////////" |> 
        (function(x) rbind.force( results.tab, x, empty = "" ) 
        )() -> results.tab ;
    }
    
    if ( !FULL & ANOVA )
    {
      # Anova
      data.frame( Predictors = rownames( anova.corrected1 ),
                  "F" = anova.corrected1$F,
                  "Df" = anova.corrected1$Df,
                  "Pr(>F)" = anova.corrected1$`Pr(>F)`
      )[1:(nrow(anova.corrected1) - 1),] |>
        as.data.frame() |> 
        (function(x) data.frame( 
          Predictors = x$Predictors,
          `Df numerator` = x$Df,
          `Df denominator` = c( rep( m1$df.residual, 
                                     times = dim(x)[1] ) ),
          `F value` =  IFELSE( is.null( round ), 
                               x$F,
                               round( x$F, round ) ), 
          `Pr(>F)` =  IFELSE( is.null( pvalue.round ), 
                              x$`Pr..F.`,
                              p.round( x$`Pr..F.`, pvalue.round ) ) ) 
        )() |>
        cbind( `Cohen's f-squared on R-squared` =  
                 IFELSE( is.null( round ), 
                         c( NA, cohen.f2( m1, data = data ) ),
                         c( NA, round( cohen.f2( m1, data = data ), round )  ) ) 
        ) |>
        cbind( `Partial eta-squared` =  
                 IFELSE( is.null( round ), 
                         c( NA, heplots::etasq( m1 )[1:(
                           nrow( heplots::etasq( m1 ) ) - 1), 1 ] ),
                         c( NA, round( heplots::etasq( m1 )[1:(
                           nrow( heplots::etasq( m1 ) ) - 1), 1 ],
                           round )  ) ) 
        ) |>
        cbind(  AIC =  IFELSE( is.null( round ), 
                               AIC( m1 ),
                               round( AIC( m1 ), round ) ) ) ->
        tmp.anova ;
      
      # Extraction
      lapply( 1:length(selected.predictors),  
              function(a){ 
                tmp.anova[ grep( selected.predictors[a],  tmp.anova[,1] ), ] } ) |> 
        (function(x) rbind.force( tmp.anova[1,], x, empty = "" ) )() |>
        unique() ->
        results.tab ;
      
      rbind.force( colnames(tmp.anova), results.tab ) ->
        results.tab ;
    }
    
    
    if ( !FULL & !ANOVA )
    {
      # Compute output
      summary.corrected1[,1:4] |>
        as.data.frame() |>
        subset( select = -Estimate ) |>
        transform( 
          `Std. Error` =  IFELSE( is.null( round ), 
                                  `Std. Error`,
                                  round( `Std. Error`, round ) ),
          `t value` =  IFELSE( is.null( round ), 
                               `t value`,
                               round( `t value`, round ) ),
          `Pr(>|t|)` =  IFELSE( is.null( pvalue.round ), 
                                `Pr(>|t|)`,
                                p.round( `Pr(>|t|)`, pvalue.round ) ) ) |>
        (function(x) rbind.force( colnames(x), x ) )() |>
        (function(x) cbind( confint.corrected1, x ) )() -> 
        tmp.student ;
      
      # Extraction
      lapply( 1:length(selected.predictors),  
              function(a){ 
                tmp.student[ grep( selected.predictors[a],  tmp.student[,1] ), ] } 
      ) |> 
        (function(x)  rbind.force( tmp.student[1,], x, empty = "" ) )() |>
        unique() ->
        results.tab ;
    }
    
    # output 
    NULL -> rownames( results.tab ) ;
    NULL -> colnames( results.tab ) ;
    
    c( output, list( results.tab = results.tab ) ) -> 
      output ;
    
    return( output )
  }
  
  Glm.Analysis <- function( outcome, predictors, 
                            family,
                            data, 
                            na.omit = TRUE,
                            FULL = TRUE, 
                            selected.predictors = NULL,
                            ANODE = FALSE 
  )
  {
    # Formula
    if ( length( outcome ) == 2 ) 
    { paste( "cbind(", outcome[1], ",", outcome[2], ")" ) -> outcome ;
      as.formula( paste(outcome, 
                        " ~ ", 
                        as.character( reformulate( predictors ) )[2] ) 
      ) -> 
        formula ; 
    } else
    {
      Formula.Maker( outcome, predictors ) -> 
        formula ;
    }
    
    # model
    if ( na.omit == TRUE ) { na.omit( data ) -> data } 
    
    glm( formula, family = family, data = data,
         weights = weights ) ->
      m1 ;
    
    m1 |> 
      (function(x) list( model = x ) )() -> 
      output ;
    
    m1 |> summary() -> summary1 ;
    
    m1 |> 
      lmtest::coeftest( 
        vcov. = sandwich::vcovCL, 
        cluster = as.formula( paste0( "~", cluster.ID ) ) 
      ) -> summary.corrected1 ;
    
    m1 |>
      #car::Confint( level = conf.level ) |>
      ( function(x)
        cbind( 
          Estimate = x$coefficients,
          lmtest::coefci( x, vcov. = sandwich::vcovCL, 
                          cluster = as.formula( paste0( "~", cluster.ID ) ),
                          level = conf.level )
        )
      )() |>
      as.data.frame()|>
      exp() |>
      (function(x) IFELSE( is.null( round ),
                           x,
                           round( x, round ) ) )() |>
      (function(x) cbind( Predictors = rownames(x), x ) )() |>
      (function(x) rbind.force( colnames(x), x ) )() -> 
      confint.corrected1 ;
    
    confint.corrected1[1,2:4] <- c( "exp(Estimate)", 
                                    paste0("exp(", 
                                           (1 - conf.level ) / 2 * 100,
                                           "%CI)"),
                                    paste0("exp(", 
                                           100 - (1 - conf.level ) / 2 * 100,
                                           "%CI)")
    ) ;
    
    m1 |>
      ( function(x) {
        car::Anova( x,
                    type = "3",
                    test.statistic=c("Wald"),
                    vcov. = 
                      sandwich::vcovCL( x,
                                        cluster = as.formula( paste0( "~", cluster.ID ) ) ) 
        ) }
      )() ->
      anova.corrected1 ;
    
    # prepare results 
    if (FULL)
    {
      # formula
      "Model:" -> results.tab ;
      
      formula |> 
        deparse() |> 
        (function(x) rbind.force( results.tab, x, empty = "" ) 
        )() -> results.tab ;
      
      "" |> (function(x) rbind.force( results.tab, x, empty = "" ) 
      )() -> results.tab ;
      
      # missing data
      c( "Observations deleted due to missingness:",
         dim( data )[1] - dim( m1$model )[1] ) |> 
        (function(x) rbind.force( results.tab, x, empty = "" ) 
        )() -> results.tab ;
      
      "" |> (function(x) rbind.force( results.tab, x, empty = "" ) 
      )() -> results.tab ;
      
      #  slopes and t.tests
      "Model coefficients and t-tests" |> 
        (function(x) rbind.force( results.tab, x, empty = "" ) 
        )() -> results.tab ;
      
      data.frame( `Std. Error` =  IFELSE( is.null( round ), 
                                          summary.corrected1[,2],
                                          round( summary.corrected1[,2], round ) ),
                  `z value` =  IFELSE( is.null( round ), 
                                       summary.corrected1[,3],
                                       round( summary.corrected1[,3], round ) ),
                  `Pr(>|z|)` =  IFELSE( is.null( pvalue.round ), 
                                        summary.corrected1[,4],
                                        p.round( summary.corrected1[,4], pvalue.round ) ) ) |>
        (function(x) rbind.force( colnames(summary.corrected1)[-1], x ) )()|>
        (function(x) cbind( confint.corrected1, x )  )() |>
        (function(x) rbind.force( results.tab, x, empty = "" ) 
        )() -> results.tab ;
      
      "" |> (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      c( "Degrees of freedom:", summary1$df[2],
         "Number of Coefficients:", summary1$df[1] ) |> 
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      "" |> (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      # Anova
      data.frame( Predictors = rownames( anova.corrected1 ), 
                  `LR Chisq` =  IFELSE( is.null( round ), 
                                        anova.corrected1$`Chisq`,
                                        round( anova.corrected1$`Chisq`, round ) ),
                  `Chisq Df` = anova.corrected1$Df,
                  `Residual Df` = m1$df.residual,
                  `Pr(>Chisq)` =  IFELSE( 
                    is.null( pvalue.round ), 
                    anova.corrected1$`Pr(>Chisq)`,
                    p.round( anova.corrected1$`Pr(>Chisq)`, 
                             pvalue.round ) ) ) |>
        cbind(  `Cohen's f-squared on pseudo-R-squared` = 
                  IFELSE( is.null( round ), 
                          c( NA, cohen.f2( m1, TRUE, family, data = data ) ),
                          round( c( NA, cohen.f2( m1, TRUE, family, data = data ) ), 
                                 round ) ) ) |>
        cbind( 
          AIC = IFELSE( is.null( round ), 
                        AIC( m1 ),
                        round( AIC( m1 ), round ) ) )-> 
        anova1 ;
      
      rbind.force( c( "Predictors", "Chisq",
                      "Chisq Df", "Residual Df", "Pr(>Chisq)",
                      "Cohen's f-squared on pseudo-R-squared",
                      "AIC" ),
                   anova1
      ) -> tmp.anova ;
      
      "ANODE (type 3 tests)" |> 
        (function(x) rbind.force( results.tab, x, empty = "" ) 
        )() -> results.tab ;
      
      tmp.anova |>
        (function(x) rbind.force( results.tab, x, empty = "" ) 
        )() -> results.tab ;
      
      "" |> (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      # Models infos
      c( "Multiple Cox an Snell pseuod-R-squared:", 
         IFELSE( is.null( round ), 
                 MuMIn::r.squaredLR( m1, stats::update( m1, reformulate( "1" ) ) )[1],
                 round( MuMIn::r.squaredLR( m1, stats::update( m1, reformulate( "1" ) ) )[1], 
                        round ) ),
         "Nagelkerke Adjusted pseudo-R-squared:", 
         IFELSE( is.null( round ), 
                 attr( MuMIn::r.squaredLR( m1, stats::update( m1, reformulate( "1" ) ) ),
                       "adj.r.squared"),
                 round( attr( MuMIn::r.squaredLR( m1, stats::update( m1, reformulate( "1" ) ) ),
                              "adj.r.squared"), 
                        round ) ) ) |> 
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      c( "AIC:", 
         IFELSE( is.null( round ), 
                 AIC(m1),
                 round( AIC(m1), round ) ),
         "AICc:", 
         IFELSE( is.null( round ), 
                 MuMIn::AICc(m1),
                 round( MuMIn::AICc(m1), round ) ) ) |> 
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      "" |> (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      # post hoc analysis with no plots
      
      # Dispersion 
      c( "Dispersion:", 
         IFELSE( is.null( round ), 
                 summary( m1 )$dispersion ,
                 round(  summary( m1 )$dispersion , round ) ) ) |> 
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      "" |> (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      #  Multicollinearity
      if ( length( attr( terms(m1),"term.labels") ) > 1 )
      {
        c( "Multicollinearity check" ) |> 
          (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
        
        c( "(generalized) Variance Inflation Factors:" ) |> 
          (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
        
        car::vif( m1 ) |>
          (function(x) IFELSE( is.null( round ), 
                               x,
                               round( x, round ) ) )() |>
          as.data.frame() |>
          (function(x)   cbind( Predictors = rownames(x), x ) )() -> 
          tmp.vif ;
        
        if ( ncol( tmp.vif ) == 2 ) { "VIF" -> colnames( tmp.vif )[2] }
        
        tmp.vif |>
          (function(x)  rbind.force( colnames(x), x ) )() |>
          (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
        
        "" |> (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
        
        # besley
        attr( terms( m1 ),"term.labels" ) -> Vars
        subset( data, 
                select = Vars[ 
                  !( Vars  %in% Vars[ grep( ":", Vars ) ] ) ] ) |>
          dplyr::select_if( is.numeric ) ->
          data2 
        
        VisCollin::colldiag( mod = glm(
          reformulate( colnames(data2),
                       as.character(formula)[2] ),
          family = family,
          data = data), 
          scale = FALSE, 
          center = FALSE, add.intercept = T ) -> 
          besley
        
        "Belsley criteria (computed on numeric predictors only):" |> (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
        data.frame( besley$condindx, besley$pi) |>
          (function(x) rbind( colnames(x), x ) )() |>
          (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
        "" |> (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      }
      
      #  Linearity and non-addititvity check
      c(  "Linearity and non-addititvity check" ) |> 
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab 
      
      "Best Fractional Polynomial for each numeric predictor:" |> 
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      formula |> as.character() -> formula1 ;
      
      Systematic.FP( output = formula1[2], 
                     predictors = attr( terms(m1), 'term.labels'),
                     family = family, 
                     data = data, 
                     na.omit = na.omit ) |>
        as.data.frame() |>
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      "" |> (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      # Observation with major influence
      c( "Observation with major influence" ) |> 
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      c( "Number of observations",
         "with a Cook distance",
         "over 4 / N:",
         sum( cooks.distance( m1 ) > 4 / nrow( data ) )
      ) |> 
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      "" |> (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      car::outlierTest( m1) |> 
        capture.output() |> 
        matrix(  ncol = 1) |>
        as.data.frame() |>
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      "" |> (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      "/////////////////////////////////////////////////////" |> 
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
    }
    
    if ( !FULL & ANODE )
    {
      # Anova
      data.frame( Predictors = rownames( anova.corrected1 ), 
                  `Chisq Df` = anova.corrected1$Df,
                  `Residual Df` = m1$df.residual,
                  `Chisq` =  IFELSE( is.null( round ), 
                                     anova.corrected1$`LR Chisq`,
                                     round( anova.corrected1$`Chisq`, round ) ),
                  `Pr(>Chisq)` =  IFELSE( 
                    is.null( pvalue.round ), 
                    anova.corrected1$`Pr(>Chisq)`,
                    p.round( anova.corrected1$`Pr(>Chisq)`, 
                             pvalue.round ) ) ) |>
        cbind(  `Cohen's f-squared on pseudo-R-squared` = 
                  IFELSE( is.null( round ), 
                          c(NA,cohen.f2( m1, TRUE, family, data )),
                          round( c(NA,cohen.f2( m1, TRUE, family, data )), 
                                 round ) ) ) |>
        cbind( 
          "-" = "",
          AIC = IFELSE( is.null( round ), 
                        AIC( m1 ),
                        round( AIC( m1 ), round ) ) )-> 
        anova1 ;
      
      rbind.force( c( "Predictors",
                      "Chisq Df", "Residual Df",
                      "LR Chisq", "Pr(>Chisq)",
                      "Cohen's f-squared on pseudo-R-squared",
                      "-",
                      "AIC" ),
                   anova1
      ) -> tmp.anova ;
      
      
      # Extraction
      lapply( 1:length(selected.predictors),  
              function(a){ 
                tmp.anova[ grep( selected.predictors[a],  tmp.anova[,1] ), ] } ) |> 
        (function(x) rbind.force( tmp.anova[1,], x, empty = "" ) )() |>
        unique() ->
        results.tab ;
    }
    
    
    if ( !FULL & !ANODE )
    {
      # Compute output
      data.frame( `Std. Error` =  IFELSE( is.null( round ), 
                                          summary.corrected1[,2],
                                          round( summary.corrected1[,2], round ) ),
                  `z value` =  IFELSE( is.null( round ), 
                                       summary.corrected1[,3],
                                       round( summary.corrected1[,3], round ) ),
                  `Pr(>|z|)` =  IFELSE( is.null( pvalue.round ), 
                                        summary.corrected1[,4],
                                        p.round( summary.corrected1[,4], pvalue.round ) ) ) |>
        (function(x) rbind.force( colnames(summary.corrected1)[-1], x ) )()|>
        (function(x) cbind( confint.corrected1, x ) )() -> 
        tmp.student ;
      
      # Extraction
      lapply( 1:length(selected.predictors),  
              function(a){ 
                tmp.student[ grep( selected.predictors[a],  tmp.student[,1] ), ] } ) |> 
        (function(x) rbind.force( tmp.student[1,], x, empty = "" ) )() |>
        unique() ->
        results.tab ;
    }
    
    
    # output 
    NULL -> rownames( results.tab ) ;
    NULL -> colnames( results.tab ) ;
    
    c( output, list( results.tab = results.tab ) ) -> 
      output ;
    
    return( output )
  }
  
  Multinom.Analysis <- function( outcome, predictors,
                                 data, 
                                 HMF.test = TRUE,
                                 na.omit = TRUE,
                                 FULL = TRUE, 
                                 selected.predictors = NULL,
                                 ANODE = FALSE 
  )
  {
    # Formula
    Formula.Maker( outcome, predictors ) -> 
      formula ;
    
    # model
    if ( na.omit == TRUE ) { na.omit( data ) -> data } 
    
    nnet::multinom( formula, data = data, weights = weights ) -> m1 ;
    
    formula |>
      as.character() ->
      formula2.ch ;
    
    reformulate( paste0( "0 | ", formula2.ch[3]), formula2.ch[2] ) ->
      formula2.new  ;
    
    dfidx::dfidx( data, shape = "wide", choice = formula2.ch[2] ) ->
      data.new ;
    
    mlogit::mlogit( formula2.new, 
                    data = data.new,
                    weights = weights
    ) -> m1.bis ; 
    
    m1 |> 
      (function(x) list( model = x ) )() -> 
      output ;
    
    m1.bis |> summary() -> summary1 ;
    
    m1.bis |> 
      lmtest::coeftest( 
        vcov. = sandwich::vcovCL( m1.bis,  cluster = data[, cluster.ID] )
      ) -> summary.corrected1 ;
    
    m1.bis |>
      ( function(x)
        cbind( 
          Estimate = summary.corrected1[,1],
          lmtest::coefci( x,
                          vcov. = sandwich::vcovCL( x,  
                                                    cluster = data[, cluster.ID] ),
                          level = conf.level )
        )
      )() |>
      as.data.frame() |>
      exp() |>
      (function(x) IFELSE( is.null( round ),
                           x,
                           round( x, round ) ) )() |>
      (function(x) cbind( Predictors = rownames(x), x ) )() |>
      (function(x) rbind.force( colnames(x), x ) )() -> 
      confint.corrected1 ;
    
    confint.corrected1[1,2:4] <- c( "exp(Estimate)", 
                                    paste0("exp(", 
                                           (1 - conf.level ) / 2 * 100,
                                           "%CI)"),
                                    paste0("exp(", 
                                           100 - (1 - conf.level ) / 2 * 100,
                                           "%CI)")
    ) ;
    
    m1 |>
      ( function(x) {
        car::Anova( x,
                    type = "3",
                    vcov. = sandwich::vcovCL(m1.bis,  # ATTENTION m1.bis
                                             cluster = data[, cluster.ID] )
        ) 
      }
      )() ->
      anova.corrected1 ;
    
    # prepare results 
    if (FULL)
    {
      # formula
      "Model:" -> results.tab ;
      
      formula |> 
        deparse() |> 
        (function(x) rbind.force( results.tab, x, empty = "" )
        )() -> results.tab ;
      
      "" |> (function(x) rbind.force( results.tab, x, empty = "" ) 
      )() -> results.tab ;
      
      # missing data
      c( "Observations deleted due to missingness:",
         dim( data )[1] - dim( m1$residuals )[1] ) |> 
        (function(x) rbind.force( results.tab, x, empty = "" ) 
        )() -> results.tab ;
      
      "" |> (function(x) rbind.force( results.tab, x, empty = "" ) 
      )() -> results.tab ;
      
      #  slopes and t.tests
      "Model coefficients and t-tests" |> 
        (function(x) rbind.force( results.tab, x, empty = "" )
        )() -> results.tab ;
      
      summary.corrected1[,2:3] |> 
        (function(x) IFELSE( is.null( round ),
                             x,
                             round( x, round ) ) )() |>
        (function(x) cbind( x, 
                            "Pr(>|t|)" = IFELSE(
                              is.null( pvalue.round ),
                              summary.corrected1[,4],
                              p.round( summary.corrected1[,4], 
                                       pvalue.round ) )
        ) )() |>
        (function(x) rbind.force( colnames(x), x ) )() |>
        (function(x) cbind( confint.corrected1, x) )() |>
        (function(x) rbind.force( results.tab, x, empty = "" )
        )() -> results.tab ;
      
      "" |> (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      c( "Number of Coefficients:", dim(summary1$standard.errors)[1] * dim(summary1$standard.errors)[2] ) |> 
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      "" |> (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      # Anova
      anova.corrected1 |>
        (function(x) cbind( Predictors = rownames(x), x ) )()|>
        dplyr::transmute( Predictors = Predictors,
                          `LR Chisq` =  IFELSE( is.null( round ), 
                                                `LR Chisq`,
                                                round( `LR Chisq`, round ) ),
                          `Chisq Df` = Df,
                          `Residual Df` = dim( m1$residuals)[1] - 
                            length(summary1$coefficients),
                          `Pr(>Chisq)` =  IFELSE( is.null( pvalue.round ), 
                                                  `Pr(>Chisq)`,
                                                  p.round( `Pr(>Chisq)`, pvalue.round ) ) ) |>
        cbind(   `Cohen's f-squared on pseudo-R-squared` =  IFELSE( is.null( round ), 
                                                                    cohen.f2( m1, TRUE, data = data ),
                                                                    round( cohen.f2( m1, TRUE, data = data ), 
                                                                           round ) ) ) |>
        cbind(  
          "-" = "",
          AIC = IFELSE( is.null( round ), 
                        AIC( m1 ),
                        round( AIC( m1 ), round ) )) ->
        anova1 ;
      
      rbind.force( colnames(anova1),
                   anova1,
                   empty = "" ) ->
        tmp.anova ;
      
      "ANODE (type 3 tests)" |> 
        (function(x) rbind.force( results.tab, x, empty = "" ) 
        )() -> results.tab ;
      
      tmp.anova |>
        (function(x) rbind.force( results.tab, x, empty = "" ) 
        )() -> results.tab ;
      
      "" |> (function(x) rbind.force( results.tab, x, empty = "" ) 
      )() -> results.tab ;
      
      # Models infos
      c( "Multiple Cox an Snell pseuod-R-squared:", 
         IFELSE( is.null( round ), 
                 MuMIn::r.squaredLR( m1, stats::update( m1, 
                                                 reformulate( "1" ) ) )[1],
                 round( MuMIn::r.squaredLR( m1, 
                                            stats::update( m1, reformulate( "1" ) ) )[1], 
                        round ) ),
         "Nagelkerke Adjusted pseudo-R-squared:", 
         IFELSE( is.null( round ), 
                 attr( MuMIn::r.squaredLR( m1, 
                                           stats::update( m1, reformulate( "1" ) ) ),
                       "adj.r.squared"),
                 round( attr( MuMIn::r.squaredLR( m1, 
                                                  stats::update( m1, reformulate( "1" ) ) ),
                              "adj.r.squared"), 
                        round ) ) ) |> 
        (function(x) rbind.force( results.tab, x, empty = "" ) 
        )() -> results.tab ;
      
      c( "AIC:", 
         IFELSE( is.null( round ), 
                 AIC(m1),
                 round( AIC(m1), round ) ),
         "AICc:", 
         IFELSE( is.null( round ), 
                 MuMIn::AICc(m1),
                 round( MuMIn::AICc(m1), round ) ) ) |> 
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      "" |> (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      # post hoc analysis with no plots
      
      #  Multicollinearity
      c( "Multicollinearity check" ) |> 
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      c( "(generalized) Variance Inflation Factors:", "No intercept include for computations: vifs may not be sensible" ) |> 
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      if ( length( attr( terms( formula ),"term.labels" ) ) == 1 )
      {
        data.frame( "no possible because just 1 predictor" ) -> tmp.mc ;
      } else
      {
        "" -> tmp.mc
        # vif
        car::vif( m1 ) |>
          (function(x) IFELSE( is.null( round ), 
                               x,
                               round( x, round ) ) )() |>
          as.data.frame() |>
          (function(x)  cbind( Predictors = rownames(x), x ) )() -> 
          tmp.vif ;
        
        if ( ncol( tmp.vif ) == 2 ) { "VIF" -> colnames( tmp.vif )[2] }
        
        tmp.vif |>
          (function(x) rbind.force( colnames(x), x ) )() |>
          (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
        "" |> (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
        
        # besley
        attr( terms( m1 ),"term.labels" ) -> Vars
        base::subset( data, 
                      select = Vars[ 
                        !( Vars  %in% Vars[ grep( ":", Vars ) ] ) ] ) |>
          dplyr::select_if( is.numeric ) ->
          data2 
        
        VisCollin::colldiag( mod = nnet::multinom(
          reformulate( colnames(data2),
                       as.character(formula)[2] ),
          data = data,
          model = T ), 
          scale = FALSE, 
          center = FALSE, add.intercept = T ) -> 
          besley
        
        "Belsley criteria (computed on numeric predictors only):" |> (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
        data.frame( besley$condindx, besley$pi ) |>
          (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
        "" |> (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      }
      
      tmp.mc |>
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      "" |> (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      # Independence of Irrelevant Alternatives assumption : Hauslab-McFadden test
      c( "Independence of Irrelevant Alternatives assumption" ) |> 
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      if ( HMF.test )
      {
        c( "Hauslab-McFadden test:" ) |> 
          (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
        
        hmftest.systematic( formula, data ) |>
          data.frame() |>
          (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ; 
        
        "" |> (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      }
      
      c( "Substracting each levels of outcome:" ) |> 
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      Multinomial.SubsetLevels( formula, data, round = round ) |>
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      "" |> (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      "/////////////////////////////////////////////////////" |> 
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
    }
    
    if ( !FULL & ANODE )
    {
      # Anova
      anova.corrected1 |>
        (function(x) cbind( Predictors = rownames(x), x ) )()|>
        dplyr::transmute( Predictors = Predictors,
                          `Chisq Df` = Df,
                          `Residual Df` = dim( m1$residuals)[1] - 
                            length(summary1$coefficients),
                          `LR Chisq` =  IFELSE( is.null( round ), 
                                                `LR Chisq`,
                                                round( `LR Chisq`, round ) ),
                          `Pr(>Chisq)` =  IFELSE( is.null( pvalue.round ), 
                                                  `Pr(>Chisq)`,
                                                  p.round( `Pr(>Chisq)`, pvalue.round ) ) ) |>
        cbind(   `Cohen's f-squared on pseudo-R-squared` =  IFELSE( is.null( round ), 
                                                                    cohen.f2( m1, TRUE, data = data ),
                                                                    round( cohen.f2( m1, TRUE, data = data ), 
                                                                           round ) ) ) |>
        cbind(  
          "-" = "",
          AIC = IFELSE( is.null( round ), 
                        AIC( m1 ),
                        round( AIC( m1 ), round ) )) ->
        anova1 ;
      
      rbind.force( colnames(anova1),
                   anova1,
                   empty = "" ) ->
        tmp.anova ;
      
      # Extraction
      lapply( 1:length(selected.predictors),  
              function(a){ 
                tmp.anova[ grep( selected.predictors[a],  tmp.anova[,1] ), ] } ) |> 
        (function(x) rbind.force( tmp.anova[1,], x, empty = "" ) )() |>
        unique() ->
        results.tab ;
    }
    
    
    if ( !FULL & !ANODE )
    {
      #  slopes and t.tests
      summary.corrected1[,2:3] |> 
        (function(x) IFELSE( is.null( round ),
                             x,
                             round( x, round ) ) )() |>
        (function(x) cbind( x, 
                            "Pr(>|t|)" = IFELSE(
                              is.null( pvalue.round ),
                              summary.corrected1[,4],
                              p.round( summary.corrected1[,4], 
                                       pvalue.round ) )
        ) )() |>
        (function(x) rbind.force( colnames(x), x ) )() |>
        (function(x) cbind( confint.corrected1, x) )()  -> 
        tmp.student ;
      
      # Extraction
      lapply( 1:length(selected.predictors),  
              function(a){ 
                tmp.student[ grep( selected.predictors[a],  tmp.student[,1] ), ] } ) |> 
        (function(x) rbind.force( tmp.student[1,], x, empty = "" ) )() |>
        unique() ->
        results.tab ;
    }
    
    
    # output 
    NULL -> rownames( results.tab ) ;
    NULL -> colnames( results.tab ) ;
    
    c( output, list( results.tab = results.tab ) ) -> 
      output ;
    
    return( output )
  }
  
  Ordinal.Analysis <- function( outcome, predictors,  
                                data, 
                                na.omit = TRUE,
                                FULL = TRUE, 
                                selected.predictors = NULL,
                                ANODE = FALSE 
  )
  {
    # Formula
    Formula.Maker( outcome, predictors ) -> 
      formula ;
    
    # model
    formula -> formula1 ;
    
    data -> data.clm ;
    
    if ( na.omit == TRUE ) { na.omit( data ) -> data } 
    
    MASS::polr( formula1, data = data, Hess = TRUE ) ->
      m1 ;
    
    try( ordinal::clm( formula1, data = data.clm ), silent = T  ) -> clm1
    
    m1 |> summary() -> summary1 ;
    
    summary1$coefficients |>
      as.data.frame() |>
      (function(x) data.frame( Predictors = rownames(x),
                               Estimate = x$Value,
                               lb = x$Value - qnorm( (1 - conf.level) / 2, lower.tail = FALSE ) * x$`Std. Error`,
                               ub = x$Value + qnorm( (1 - conf.level) / 2, lower.tail = FALSE ) * x$`Std. Error` 
      ) 
      )() -> ci ;
    
    c( paste( (1 - conf.level) / 2 * 100, "%" ),
       paste( (1 -(1 - conf.level) / 2 ) * 100, "%" )  ) ->
      colnames( ci )[3:4] ;
    ci[,1] -> rownames( ci ) ;
    
    ci[,-1] |>
      exp() |>
      (function(x) IFELSE( is.null( round ),
                           x,
                           round( x ) ) )() |>
      as.data.frame() |> 
      (function(x) cbind( Predictors = rownames(x), x ) )() |> 
      (function(x) rbind.force( c( colnames(x)[1], 
                                   paste( "exp of", 
                                          colnames(x)[-1] ) ), 
                                x ) )() -> 
      confint1 ;
    
    # prepare results 
    if (FULL)
    {
      # formula
      "Model:" -> results.tab ;
      
      formula |> 
        deparse() |> 
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      "" |> (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      # missing data
      c( "Observations deleted due to missingness:",
         dim( data )[1] - dim( m1$model )[1] ) |> 
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      "" |> (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      #  slopes and t.tests
      "Model coefficients and t-tests" |> 
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      summary1 |> 
        coef() |>
        as.data.frame() |>  
        dplyr::transmute( `Std. Error` =  IFELSE( is.null( round ), 
                                                  `Std. Error`,
                                                  round( `Std. Error`, round ) ),
                          `--` = "",
                          `z value` =  IFELSE( is.null( round ), 
                                               Value / `Std. Error`,
                                               round( Value / `Std. Error`, round ) ),
                          `Pr(>|z|)` =  IFELSE( is.null( pvalue.round ), 
                                                pnorm( abs( Value / `Std. Error` ), 
                                                       lower.tail = FALSE ) * 2,
                                                p.round( pnorm( abs( Value / `Std. Error` ), 
                                                                lower.tail = FALSE ) * 2,
                                                         pvalue.round ) ) ) |>
        (function(x) rbind.force( colnames(x), x) )()  |>
        (function(x)  cbind( confint1, x )  )() |>
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      "" |> (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      c( "Degrees of freedom:", summary1$df.residual,
         "Number of Coefficients:", length(coef(m1)) + length(m1$zeta) ) |> 
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      "" |> (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      # Anova
      m1 |>
        car::Anova( type = 3) |>
        as.data.frame() |>
        (function(x) cbind( Predictors = rownames(x), x ) )() |>
        dplyr::transmute( Predictors = Predictors,
                          `LR Chisq` =  IFELSE( is.null( round ), 
                                                `LR Chisq`,
                                                round( `LR Chisq`, round ) ),
                          `Chisq Df` = Df,
                          `Residual Df` = m1$df.residual,
                          `--` = "",
                          `Pr(>Chisq)` =  IFELSE( is.null( pvalue.round ), 
                                                  `Pr(>Chisq)`,
                                                  p.round( `Pr(>Chisq)`, pvalue.round ) ) ) |>
        cbind(  `Cohen's f-squared on pseudo-R-squared` =  IFELSE( is.null( round ), 
                                                                   cohen.f2( m1, TRUE ),
                                                                   round( cohen.f2( m1, TRUE ), 
                                                                          round ) ) ) |>
        cbind( 
          `--` = "",
          AIC = IFELSE( is.null( round ), 
                        AIC( m1 ),
                        round( AIC( m1 ), round ) )) ->
        anova1 ;
      
      # fusion anova and CI
      c( confint1[1,], 
         colnames(anova1)[-1] ) |>
        matrix( nrow = 1 ) -> 
        tmp.anova ;
      
      for ( a in as.character(anova1$Predictors) )
      {
        c( confint1[1,], 
           colnames(anova1)[-1] ) |>
          matrix( nrow = 1 ) -> 
          tmp.anova ;
        
        for ( a in as.character(anova1$Predictors) )
        {
          confint1[grep( a, confint1[,1] ) , ] -> tmp.ci1
          
          anova1[grep( a, anova1[,1] ) , ] -> tmp.anova1
          
          if ( !grepl( ":", a ) )
          {
            if ( length( grep( ":", tmp.ci1[,1] ) ) > 0 )
            {
              tmp.ci1[ -grep( ":", tmp.ci1[,1] ) , ] -> tmp.ci1
              
              tmp.anova1[ -grep( ":", 
                                 as.character( tmp.anova1[,1] ) 
              ),  ] -> 
                tmp.anova1
            }
          }
          
          if ( grepl( ":", a ) )
          {
            strsplit( a, ":" ) |>
              unlist() ->
              sub.names.interaction
            
            confint1 -> tmp.ci1
            for ( b in sub.names.interaction )
            {
              tmp.ci1[grep( b, tmp.ci1[,1] ) , ] -> tmp.ci1
            }
          }
          
          cbind.force( tmp.ci1,
                       tmp.anova1[, -1 ],
                       empty = "" ) |>
            (function(x) rbind.force( tmp.anova,
                                      x,
                                      empty = "" ) )() ->
            tmp.anova ;
        }
      }
      
      "ANODE (type 3 tests)" |> 
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      tmp.anova |>
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      "" |> (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      # Models infos
      c( "Multiple Cox an Snell pseuod-R-squared:", 
         IFELSE( is.null( round ), 
                 MuMIn::r.squaredLR( m1, stats::update( m1, reformulate( "1" ) ) )[1],
                 round( MuMIn::r.squaredLR( m1, stats::update( m1, reformulate( "1" ) ) )[1], 
                        round ) ),
         "Nagelkerke Adjusted pseudo-R-squared:", 
         IFELSE( is.null( round ), 
                 attr( MuMIn::r.squaredLR( m1, stats::update( m1, reformulate( "1" ) ) ),
                       "adj.r.squared"),
                 round( attr( MuMIn::r.squaredLR( m1, stats::update( m1, reformulate( "1" ) ) ),
                              "adj.r.squared"), 
                        round ) ) ) |> 
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      c( "AIC:", 
         IFELSE( is.null( round ), 
                 AIC(m1),
                 round( AIC(m1), round ) ),
         "AICc:", 
         IFELSE( is.null( round ), 
                 MuMIn::AICc(m1),
                 round( MuMIn::AICc(m1), round ) ) ) |> 
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      "" |> (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      # post hoc analysis with no plots
      
      #  Multicollinearity
      c( "Multicollinearity check" ) |> 
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      c( "(generalized) Variance Inflation Factors:", "No intercept: vifs may not be sensible" ) |> 
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      if ( length( attr( terms( formula ),"term.labels" ) ) == 1 )
      {
        data.frame( "no possible because just 1 predictor" ) -> tmp.mc ;
      } else
      {
        "" -> tmp.mc
        # vif
        car::vif( m1 ) |>
          (function(x) IFELSE( is.null( round ), 
                               x,
                               round( round ) ) )() |>
          as.data.frame() |>
          (function(x) cbind( Predictors = rownames(x), x ) )() -> 
          tmp.vif ;
        
        if ( ncol( tmp.vif ) == 2 ) { "VIF" -> colnames( tmp.vif )[2] }
        
        tmp.vif |>
          (function(x) rbind.force( colnames(x), x) )() |>
          (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
        "" |> (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
        
        # besley
        attr( terms( m1 ),"term.labels" ) -> Vars
        subset( data, 
                select = Vars[ 
                  !( Vars  %in% Vars[ grep( ":", Vars ) ] ) ] ) |>
          dplyr::select_if( is.numeric ) ->
          data2 
        
        VisCollin::colldiag( mod = MASS::polr(
          reformulate( colnames(data2),
                       as.character(formula)[2] ),
          data = data ), 
          scale = FALSE, 
          center = FALSE, add.intercept = T ) -> 
          besley
        
        "Belsley criteria (computed on numeric predictors only):" |> (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
        data.frame( besley$condindx, besley$pi) |>
          (function(x) rbind( colnames(x), x ) )() |>
          (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
        "" |> (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
        
      }
      
      tmp.mc |>
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      "" |> (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      # Proportional odds assumptions
      c( "Proportional odds assumption" ) |> 
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      c( "Test of Brant:" ) |> 
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      if ( length( grep( ":", attr( terms( m1 ), "term.labels" ) ) ) == 0 &
           length( attr( terms( m1 ), "term.labels" )  ) > 1)
      {
        brant.perso(m1) |> 
          as.matrix() |> 
          (function(x) data.frame( rownames(x), x) )() |>
          setNames( c( "Predictors", "Chisq", "df", "p" ) ) |> 
          (function(x) data.frame( Predictors = x$Predictors, "Chisq" = IFELSE( is.null(round), 
                                                                                x[,"Chisq"], 
                                                                                round( x[,"Chisq"], round) ),
                                   "p" = IFELSE( is.null( pvalue.round ), 
                                                 x[,"p"], 
                                                 p.round( x[,"p"], pvalue.round ) )
          ) )() |> 
          (function(x) rbind( colnames(x), x ) )() |> 
          (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
        "" |> (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      } else
      {
        "test is not applicable because presence of interacions or because just 1 predictor" |> 
          (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
        "" |> (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      }
      
      c( "Nominal test:" ) |> 
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      if (attr( clm1,"class") == "try-error" )
      {
        "Nominal test not computable" -> output ; 
      } else
      {
        nominal_test.perso( clm1, formula1, data.clm ) |>
          setNames( c( "Predictors", "Df", "logLik", "AIC", "LRT", "Pr(>Chi)" ) ) |> 
          (function(x) data.frame( "logLik" = IFELSE( is.null(round), 
                                                      x[,"logLik"], 
                                                      round( x[,"logLik"], round) ),
                                   "AIC" = IFELSE( is.null(round), 
                                                   x[,"AIC"], 
                                                   round( x[,"AIC"], round) ),
                                   "LRT" = IFELSE( is.null(round), 
                                                   x[,"LRT"], 
                                                   round( x[,"LRT"], round) ),
                                   "Pr(>Chi)" = IFELSE( is.null( pvalue.round ), 
                                                        x[,"Pr(>Chi)"], 
                                                        p.round( x[,"Pr(>Chi)"], pvalue.round ) )
          ) )() |> 
          (function(x) rbind( colnames(x), x ) )() |> 
          (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      }
      
      
      "" |> (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
      
      "/////////////////////////////////////////////////////" |> 
        (function(x) rbind.force( results.tab, x, empty = "" ) )() -> results.tab ;
    }
    
    if ( !FULL & ANODE )
    {
      # Anova
      m1 |>
        car::Anova( type = 3) |>
        as.data.frame() |>
        (function(x) cbind( Predictors = rownames(x), x ) )() |>
        dplyr::transmute( Predictors = Predictors,
                          `LR Chisq` =  IFELSE( is.null( round ), 
                                                `LR Chisq`,
                                                round( `LR Chisq`, round ) ),
                          `Chisq Df` = Df,
                          `Residual Df` = m1$df.residual,
                          `--` = "",
                          `Pr(>Chisq)` =  IFELSE( is.null( pvalue.round ), 
                                                  `Pr(>Chisq)`,
                                                  p.round( `Pr(>Chisq)`, pvalue.round ) ) ) |>
        cbind(  `Cohen's f-squared on pseudo-R-squared` =  IFELSE( is.null( round ), 
                                                                   cohen.f2( m1, TRUE ),
                                                                   round( cohen.f2( m1, TRUE ), 
                                                                          round ) ) ) |>
        cbind( 
          `--` = "",
          AIC = IFELSE( is.null( round ), 
                        AIC( m1 ),
                        round( AIC( m1 ), round ) )) ->
        anova1 ;
      
      # fusion anova and CI
      c( confint1[1,], 
         colnames(anova1)[-1] ) |>
        matrix( nrow = 1 ) -> 
        tmp.anova ;
      
      for ( a in as.character(anova1$Predictors) )
      {
        c( confint1[1,], 
           colnames(anova1)[-1] ) |>
          matrix( nrow = 1 ) -> 
          tmp.anova ;
        
        for ( a in as.character(anova1$Predictors) )
        {
          confint1[grep( a, confint1[,1] ) , ] -> tmp.ci1
          
          anova1[grep( a, anova1[,1] ) , ] -> tmp.anova1
          
          if ( !grepl( ":", a ) )
          {
            if ( length( grep( ":", tmp.ci1[,1] ) ) > 0 )
            {
              tmp.ci1[ -grep( ":", tmp.ci1[,1] ) , ] -> tmp.ci1
              
              tmp.anova1[ -grep( ":", 
                                 as.character( tmp.anova1[,1] ) 
              ),  ] -> 
                tmp.anova1
            }
          }
          
          if ( grepl( ":", a ) )
          {
            strsplit( a, ":" ) |>
              unlist() ->
              sub.names.interaction
            
            confint1 -> tmp.ci1
            for ( b in sub.names.interaction )
            {
              tmp.ci1[grep( b, tmp.ci1[,1] ) , ] -> tmp.ci1
            }
          }
          
          cbind.force( tmp.ci1,
                       tmp.anova1[, -1 ],
                       empty = "" ) |>
            (function(x) rbind.force( tmp.anova,
                                      x,
                                      empty = "" ) )() ->
            tmp.anova ;
        }
      }
      
      # Extraction
      lapply( 1:length(selected.predictors),  
              function(a){ 
                tmp.anova[ grep( selected.predictors[a],  tmp.anova[,1] ), ] } ) |> 
        (function(x) rbind.force( tmp.anova[1,], x, empty = "" ) )() |>
        unique() ->
        results.tab ;
    }
    
    if ( !FULL & !ANODE )
    {
      # Compute output
      summary1 |> 
        coef() |>
        as.data.frame() |>  
        (function(x) data.frame( `Std. Error` =  IFELSE( is.null( round ), 
                                                         x$`Std. Error`,
                                                         round( x$`Std. Error`, round ) ),
                                 `--` = "",
                                 `z value` =  IFELSE( is.null( round ), 
                                                      x$Value / x$`Std. Error`,
                                                      round( x$Value / x$`Std. Error`, round ) ),
                                 `Pr(>|z|)` =  IFELSE( is.null( pvalue.round ), 
                                                       pnorm( abs( x$Value / x$`Std. Error` ), 
                                                              lower.tail = FALSE ) * 2,
                                                       p.round( pnorm( abs( x$Value / x$`Std. Error` ), 
                                                                       lower.tail = FALSE ) * 2,
                                                                pvalue.round ) ) ) )() |>
        (function(x) rbind.force( colnames(x), x) )()  |>
        (function(x) cbind( confint1, x ) )()  -> 
        tmp.student ;
      
      # Extraction
      lapply( 1:length(selected.predictors),  
              function(a){ 
                tmp.student[ grep( selected.predictors[a],  tmp.student[,1] ), ] 
              } ) |> 
        (function(x) rbind.force( tmp.student[1,], x, empty = "" ) )() |>
        unique() ->
        results.tab ;
    }
    
    
    # output 
    NULL -> rownames( results.tab ) ;
    NULL -> colnames( results.tab ) ;
    
    list( model = m1,  results.tab = results.tab  ) -> 
      output ;
    
    return( output )
  }
  
  Lm.Plot <- function( model, ExportName )
  {
    # Pair graphics on variables
    pairs2( subset( model$model, select = 1),
            subset( model$model, select = -1),
            ExportName, 3 )
    
    # Terms plot
    if ( length( attr( terms(model),"term.labels") ) < 7 &
         all( !grepl( ":", attr( terms(model),"term.labels") ) ) )
    {
      termplot2.w(model, ExportName )
    }
    
    # Normality Study
    png( paste( ExportName,
                "Normality_Study_of_Studendized_Residuals",
                ".png",
                sep = "" ) )
    MASS::studres( model ) |> Normality.Plot.Unique(  "Studendized Residuals") ;
    dev.off() ;
    
    # Added variables plot
    avPlots2.w( model, ExportName ) ;
    
    # Component + residuals  plot
    if ( all( !grepl( ":", attr( terms(model),"term.labels") ) ) )
    {
      crPlots2.w( model, ExportName )
    }
    
    #  Cook's distance and Leverage graphics
    png( paste( ExportName,
                "Cooksdistance_and_Leverage_Graphics",
                ".png",
                sep = "" ),
         width = 270,
         height = 600 )
    par( mfrow = c( 3, 1), oma = c( 0, 0, 2, 0) )
    plot( model , c(5:6), ask = FALSE, sub.caption = "")
    dotchart( sort( sort( cooks.distance( model ), decreasing = T )[1:15] ),
              main = "Top 15 Cook's distances",
              xlab = "Cook distance",
              sub = paste( "cutoff:",
                           round( 4 / (length( cooks.distance( model ) ) ), 2 ) ) )
    abline( v = 4 / (nrow( model$model ) ),
            col = "red" )
    mtext( text =  "Cook's distance and Leverage Graphics",
           outer = TRUE, cex = 1.2 ) ;
    dev.off() ;
  }
  
  Glm.Plot <- function( model, ExportName )
  {
    # Pair graphics on variables
    data.frame( model$fitted.values ) |>
      magrittr::set_colnames( paste( "fitted.LogOR",
                                     as.character( terms(model) )[2],
                                     sep = ".")  ) |>
      pairs2( 
        subset( model$model, select = -1),
        ExportName, 7 )
    
    # Terms plot
    if ( length( attr( terms(model),"term.labels") ) < 7 &
         all( !grepl( ":", attr( terms(model),"term.labels") ) ) )
    {
      termplot2.w(model, ExportName )
    }
    
    # Added variables plot
    model |> avPlots2.w( ExportName ) ;
    
    # Component + residuals  plot
    if ( all( !grepl( ":", attr( terms(model),"term.labels") ) ) )
    {
      crPlots2.w( model, ExportName  )
    }
    
    # Residuals vs Fitted
    png( paste( ExportName,
                "Residuals_vs_Fitted",
                ".png",
                sep = "" ),
         width = 270,
         height = 600 )
    par( mfrow = c( 3, 1), oma = c( 0, 0, 2, 0) )
    plot( model , c(1), ask = FALSE, sub.caption = "")
    car::residualPlot( model, col.quad = "red")
    plot( model$fitted.values,
          sqrt( abs( residuals( model, type = "pearson" ) ) ),
          ylab = "sqrt( | Pearson's reisduals | )",
          xlab =  "Fitted values",
          main = "Scale-Location"
    )
    car::loessLine( model$fitted.values,
                    sqrt( abs( residuals( model, type = "pearson" ) ) ),
                    col = "red" )
    mtext( text =  "Residuals vs Fitted Graphics",
           outer = TRUE, cex = 1.5 ) ;
    dev.off() ;
    
    #  Cook's distance and Leverage graphics
    png( paste( ExportName,
                "Cooksdistance_and_Leverage_Graphics",
                ".png",
                sep = "" ),
         width = 270,
         height = 600 )
    par( mfrow = c( 3, 1), oma = c( 0, 0, 2, 0) )
    plot( model , c(5:6), ask = FALSE, sub.caption = "")
    dotchart( sort( sort( cooks.distance( model ), decreasing = T )[1:15] ),
              main = "Top 15 Cook's distances",
              xlab = "Cook distance",
              sub = paste( "cutoff:",
                           round( 4 / (length( cooks.distance( model ) ) ), 2 ) ) )
    abline( v = 4 / (length( cooks.distance( model ) ) ),
            col = "red" )
    mtext( text =  "Cook's distance and Leverage Graphics",
           outer = TRUE, cex = 1.2 ) ;
    dev.off() ;
  }
  
  Multinom.Plot <- function( model, data, ExportName )
  {
    # Pair graphics on variables
    attr( terms( model ),"term.labels" ) -> Vars
    
    data.frame( model$fitted.values ) |>
      (function(x) magrittr::set_colnames( x, paste( "fitted.LogOR",
                                                     colnames(x),
                                                     sep = ".")  ) )() |>
      pairs2(
        data.frame(
          subset( data,
                  select = Vars[
                    !( Vars  %in% Vars[ grep( ":", Vars ) ] ) ] )),
        ExportName, 2 )
    
    # Residuals vs Fitted
    model$fitted.values |>
      as.data.frame() |>
      tidyr::gather( key = Levels, value = Fitted  ) ->
      Fitted1 ;
    
    model$residuals |>
      as.data.frame() |>
      tidyr::gather( key = levels1, value = Residuals  ) |>
      dplyr::select( -levels1 ) ->
      Resid1 ;
    
    cbind( Fitted1, Resid1 ) |>
      ggplot() +
      geom_point( aes( x = Fitted, y = Residuals ) ) +
      facet_grid( . ~ Levels, scales = "free" ) +
      labs( title = "Residuals vs Fitted for cumulative link models" ) ->
      g1 ;
    
    paste( ExportName,
           "Residuals_vs_Fitted",
           ".png",
           sep = "" ) |>
      ggsave( g1, width = 8, height = 3 ) ;
  }
  
  Ordinal.Plot <- function( model, ExportName )
  {
    # Pair graphics on variables 
    data.frame( model$fitted.values ) |>
      (function(x) magrittr::set_colnames( x, paste( "fitted.LogOR",
                                                     colnames(x),
                                                     sep = ".")  ) )() |>
      pairs2( 
        subset( model$model, select = -1), 
        ExportName, 2 )
    
    # Residuals vs Fitted
    model$fitted.values |>
      as.data.frame() |>
      tidyr::gather( key = Levels, value = Fitted  ) -> 
      Fitted1 ;
    
    model |>
      residuals.polr() |>
      as.data.frame() |>
      tidyr::gather( key = levels1, value = Residuals  ) |>
      dplyr::select( -levels1 ) -> 
      Resid1 ;
    
    cbind( Fitted1, Resid1 ) |> 
      ggplot() +
      geom_point( aes( x = Fitted, y = Residuals ) ) +
      facet_grid( . ~ Levels, scales = "free" ) +
      labs( title = "Residuals vs Fitted for the cumulative link models" ) -> 
      g1 ;
    
    paste( ExportName,
           "Residuals_vs_Fitted",
           ".png",
           sep = "" ) |>
      ggsave( g1, width = 8, height = 3 ) ;
  }
  
  fun.a <- function( a )
  {
    
    lapply( 1:length( changing.predictors ),
            fun.b,
            a = a ) |>
      rbind.force(
        empty = "" ) ->
      output.a
    
    return( output.a )
  }
  
  fun.a.parallel <- function( a )
  {
    
    furrr::future_map( 1:length( changing.predictors ),
                       fun.b,
                       a = a,
                       .options = furrr::furrr_options(seed = TRUE), .progress = T 
    ) |>
      rbind.force(
        empty = "" ) ->
      output.a
    
    return( output.a )
  }
  
  fun.b <- function( b, a )
  {
    print( "a : ") ;  print( a ); print( "b : ") ; print(b)
    
    # Prepare base name for graphics
    paste0( ExportName,
            families[a], "_",
            outcomes[[a]],
            "_Model_",
            b,
            "_"
    ) -> BasePlotName ;
    
    # Do job selecting modeling family
    if ( families[a] == "gaussian" )
    {
      Lm.Analysis(  outcome = outcomes[[a]],
                    predictors = c( changing.predictors[[b]],
                                    fixed.predictors ),
                    data = data, 
                    na.omit = na.omit,
                    FULL = FULL, 
                    selected.predictors = changing.predictors[[b]],
                    ANOVA = ANOVA.ANODE ) -> 
        tmp.output
      
      if ( PLOT )
      {
        Lm.Plot( tmp.output$model,
                 BasePlotName )
      }
    }
    
    if ( families[a] %in%  c( "binomial", "poisson", "quasibinomial", "quasipoisson" ) )
    {
      Glm.Analysis(  outcome = outcomes[[a]],
                     predictors = c( changing.predictors[[b]],
                                     fixed.predictors ),
                     family = families[a],
                     data = data, 
                     na.omit = na.omit,
                     FULL = FULL, 
                     selected.predictors = changing.predictors[[b]],
                     ANODE = ANOVA.ANODE ) -> 
        tmp.output
      
      if ( PLOT )
      {
        Glm.Plot( tmp.output$model,
                  BasePlotName )
      }
    }
    
    if ( families[a] == "multinomial" )
    {
      Multinom.Analysis(  outcome = outcomes[[a]],
                          predictors = c( changing.predictors[[b]],
                                          fixed.predictors ),
                          data = data, 
                          HMF.test = HMF.test,
                          na.omit = na.omit,
                          FULL = FULL, 
                          selected.predictors = changing.predictors[[b]],
                          ANODE = ANOVA.ANODE ) -> 
        tmp.output
      
      if ( PLOT )
      {
        Multinom.Plot( tmp.output$model,
                       data = data,
                       BasePlotName )
      }
    }
    
    if ( families[a] == "ordinal" )
    {
      Ordinal.Analysis(  outcome = outcomes[[a]],
                         predictors = c( changing.predictors[[b]],
                                         fixed.predictors ),
                         data = data, 
                         na.omit = na.omit,
                         FULL = FULL, 
                         selected.predictors = changing.predictors[[b]],
                         ANODE = ANOVA.ANODE ) -> 
        tmp.output
      
      if ( PLOT )
      {
        Ordinal.Plot( tmp.output$model,
                      BasePlotName )
      }
    }
    
    # output
    tmp.output$results.tab -> output.b ;
    
    cbind( Outcome = outcomes[[a]], 
           Families = families[a],
           Predictors = String.Contatener( c( changing.predictors[[b]],
                                              fixed.predictors),
                                           separator = "." ),
           output.b ) -> 
      output.b ;
    
    return( output.b )
  }
  
  # Active Packages 
  download.packages( "furrr", "nnet", "MASS", "ordinal",
                     "MuMIn", "car", "sandwich",
                     "heplots", "lmtest", "mfp", 
                     "moments", "nortest", "dplyr", "tidyr", 
                     "magrittr",
                     "ggplot2", "mlogit", "dfidx", "brant", 
                     "VisCollin",
                     "mctest", "ggplot2" )
  
  require( ggplot2 )
  
  # NA
  cbind( data, weights ) -> data ;
  if ( na.omit == TRUE ) { na.omit( data ) -> data } 
  
  # job
  if ( parallel.outcomes )
  {
    furrr::future_map(
      1:length( outcomes  ), 
      fun.a,
      .options = furrr::furrr_options(seed = TRUE), .progress = T 
    ) |>
      rbind.force( 
        empty = "" ) -> 
      output ;
  }
  else
  {
    purrr::map(
      1:length( outcomes  ), 
      fun.a.parallel
    ) |>
      rbind.force( 
        empty = "" ) -> 
      output ;
  }
  
  # end parallel
  future::plan("sequential")
  
  # Output 
  return( output )
}

# 1.5.3 Function to perform bivariate analysis cluster robust
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Bivariate.Analysis.ClusterRobust <- function( data, 
                                              group, 
                                              identifier,
                                              na.rm = TRUE,
                                              seed = 123,
                                              pvalue.round = 3,
                                              round = 2,
                                              ncores = NULL )
  
{
  # Conditions for input
  if ( !is.data.frame( data ) ) { stop( "data is not a data.frame" );  } ;
  if ( !is.character( group ) ) { stop( "groups is not character" );   } ;
  if ( !is.character( identifier ) ) { stop( "identifier is not character" );   } ;
  if ( !(group %in% colnames( data ) ) ) { stop(  "group is not in data"  );   } ;
  if ( !(identifier %in% colnames( data ) ) ) { stop(  "identifier is not in data"  );   } ;
  if ( !is.logical( na.rm ) ) { stop( "na.rm is not TRUE or FALSE" );   } ;
  if ( !is.numeric( seed ) ) { stop( "seed is not numeric" );   } ;
  if ( !( is.numeric( pvalue.round ) | 
          is.null( pvalue.round ) ) ) { stop( "pvalue.round is neither numeric, neither NULL" );    } ;
  if ( !( is.numeric( round ) | 
          is.null( round ) ) ) { stop( "round is neither numeric, neither NULL" );    } ;
  if ( !is.null(ncores) & !is.numeric(ncores) ) { stop( "ncores is not null nor numeric" ) }
  
  # parallel
  if ( !is.null( ncores ) ) { future::plan( "multisession",  workers = ncores ) }
  
  # custom functions
  download.packages <- function( PackagesNames, ... )
  {
    # Get a vector with packages names 
    packages1 <- c( PackagesNames, ... ) ;
    
    # Install packages
    for (a in 1:length( packages1 ) )
    {
      try( find.package( packages1[a]), silent = TRUE ) -> test ;
      
      if ( class( test ) == "try-error" )
      { print( packages1[a] ) ; 
        install.packages(  packages1[a] ) ;
      } 
    }
  } ;
  
  rbind.force <- function( data, ..., keep.col = FALSE, empty = NA ) 
  {
    # Unify data
    list( data, ... ) -> input ;
    
    # include list elements
    repeat 
    {
      if (  !any( unlist( lapply( input, class ) ) == "list" ) ) { break }  
      
      which( unlist( lapply( input, class ) ) == "list" )[1] -> a ;
      input[[a]] -> tmp ;
      input[[a]] <- NA ;
      c( input[1:a],  tmp, input[ (a + 1):length( input ) ] ) -> 
        input ;
    }
    
    input[ !is.na( input ) ] ->
      input ;
    
    # delete NULL data and transformt vector in data.frame
    for ( a in 1:length( input ) )
    {
      if ( is.null( dim( input[[a]] ) ) )
      {
        if ( is.null( input[[a]] ) )
        {
          input[[a]] <- NA ;
        } else
        {
          data.frame( matrix( input[[a]], nrow = 1 ),
                      stringsAsFactors = FALSE ) -> input[[a]] ; 
        }
      }
      
      if ( all( dim( input[[a]] ) == 0 ) )
      {
        input[[a]] <- NA ;
      }
    }
    
    input[ !is.na( input ) ] ->
      input ;
    
    # test data class
    if ( !all( unlist( lapply( input, is.data.frame ) ) |
               unlist( lapply( input, is.matrix ) ) |
               unlist( lapply( input, is.vector ) ) ) )
    { stop( "Some argument are not data.frame, neither vector" ) ;
      ; } ;
    
    # Set primer
    input[[1]] -> output ; 
    
    # job in case we keep columns 
    if ( keep.col & length( input ) >1 )
    {
      for ( a in 2:length( input ) )
      { 
        output -> x ;
        input[[a]] -> y ; 
        
        for (a in 1:dim(x)[2]) { x[,a] <- as.character(x[,a])}
        for (a in 1:dim(y)[2]) { y[,a] <- as.character(y[,a])}
        
        x.diff <- setdiff(colnames(x), colnames(y))
        y.diff <- setdiff(colnames(y), colnames(x))
        
        if( dim(x)[1] > 0 ) { x[, c(as.character(y.diff))] <- empty ; }
        if( dim(y)[1] > 0 ) { y[, c(as.character(x.diff))] <- empty ; }
        
        rbind(x, y) -> output ;
      } 
    }
    
    # job in case we do not keep columns
    if ( !keep.col & length( input ) >1 )
    {
      for ( a in 2:length( input ) )
      { 
        output -> x ;
        input[[a]] -> y ; 
        
        colnames(x) <- paste( "X",
                              1:dim( x )[2], 
                              sep = "" ) ;
        colnames(y) <- paste( "X",
                              1:dim( y )[2], 
                              sep = "" ) ;
        
        for (a in 1:dim(x)[2]) { x[,a] <- as.character(x[,a])}
        for (a in 1:dim(y)[2]) { y[,a] <- as.character(y[,a])}
        
        x.diff <- setdiff(colnames(x), colnames(y))
        y.diff <- setdiff(colnames(y), colnames(x))
        
        if( dim(x)[1] > 0 ) { x[, c(as.character(y.diff))] <- empty ; }
        if( dim(y)[1] > 0 ) { y[, c(as.character(x.diff))] <- empty ; }
        
        rbind(x, y) -> output ;
      } 
    }
    
    return( output ) ;
  } 
  
  p.round <- function( data, digits = 3 )
  {
    if (digits == 1)
    { "" -> tmp1 ; } else 
    { rep( "0", digits - 1 ) -> tmp1 ; }
    
    "0." -> tmp2 ;
    for( a in 1:length(tmp1) )
    {
      paste( tmp2, tmp1[a], sep = "" ) -> tmp2 ;
    }
    
    paste( tmp2, "1", sep = "" ) -> pval ;
    
    for ( a in 1:length(data) )
    {
      if ( !is.na( data[a] ) )
      {
        if ( data[a] >= as.numeric( pval ) )
        {
          round( data[a], digits = digits ) -> data[a] ;
        }
      }
    }
    
    data[ data < as.numeric( pval ) ] <- paste( "< ", pval, sep = "" ) ;
    
    return( data ) ;
  }
  
  cohen.f2 <- function( model, pseudo.R2 = FALSE, family, data )
  {
    attr(terms(model), 'term.labels') -> terms1 ; 
    as.character( terms(model) )[2] -> outcome ;
    
    NULL -> f2 ;
    
    if ( !pseudo.R2 )
    {
      for ( a in 1:length(terms1) )
      {
        if ( length(terms1) == 1 )
        { 
          stats::update( model, reformulate( "1" ), data = data ) -> model.bis 
        } else
        {
          stats::update( model, reformulate( terms1[-a] ) ) -> model.bis ; 
        }
        
        c( f2, 
           (summary( model )$r.squared -  summary( model.bis  )$r.squared ) / (1 - summary( model )$r.squared) ) -> 
          f2 ;
      }
    }  
    
    if ( pseudo.R2 & any( class( model ) == "glm" ) )
    {
      for ( a in 1:length(terms1) )
      {
        if ( length(terms1) == 1 )
        { 
          stats::update( model, reformulate( "1", outcome ),
                         data = data )-> model.bis ;
        } else
        {
          stats::update( model, reformulate( terms1[-a], outcome ), family = family ) -> model.bis ; 
        }
        
        c( f2, 
           (MuMIn::r.squaredLR( model, stats::update( model, reformulate( "1", outcome ), family = family, data = data  ) )[1] -  MuMIn::r.squaredLR( model.bis, stats::update( model, reformulate( "1" ), family = family, data = data ) )[1]  ) / (1 -  MuMIn::r.squaredLR( model, stats::update( model, reformulate( "1", outcome ), family = family, data = data ) )[1] )  ) -> 
          f2 ;
      }
    }
    
    if ( pseudo.R2 & all( class( model ) != "glm" ) )
    {
      for ( a in 1:length(terms1) )
      {
        if ( length(terms1) == 1 )
        { 
          stats::update( model, reformulate( "1", outcome ),
                         data = data ) -> model.bis ;
        } else
        {
          stats::update( model, reformulate( terms1[-a], outcome ) ) -> model.bis ; 
        }
        
        c( f2, 
           (MuMIn::r.squaredLR( model, 
                                stats::update( model, 
                                               reformulate( "1", outcome ),
                                               data = data ) )[1] -  
              MuMIn::r.squaredLR( model.bis, stats::update( model, 
                                                            reformulate( "1" ),
                                                            data = data ) )[1]  ) / 
             (1 -  MuMIn::r.squaredLR( model, stats::update( model, reformulate( "1", outcome ), data = data ) )[1] )  ) -> 
          f2 ;
      }
    }
    
    terms1 -> names( f2 ) ;
    
    return( f2 )
  }
  
  fun.a <- function( a, data.vars,  data.group, 
                     data.identifier, 
                     group )
  {
    print( "a") ; print( a ) ; print( colnames( data.vars )[a] ) ;
    
    # Prepara data
    data.vars[,a] -> data.var1 ; 
    
    data.vars[, which( !( colnames( data.vars ) %in% colnames( data.vars )[a] ) ) ] -> 
      data.vars2 ; 
    
    rbind.force( 
      lapply( 1:dim( data.vars2 )[2], 
              FUN = fun.b,
              data.vars2 = data.vars2, 
              data.var1 = data.var1,
              data.group = data.group, 
              data.identifier = data.identifier, 
              group = group,
              identifier = identifier,
              name.a = colnames(data.vars)[a]
      ),
      empty = "" ) -> 
      output.a ;
    
    return( output.a )
  } 
  
  fun.b <- function( b, data.vars2, 
                     data.var1,
                     data.group,
                     data.identifier,
                     group,
                     identifier,
                     name.a  )
  {
    print( "b") ; print( b ) ; print( colnames( data.vars2 )[b] ) ; 
    
    require(ordinal) ; 
    
    # Prepare data
    data.frame( var1 = data.var1,
                var2 = data.vars2[,b], 
                GROUP = factor( data.group ), 
                ID = as.factor( as.character( data.identifier ) ) ) ->
      df1 ;
    
    # NA
    if ( na.rm )
    {
      na.omit( df1 ) -> df1 ;
      
      factor( df1$GROUP ) -> df1$GROUP ;
      factor( df1$ID ) -> df1$ID ;
      
      if ( is.factor(df1$var1) ) 
      { factor( df1$var1 ) -> df1$var1 ; }
      if ( is.factor(df1$var2) ) 
      { factor( df1$var2 ) -> df1$var2 ; }
    }
    
    # primer
    NULL -> output.b ;
    
    # job
    
    # factor 2 levels & factor
    if ( is.factor( df1$var1 ) &
         is.factor( df1$var2 ) )
    {
      if (
        nlevels( df1$var1 ) == 2 &
        nlevels( df1$var2 ) > 1 &
        all( table( df1$var1, df1$var2 ) > 5 )
      )
      {
        "var1 ~ var2" |> 
          as.formula() |>
          glm( family = "binomial", data = df1 ) ->
          m1 ;
        
        m1 |>
          ( function(x) {
            car::Anova( x, 
                        type = "3",
                        test.statistic = c("Wald"),
                        vcov. = sandwich::vcovCL(m1,  # ATTENTION m1.bis
                                                 cluster = ~GROUP )
            ) 
          }
          )() -> 
          anova1 ;
        
        cohen.f2( m1, family = "binomial", pseudo.R2 = T,
                  data = df1 ) -> f2 ; 
        
        residuals( m1 ) -> residuals ;
        if ( length( matrix(residuals) ) < 5000 ) 
        { shapiro.test( matrix(residuals) ) -> shapiro.res ; }  else
        { list( "p.value" = NA ) -> shapiro.res ; }
        nortest::ad.test( matrix(residuals) ) -> anderson.res ;
        moments::jarque.test( residuals ) -> jarque.res ;
        
        c( "binomial", 
           name.a, 
           colnames( data.vars2 )[b], 
           group,
           nrow(df1), nrow(data.vars2) - nrow(df1),
           anova1["var2",3], 
           "Analysis of Deviance Table (Type III tests) - Cluster robust and  heteroscedasticity robust test",
           anova1["var2",1],
           nrow(df1) - anova1["var2",1],
           anova1["var2",2],
           anova1["var2",3],
           f2, 
           "",
           shapiro.res$p.value, 
           anderson.res$p.value, 
           jarque.res$p.value
        ) -> 
          output.b ;
        
        c( "class", 
           "var1", "var2", "Group", 
           "N", "Missing", "p value",
           "Method 1", 
           "M1 degree of freedon Chi square", 
           "M1 degree of freedon residuals", 
           "M1 Statistic: Chisq", 
           "M1 p",
           "Cohen f-squared of var2 on R-squared",
           "",
           "Shapiro-Wilk normality test on residuals p-value",
           "Anderson-Darling normality test on residuals p-value",
           "Jarque-Bera normality test on residuals p-value"
        ) -> 
          names( output.b ) ;
        
        if ( !is.null( pvalue.round ) ) 
        {  
          p.round( as.numeric( output.b[ which( names( output.b ) == 
                                                  "p value" ) ] ),
                   digits = pvalue.round ) ->
            output.b[ which( names( output.b ) == "p value" ) ] ;
          
          p.round( as.numeric( output.b[ which( names( output.b ) == 
                                                  "M1 p" ) ] ),
                   digits = pvalue.round ) ->
            output.b[ which( names( output.b ) == "M1 p" ) ] ;
          
          p.round( as.numeric( output.b[ which( names( output.b ) == 
                                                  "Shapiro-Wilk normality test on residuals p-value" ) ] ),
                   digits = pvalue.round ) ->
            output.b[ which( names( output.b ) == "Shapiro-Wilk normality test on residuals p-value" ) ] ;
          
          p.round( as.numeric( output.b[ which( names( output.b ) == 
                                                  "Anderson-Darling normality test on residuals p-value" ) ] ),
                   digits = pvalue.round ) ->
            output.b[ which( names( output.b ) == "Anderson-Darling normality test on residuals p-value" ) ] ;
          
          p.round( as.numeric( output.b[ which( names( output.b ) == 
                                                  "Jarque-Bera normality test on residuals p-value" ) ] ),
                   digits = pvalue.round ) ->
            output.b[ which( names( output.b ) == "Jarque-Bera normality test on residuals p-value" ) ] ;
        }
        
        if ( !is.null( round ) ) 
        { 
          round( as.numeric( output.b[ which( names( output.b ) == 
                                                "M1 Statistic: Chisq" ) ] ),
                 digits = round ) ->
            output.b[ which( names( output.b ) == "M1 Statistic: Chisq" ) ] ;
          
          round( as.numeric( output.b[ which( names( output.b ) == 
                                                "Cohen f-squared of var2 on R-squared" ) ] ),
                 digits = round ) ->
            output.b[ which( names( output.b ) == "Cohen f-squared of var2 on R-squared" ) ] ;
        } 
        
        unlist( output.b )-> output.b ;
      } 
    }
    
    # factor 2 levels & numeric
    if ( is.factor( df1$var1 ) &
         is.numeric( df1$var2 ) )
    {
      if (  nlevels( df1$var1 ) == 2 &
            all( table( df1$var1 ) > 5 ) &
            nlevels( factor( df1$var2 ) ) > 3 &
            length( df1$var2 ) > 7  )
      {
        "var1 ~ var2" |> 
          as.formula() |>
          glm( family = "binomial", data = df1 ) ->
          m1 ;
        
        m1 |>
          ( function(x) {
            car::Anova( x, 
                        type = "3",
                        test.statistic = c("Wald"),
                        vcov. = sandwich::vcovCL(m1,  # ATTENTION m1.bis
                                                 cluster = ~GROUP )
            ) 
          }
          )() -> 
          anova1 ;
        
        cohen.f2( m1, family = "binomial", pseudo.R2 = T,
                  data = df1 ) -> f2 ; 
        
        residuals( m1 ) -> residuals ;
        if ( length( matrix(residuals) ) < 5000 ) 
        { shapiro.test( matrix(residuals) ) -> shapiro.res ; }  else
        { list( "p.value" = NA ) -> shapiro.res ; }
        nortest::ad.test( matrix(residuals) ) -> anderson.res ;
        moments::jarque.test( residuals ) -> jarque.res ;
        
        c( "binomial", 
           name.a, 
           colnames( data.vars2 )[b], 
           group,
           nrow(df1), nrow(data.vars2) - nrow(df1),
           anova1["var2",3], 
           "Analysis of Deviance Table (Type III tests) - Cluster robust and  heteroscedasticity robust test",
           anova1["var2",1],
           nrow(df1) - anova1["var2",1],
           anova1["var2",2],
           anova1["var2",3],
           f2, 
           "",
           shapiro.res$p.value, 
           anderson.res$p.value, 
           jarque.res$p.value
        ) -> 
          output.b ;
        
        c( "class", 
           "var1", "var2", "Group", 
           "N", "Missing", "p value",
           "Method 1", 
           "M1 degree of freedon Chi square", 
           "M1 degree of freedon residuals", 
           "M1 Statistic: Chisq", 
           "M1 p",
           "Cohen f-squared of var2 on R-squared",
           "",
           "Shapiro-Wilk normality test on residuals p-value",
           "Anderson-Darling normality test on residuals p-value",
           "Jarque-Bera normality test on residuals p-value"
        ) -> 
          names( output.b ) ;
        
        if ( !is.null( pvalue.round ) ) 
        {  
          p.round( as.numeric( output.b[ which( names( output.b ) == 
                                                  "p value" ) ] ),
                   digits = pvalue.round ) ->
            output.b[ which( names( output.b ) == "p value" ) ] ;
          
          p.round( as.numeric( output.b[ which( names( output.b ) == 
                                                  "M1 p" ) ] ),
                   digits = pvalue.round ) ->
            output.b[ which( names( output.b ) == "M1 p" ) ] ;
          
          p.round( as.numeric( output.b[ which( names( output.b ) == 
                                                  "Shapiro-Wilk normality test on residuals p-value" ) ] ),
                   digits = pvalue.round ) ->
            output.b[ which( names( output.b ) == "Shapiro-Wilk normality test on residuals p-value" ) ] ;
          
          p.round( as.numeric( output.b[ which( names( output.b ) == 
                                                  "Anderson-Darling normality test on residuals p-value" ) ] ),
                   digits = pvalue.round ) ->
            output.b[ which( names( output.b ) == "Anderson-Darling normality test on residuals p-value" ) ] ;
          
          p.round( as.numeric( output.b[ which( names( output.b ) == 
                                                  "Jarque-Bera normality test on residuals p-value" ) ] ),
                   digits = pvalue.round ) ->
            output.b[ which( names( output.b ) == "Jarque-Bera normality test on residuals p-value" ) ] ;
        }
        
        if ( !is.null( round ) ) 
        { 
          round( as.numeric( output.b[ which( names( output.b ) == 
                                                "M1 Statistic: Chisq" ) ] ),
                 digits = round ) ->
            output.b[ which( names( output.b ) == "M1 Statistic: Chisq" ) ] ;
          
          round( as.numeric( output.b[ which( names( output.b ) == 
                                                "Cohen f-squared of var2 on R-squared" ) ] ),
                 digits = round ) ->
            output.b[ which( names( output.b ) == "Cohen f-squared of var2 on R-squared" ) ] ;
        } 
        
        unlist( output.b )-> output.b ;
      } 
    }
    
    # factor > 2 levels & factor
    if ( is.factor( df1$var1 ) &
         is.factor( df1$var2 ) )
    {
      if ( nlevels( df1$var1 ) > 2 &
           nlevels( df1$var2 ) > 1 &
           all( table( df1$var1, df1$var2 ) > 5 ) )
      {
        "var1 ~ var2" |> 
          as.formula() |>
          nnet::multinom( data = df1 ) -> m1 ;
        
        m1 |>
          ( function(x) {
            car::Anova( x,
                        type = "3",
                        vcov. = sandwich::vcovCL(m1,  # ATTENTION m1.bis
                                                 cluster = df1[, "GROUP"] )
            ) 
          }
          )() -> 
          anova1 ;
        
        cohen.f2( m1, pseudo.R2 = T,
                  data = df1 ) -> f2 ; 
        
        residuals( m1 ) -> residuals ;
        if ( length( matrix(residuals) ) < 5000 ) 
        { shapiro.test( matrix(residuals) ) -> shapiro.res ; }  else
        { list( "p.value" = NA ) -> shapiro.res ; }
        nortest::ad.test( matrix(residuals) ) -> anderson.res ;
        moments::jarque.test( as.numeric(
          matrix(residuals) ) ) -> jarque.res ;
        
        c( "multinomial", 
           name.a, 
           colnames( data.vars2 )[b], 
           group,
           nrow(df1), nrow(data.vars2) - nrow(df1),
           anova1["var2",3],
           "Analysis of Deviance Table (Type III tests) - Cluster robust and  heteroscedasticity robust test",
           anova1["var2",2],
           nrow(df1) - anova1["var2",2],
           anova1["var2",1],
           anova1["var2",3],
           f2, 
           "",
           shapiro.res$p.value, 
           anderson.res$p.value, 
           jarque.res$p.value
        ) -> 
          output.b ;
        
        c( "class", 
           "var1", "var2", "Group", 
           "N", "Missing", "p value",
           "Method 1", 
           "M1 degree of freedon Chi square", 
           "M1 degree of freedon residuals", 
           "M1 Statistic: LR Chisq", 
           "M1 p",
           "Cohen f-squared of var2 on R-squared",
           "",
           "Shapiro-Wilk normality test on residuals p-value",
           "Anderson-Darling normality test on residuals p-value",
           "Jarque-Bera normality test on residuals p-value"
        ) -> 
          names( output.b ) ;
        
        if ( !is.null( pvalue.round ) ) 
        {  
          p.round( as.numeric( output.b[ which( names( output.b ) == 
                                                  "p value" ) ] ),
                   digits = pvalue.round ) ->
            output.b[ which( names( output.b ) == "p value" ) ] ;
          
          p.round( as.numeric( output.b[ which( names( output.b ) == 
                                                  "M1 p" ) ] ),
                   digits = pvalue.round ) ->
            output.b[ which( names( output.b ) == "M1 p" ) ] ;
          
          p.round( as.numeric( output.b[ which( names( output.b ) == 
                                                  "Shapiro-Wilk normality test on residuals p-value" ) ] ),
                   digits = pvalue.round ) ->
            output.b[ which( names( output.b ) == "Shapiro-Wilk normality test on residuals p-value" ) ] ;
          
          p.round( as.numeric( output.b[ which( names( output.b ) == 
                                                  "Anderson-Darling normality test on residuals p-value" ) ] ),
                   digits = pvalue.round ) ->
            output.b[ which( names( output.b ) == "Anderson-Darling normality test on residuals p-value" ) ] ;
          
          p.round( as.numeric( output.b[ which( names( output.b ) == 
                                                  "Jarque-Bera normality test on residuals p-value" ) ] ),
                   digits = pvalue.round ) ->
            output.b[ which( names( output.b ) == "Jarque-Bera normality test on residuals p-value" ) ] ;
        }
        
        if ( !is.null( round ) ) 
        { 
          round( as.numeric( output.b[ which( names( output.b ) == 
                                                "M1 Statistic: LR Chisq" ) ] ),
                 digits = round ) ->
            output.b[ which( names( output.b ) == "M1 Statistic: LR Chisq" ) ] ;
          
          round( as.numeric( output.b[ which( names( output.b ) == 
                                                "Cohen f-squared of var2 on R-squared" ) ] ),
                 digits = round ) ->
            output.b[ which( names( output.b ) == "Cohen f-squared of var2 on R-squared" ) ] ;
        } 
        
        unlist( output.b )-> output.b ;
      } 
    }
    
    # factor > 2 levels & numeric
    if ( is.factor( df1$var1 ) &
         is.numeric( df1$var2 ) )
    {
      if (  nlevels( df1$var1 ) > 2 &
            all( table( df1$var1 ) > 5 ) &
            nlevels( factor( df1$var2 ) ) > 3 &
            length( df1$var2 ) > 7  )
      {
        "var1 ~ var2" |> 
          as.formula() |>
          nnet::multinom( data = df1 ) -> m1 ;
        
        m1 |>
          ( function(x) {
            car::Anova( x,
                        type = "3",
                        vcov. = sandwich::vcovCL(m1,  # ATTENTION m1.bis
                                                 cluster = df1[, "GROUP"] )
            ) 
          }
          )() -> 
          anova1 ;
        
        cohen.f2( m1, pseudo.R2 = T,
                  data = df1 ) -> f2 ; 
        
        residuals( m1 ) -> residuals ;
        if ( length( matrix(residuals) ) < 5000 ) 
        { shapiro.test( matrix(residuals) ) -> shapiro.res ; }  else
        { list( "p.value" = NA ) -> shapiro.res ; }
        nortest::ad.test( matrix(residuals) ) -> anderson.res ;
        moments::jarque.test( as.numeric(
          matrix(residuals) ) ) -> jarque.res ;
        
        c( "multinomial", 
           name.a, 
           colnames( data.vars2 )[b], 
           group,
           nrow(df1), nrow(data.vars2) - nrow(df1),
           anova1["var2",3],
           "Analysis of Deviance Table (Type III tests) - Cluster robust and  heteroscedasticity robust test",
           anova1["var2",2],
           nrow(df1) - anova1["var2",2],
           anova1["var2",1],
           anova1["var2",3],
           f2, 
           "",
           shapiro.res$p.value, 
           anderson.res$p.value, 
           jarque.res$p.value
        ) -> 
          output.b ;
        
        c( "class", 
           "var1", "var2", "Group", 
           "N", "Missing", "p value",
           "Method 1", 
           "M1 degree of freedon Chi square", 
           "M1 degree of freedon residuals", 
           "M1 Statistic: LR Chisq", 
           "M1 p",
           "Cohen f-squared of var2 on R-squared",
           "",
           "Shapiro-Wilk normality test on residuals p-value",
           "Anderson-Darling normality test on residuals p-value",
           "Jarque-Bera normality test on residuals p-value"
        ) -> 
          names( output.b ) ;
        
        if ( !is.null( pvalue.round ) ) 
        {  
          p.round( as.numeric( output.b[ which( names( output.b ) == 
                                                  "p value" ) ] ),
                   digits = pvalue.round ) ->
            output.b[ which( names( output.b ) == "p value" ) ] ;
          
          p.round( as.numeric( output.b[ which( names( output.b ) == 
                                                  "M1 p" ) ] ),
                   digits = pvalue.round ) ->
            output.b[ which( names( output.b ) == "M1 p" ) ] ;
          
          p.round( as.numeric( output.b[ which( names( output.b ) == 
                                                  "Shapiro-Wilk normality test on residuals p-value" ) ] ),
                   digits = pvalue.round ) ->
            output.b[ which( names( output.b ) == "Shapiro-Wilk normality test on residuals p-value" ) ] ;
          
          p.round( as.numeric( output.b[ which( names( output.b ) == 
                                                  "Anderson-Darling normality test on residuals p-value" ) ] ),
                   digits = pvalue.round ) ->
            output.b[ which( names( output.b ) == "Anderson-Darling normality test on residuals p-value" ) ] ;
          
          p.round( as.numeric( output.b[ which( names( output.b ) == 
                                                  "Jarque-Bera normality test on residuals p-value" ) ] ),
                   digits = pvalue.round ) ->
            output.b[ which( names( output.b ) == "Jarque-Bera normality test on residuals p-value" ) ] ;
        }
        
        if ( !is.null( round ) ) 
        { 
          round( as.numeric( output.b[ which( names( output.b ) == 
                                                "M1 Statistic: LR Chisq" ) ] ),
                 digits = round ) ->
            output.b[ which( names( output.b ) == "M1 Statistic: LR Chisq" ) ] ;
          
          round( as.numeric( output.b[ which( names( output.b ) == 
                                                "Cohen f-squared of var2 on R-squared" ) ] ),
                 digits = round ) ->
            output.b[ which( names( output.b ) == "Cohen f-squared of var2 on R-squared" ) ] ;
        } 
        
        unlist( output.b )-> output.b ;
      } 
    }
    
    # Numeric & factor 
    if ( is.numeric( df1$var1 ) &
         is.factor( df1$var2 ) )
    {
      if (  nlevels( factor( df1$var1 ) ) > 3 &
            length( df1$var1 ) > 7 &
            nlevels( df1$var2 ) > 1 &
            all( table( df1$var2 ) > 5 ) )
      {
        "var1 ~ var2" |> 
          as.formula() |>
          lm( data = df1 ) ->
          m1 ;
        
        m1 |>
          ( function(x) {
            car::Anova( x,
                        type = "3",
                        vcov. = 
                          sandwich::vcovCL( x,
                                            cluster = ~GROUP ) )  
          }
          )() -> 
          anova1 ;
        
        cohen.f2( m1,
                  data = df1 ) -> f2 ; 
        
        heplots::etasq( m1 ) -> eta2 ; 
        
        residuals( m1 ) -> residuals ;
        if ( length( residuals ) < 5000 ) 
        { shapiro.test( residuals ) -> shapiro.res ; }  else
        { list( "p.value" = NA ) -> shapiro.res ; }
        nortest::ad.test( residuals ) -> anderson.res ;
        moments::jarque.test( residuals ) -> jarque.res ;
        
        
        c( "gaussian", 
           name.a, 
           colnames( data.vars2 )[b], 
           group,
           nrow(df1), nrow(data.vars2) - nrow(df1),
           anova1["var2",3],
           "Analysis of Deviance Table (Type III tests) - Cluster robust and  heteroscedasticity robust test",
           anova1[2,1],
           anova1[3,1],
           anova1[2,2],
           anova1["var2",3],
           f2, eta2[1,1],
           shapiro.res$p.value, 
           anderson.res$p.value, 
           jarque.res$p.value
        ) -> 
          output.b ;
        
        c( "class", 
           "var1", "var2", "Group", 
           "N", "Missing", "p value",
           "Method 1", 
           "M1 degree of freedon numerator", 
           "M1 degree of freedon denominator", 
           "M1 Statistic: F", 
           "M1 p",
           "Cohen f-squared of var2 on R-squared",
           "Partial eta-squared",
           "Shapiro-Wilk normality test on residuals p-value",
           "Anderson-Darling normality test on residuals p-value",
           "Jarque-Bera normality test on residuals p-value"
        ) -> 
          names( output.b ) ;
        
        if ( !is.null( pvalue.round ) ) 
        {  
          p.round( as.numeric( output.b[ which( names( output.b ) == 
                                                  "p value" ) ] ),
                   digits = pvalue.round ) ->
            output.b[ which( names( output.b ) == "p value" ) ] ;
          
          p.round( as.numeric( output.b[ which( names( output.b ) == 
                                                  "M1 p" ) ] ),
                   digits = pvalue.round ) ->
            output.b[ which( names( output.b ) == "M1 p" ) ] ;
          
          p.round( as.numeric( output.b[ which( names( output.b ) == 
                                                  "Shapiro-Wilk normality test on residuals p-value" ) ] ),
                   digits = pvalue.round ) ->
            output.b[ which( names( output.b ) == "Shapiro-Wilk normality test on residuals p-value" ) ] ;
          
          p.round( as.numeric( output.b[ which( names( output.b ) == 
                                                  "Anderson-Darling normality test on residuals p-value" ) ] ),
                   digits = pvalue.round ) ->
            output.b[ which( names( output.b ) == "Anderson-Darling normality test on residuals p-value" ) ] ;
          
          p.round( as.numeric( output.b[ which( names( output.b ) == 
                                                  "Jarque-Bera normality test on residuals p-value" ) ] ),
                   digits = pvalue.round ) ->
            output.b[ which( names( output.b ) == "Jarque-Bera normality test on residuals p-value" ) ] ;
        }
        
        if ( !is.null( round ) ) 
        { 
          round( as.numeric( output.b[ which( names( output.b ) == 
                                                "M1 Statistic: F" ) ] ),
                 digits = round ) ->
            output.b[ which( names( output.b ) == "M1 Statistic: F" ) ] ;
          
          round( as.numeric( output.b[ which( names( output.b ) == 
                                                "Cohen f-squared of var2 on R-squared" ) ] ),
                 digits = round ) ->
            output.b[ which( names( output.b ) == "Cohen f-squared of var2 on R-squared" ) ] ;
          
          round( as.numeric( output.b[ which( names( output.b ) == 
                                                "Partial eta-squared" ) ] ),
                 digits = round ) ->
            output.b[ which( names( output.b ) == "Partial eta-squared" ) ] ;
        } 
        
        unlist( output.b )-> output.b ;
      }   
    }
    
    # Numeric & numeric 
    if ( is.numeric( df1$var1 ) &
         is.numeric( df1$var2 ) )
    {
      if (  nlevels( factor( df1$var1 ) ) > 3 &
            length( df1$var1 ) > 7 &
            nlevels( factor( df1$var2 ) ) > 3 &
            length( df1$var2 ) > 7 &
            !all( df1$var1 == df1$var2 ) )
      {
        "var1 ~ var2" |> 
          as.formula() |>
          lm( data = df1 ) ->
          m1 ;
        
        m1 |>
          ( function(x) {
            car::Anova( x,
                        type = "3",
                        vcov. = 
                          sandwich::vcovCL( x,
                                            cluster = ~GROUP ) )  
          }
          )() -> 
          anova1 ;
        
        cohen.f2( m1,
                  data = df1 ) -> f2 ; 
        
        heplots::etasq( m1 ) -> eta2 ; 
        
        residuals( m1 ) -> residuals ;
        if ( length( residuals ) < 5000 ) 
        { shapiro.test( residuals ) -> shapiro.res ; }  else
        { list( "p.value" = NA ) -> shapiro.res ; }
        nortest::ad.test( residuals ) -> anderson.res ;
        moments::jarque.test( residuals ) -> jarque.res ;
        
        
        c( "gaussian", 
           name.a, 
           colnames( data.vars2 )[b], 
           group,
           nrow(df1), nrow(data.vars2) - nrow(df1),
           anova1["var2",3],
           "Analysis of Deviance Table (Type III tests) - Cluster robust and  heteroscedasticity robust test",
           anova1[2,1],
           anova1[3,1],
           anova1[2,2],
           anova1["var2",3],
           f2, eta2[1,1],
           shapiro.res$p.value, 
           anderson.res$p.value, 
           jarque.res$p.value
        ) -> 
          output.b ;
        
        c( "class", 
           "var1", "var2", "Group", 
           "N", "Missing", "p value",
           "Method 1", 
           "M1 degree of freedon numerator", 
           "M1 degree of freedon denominator", 
           "M1 Statistic: F", 
           "M1 p",
           "Cohen f-squared of var2 on R-squared",
           "Partial eta-squared",
           "Shapiro-Wilk normality test on residuals p-value",
           "Anderson-Darling normality test on residuals p-value",
           "Jarque-Bera normality test on residuals p-value"
        ) -> 
          names( output.b ) ;
        
        if ( !is.null( pvalue.round ) ) 
        {  
          p.round( as.numeric( output.b[ which( names( output.b ) == 
                                                  "p value" ) ] ),
                   digits = pvalue.round ) ->
            output.b[ which( names( output.b ) == "p value" ) ] ;
          
          p.round( as.numeric( output.b[ which( names( output.b ) == 
                                                  "M1 p" ) ] ),
                   digits = pvalue.round ) ->
            output.b[ which( names( output.b ) == "M1 p" ) ] ;
          
          p.round( as.numeric( output.b[ which( names( output.b ) == 
                                                  "Shapiro-Wilk normality test on residuals p-value" ) ] ),
                   digits = pvalue.round ) ->
            output.b[ which( names( output.b ) == "Shapiro-Wilk normality test on residuals p-value" ) ] ;
          
          p.round( as.numeric( output.b[ which( names( output.b ) == 
                                                  "Anderson-Darling normality test on residuals p-value" ) ] ),
                   digits = pvalue.round ) ->
            output.b[ which( names( output.b ) == "Anderson-Darling normality test on residuals p-value" ) ] ;
          
          p.round( as.numeric( output.b[ which( names( output.b ) == 
                                                  "Jarque-Bera normality test on residuals p-value" ) ] ),
                   digits = pvalue.round ) ->
            output.b[ which( names( output.b ) == "Jarque-Bera normality test on residuals p-value" ) ] ;
        }
        
        if ( !is.null( round ) ) 
        { 
          round( as.numeric( output.b[ which( names( output.b ) == 
                                                "M1 Statistic: F" ) ] ),
                 digits = round ) ->
            output.b[ which( names( output.b ) == "M1 Statistic: F" ) ] ;
          
          round( as.numeric( output.b[ which( names( output.b ) == 
                                                "Cohen f-squared of var2 on R-squared" ) ] ),
                 digits = round ) ->
            output.b[ which( names( output.b ) == "Cohen f-squared of var2 on R-squared" ) ] ;
          
          round( as.numeric( output.b[ which( names( output.b ) == 
                                                "Partial eta-squared" ) ] ),
                 digits = round ) ->
            output.b[ which( names( output.b ) == "Partial eta-squared" ) ] ;
        } 
        
        unlist( output.b )-> output.b ;
      } 
    }
    
    # No test possible
    if ( is.null( output.b ) )
    {
      # tests
      
      
      # fusion
      c( "other", name.a, colnames( data.vars2 )[b], identifier, "-",
         nrow(df1), nrow(data.vars2) - nrow(df1)
      ) -> output.b
      
      c( "other", 
         "var1", "var2", "identifier", "-",
         "N", "Missing"
      ) -> 
        names( output.b ) 
      
    }
    
    return( output.b )
  } 
  
  # Load packages
  download.packages( "furrr", 
                     "car", "heplots", "MuMIn",
                     "nortest", 
                     "moments", 
                     "sandwich" ) ;
  
  
  # prepare data
  #=============
  as.data.frame( data ) -> data ; 
  
  data[, which( !( colnames( data ) %in% group ) ) ] -> 
    data.vars ;
  
  data.vars[, which( !( colnames( data.vars ) %in% identifier ) ) ] -> 
    data.vars ; 
  
  data[, which( colnames( data ) %in% group ) ] -> 
    data.group ;
  
  data[, which( colnames( data ) %in% identifier ) ] -> 
    data.identifier ;
  
  # Job
  furrr::future_map( 1:length( data.vars ), 
                     fun.a,
                     data.vars = data.vars, 
                     data.group = data.group, 
                     data.identifier = data.identifier, 
                     group = group,
                     .options = furrr::furrr_options( seed = seed ), .progress = T 
  ) |>
    rbind.force(  empty = "" ) -> 
    output
  
  # prepare output
  c("class", 
    "var1", "var2", "Group", 
    "N", "Missing", "p value",
    "Method 1", 
    "M1 degree of freedon Chi square", 
    "M1 degree of freedon residuals", 
    "M1 Statistic: Chisq", 
    "M1 p",
    "Cohen f-squared of var2 on R-squared",
    "-",
    "Shapiro-Wilk normality test on residuals p-value",
    "Anderson-Darling normality test on residuals p-value",
    "Jarque-Bera normality test on residuals p-value"
  ) -> titles.binomial ;
  
  c(  "class", 
      "var1", "var2", "Group", 
      "N", "Missing", "p value",
      "Method 1", 
      "M1 degree of freedon Chi square", 
      "M1 degree of freedon residuals", 
      "M1 Statistic: LR Chisq", 
      "M1 p",
      "Cohen f-squared of var2 on R-squared",
      "-",
      "Shapiro-Wilk normality test on residuals p-value",
      "Anderson-Darling normality test on residuals p-value",
      "Jarque-Bera normality test on residuals p-value"
  ) -> titles.multinomial ;
  
  c(  "class", 
      "var1", "var2", "Group", 
      "N", "Missing", "p value",
      "Method 1", 
      "M1 degree of freedon numerator", 
      "M1 degree of freedon denominator", 
      "M1 Statistic: F", 
      "M1 p",
      "Cohen f-squared of var2 on R-squared",
      "Partial eta-squared",
      "Shapiro-Wilk normality test on residuals p-value",
      "Anderson-Darling normality test on residuals p-value",
      "Jarque-Bera normality test on residuals p-value"
  ) -> titles.gaussian ;
  
  c( "class", 
     "var1", "var2", "identifier", "-",
     "N", "Missing"
  ) -> titles.other ; 
  
  NULL -> output.tmp
  
  for ( i in levels( factor( output[,1] ) ) )
  {
    if ( grepl( "binomial", i ) )
    {
      rbind.force( output.tmp,
                   titles.binomial,
                   output[ output[,1] == i, ],
                   empty = "" ) ->
        output.tmp ; 
    }
    
    if ( grepl( "multinomial", i ) )
    {
      rbind.force( output.tmp,
                   titles.multinomial,
                   output[ output[,1] == i, ],
                   empty = "" ) ->
        output.tmp ; 
    }
    
    if ( grepl( "gaussian", i ) )
    {
      rbind.force( output.tmp,
                   titles.gaussian,
                   output[ output[,1] == i, ],
                   empty = "" ) ->
        output.tmp ; 
    }
    
    if ( grepl( "other", i ) )
    {
      rbind.force( output.tmp,
                   titles.other,
                   output[ output[,1] == i, ],
                   empty = "" ) ->
        output.tmp ; 
    }
    
  }
  output.tmp -> output
  
  c( "Class", "var", "group", "N", "Missing",
     paste( rep( "col", length( 6:ncol( output ) ) ), 
            6:ncol( output ), sep = "" ) ) ->         
    colnames( output ) ;
  
  # end parallel
  future::plan("sequential")
  
  return( output ) ;
}

Bivariate.Analysis.ClusterRobust.weighted <- function( data, 
                                                       group, 
                                                       identifier,
                                                       weights,
                                                       na.rm = TRUE,
                                                       seed = 123,
                                                       pvalue.round = 3,
                                                       round = 2,
                                                       ncores = NULL )
  
{
  # Conditions for input
  if ( !is.data.frame( data ) ) { stop( "data is not a data.frame" );  } ;
  if ( !is.character( group ) ) { stop( "groups is not character" );   } ;
  if ( !is.character( identifier ) ) { stop( "identifier is not character" );   } ;
  if ( !is.numeric( weights ) ) { stop( "weights is not numeric" );   } ;
  if ( !(group %in% colnames( data ) ) ) { stop(  "group is not in data"  );   } ;
  if ( !(identifier %in% colnames( data ) ) ) { stop(  "identifier is not in data"  );   } ;
  if ( !is.logical( na.rm ) ) { stop( "na.rm is not TRUE or FALSE" );   } ;
  if ( !is.numeric( seed ) ) { stop( "seed is not numeric" );   } ;
  if ( !( is.numeric( pvalue.round ) | 
          is.null( pvalue.round ) ) ) { stop( "pvalue.round is neither numeric, neither NULL" );    } ;
  if ( !( is.numeric( round ) | 
          is.null( round ) ) ) { stop( "round is neither numeric, neither NULL" );    } ;
  if ( !is.null(ncores) & !is.numeric(ncores) ) { stop( "ncores is not null nor numeric" ) }
  
  # parallel
  if ( !is.null( ncores ) ) { future::plan( "multisession",  workers = ncores ) }
  
  # custom functions
  download.packages <- function( PackagesNames, ... )
  {
    # Get a vector with packages names 
    packages1 <- c( PackagesNames, ... ) ;
    
    # Install packages
    for (a in 1:length( packages1 ) )
    {
      try( find.package( packages1[a]), silent = TRUE ) -> test ;
      
      if ( class( test ) == "try-error" )
      { print( packages1[a] ) ; 
        install.packages(  packages1[a] ) ;
      } 
    }
  } ;
  
  rbind.force <- function( data, ..., keep.col = FALSE, empty = NA ) 
  {
    # Unify data
    list( data, ... ) -> input ;
    
    # include list elements
    repeat 
    {
      if (  !any( unlist( lapply( input, class ) ) == "list" ) ) { break }  
      
      which( unlist( lapply( input, class ) ) == "list" )[1] -> a ;
      input[[a]] -> tmp ;
      input[[a]] <- NA ;
      c( input[1:a],  tmp, input[ (a + 1):length( input ) ] ) -> 
        input ;
    }
    
    input[ !is.na( input ) ] ->
      input ;
    
    # delete NULL data and transformt vector in data.frame
    for ( a in 1:length( input ) )
    {
      if ( is.null( dim( input[[a]] ) ) )
      {
        if ( is.null( input[[a]] ) )
        {
          input[[a]] <- NA ;
        } else
        {
          data.frame( matrix( input[[a]], nrow = 1 ),
                      stringsAsFactors = FALSE ) -> input[[a]] ; 
        }
      }
      
      if ( all( dim( input[[a]] ) == 0 ) )
      {
        input[[a]] <- NA ;
      }
    }
    
    input[ !is.na( input ) ] ->
      input ;
    
    # test data class
    if ( !all( unlist( lapply( input, is.data.frame ) ) |
               unlist( lapply( input, is.matrix ) ) |
               unlist( lapply( input, is.vector ) ) ) )
    { stop( "Some argument are not data.frame, neither vector" ) ;
      ; } ;
    
    # Set primer
    input[[1]] -> output ; 
    
    # job in case we keep columns 
    if ( keep.col & length( input ) >1 )
    {
      for ( a in 2:length( input ) )
      { 
        output -> x ;
        input[[a]] -> y ; 
        
        for (a in 1:dim(x)[2]) { x[,a] <- as.character(x[,a])}
        for (a in 1:dim(y)[2]) { y[,a] <- as.character(y[,a])}
        
        x.diff <- setdiff(colnames(x), colnames(y))
        y.diff <- setdiff(colnames(y), colnames(x))
        
        if( dim(x)[1] > 0 ) { x[, c(as.character(y.diff))] <- empty ; }
        if( dim(y)[1] > 0 ) { y[, c(as.character(x.diff))] <- empty ; }
        
        rbind(x, y) -> output ;
      } 
    }
    
    # job in case we do not keep columns
    if ( !keep.col & length( input ) >1 )
    {
      for ( a in 2:length( input ) )
      { 
        output -> x ;
        input[[a]] -> y ; 
        
        colnames(x) <- paste( "X",
                              1:dim( x )[2], 
                              sep = "" ) ;
        colnames(y) <- paste( "X",
                              1:dim( y )[2], 
                              sep = "" ) ;
        
        for (a in 1:dim(x)[2]) { x[,a] <- as.character(x[,a])}
        for (a in 1:dim(y)[2]) { y[,a] <- as.character(y[,a])}
        
        x.diff <- setdiff(colnames(x), colnames(y))
        y.diff <- setdiff(colnames(y), colnames(x))
        
        if( dim(x)[1] > 0 ) { x[, c(as.character(y.diff))] <- empty ; }
        if( dim(y)[1] > 0 ) { y[, c(as.character(x.diff))] <- empty ; }
        
        rbind(x, y) -> output ;
      } 
    }
    
    return( output ) ;
  } 
  
  p.round <- function( data, digits = 3 )
  {
    if (digits == 1)
    { "" -> tmp1 ; } else 
    { rep( "0", digits - 1 ) -> tmp1 ; }
    
    "0." -> tmp2 ;
    for( a in 1:length(tmp1) )
    {
      paste( tmp2, tmp1[a], sep = "" ) -> tmp2 ;
    }
    
    paste( tmp2, "1", sep = "" ) -> pval ;
    
    for ( a in 1:length(data) )
    {
      if ( !is.na( data[a] ) )
      {
        if ( data[a] >= as.numeric( pval ) )
        {
          round( data[a], digits = digits ) -> data[a] ;
        }
      }
    }
    
    data[ data < as.numeric( pval ) ] <- paste( "< ", pval, sep = "" ) ;
    
    return( data ) ;
  }
  
  cohen.f2 <- function( model, pseudo.R2 = FALSE, family, data )
  {
    attr(terms(model), 'term.labels') -> terms1 ; 
    as.character( terms(model) )[2] -> outcome ;
    
    NULL -> f2 ;
    
    if ( !pseudo.R2 )
    {
      for ( a in 1:length(terms1) )
      {
        if ( length(terms1) == 1 )
        { 
          stats::update( model, reformulate( "1" ), data = data ) -> model.bis 
        } else
        {
          stats::update( model, reformulate( terms1[-a] ) ) -> model.bis ; 
        }
        
        c( f2, 
           (summary( model )$r.squared -  summary( model.bis  )$r.squared ) / (1 - summary( model )$r.squared) ) -> 
          f2 ;
      }
    }  
    
    if ( pseudo.R2 & any( class( model ) == "glm" ) )
    {
      for ( a in 1:length(terms1) )
      {
        if ( length(terms1) == 1 )
        { 
          stats::update( model, reformulate( "1", outcome ),
                  data = data )-> model.bis ;
        } else
        {
          stats::update( model, reformulate( terms1[-a], outcome ), family = family ) -> model.bis ; 
        }
        
        c( f2, 
           (MuMIn::r.squaredLR( model, stats::update( model, reformulate( "1", outcome ), family = family, data = data  ) )[1] -  MuMIn::r.squaredLR( model.bis, stats::update( model, reformulate( "1" ), family = family, data = data ) )[1]  ) / (1 -  MuMIn::r.squaredLR( model, stats::update( model, reformulate( "1", outcome ), family = family, data = data ) )[1] )  ) -> 
          f2 ;
      }
    }
    
    if ( pseudo.R2 & all( class( model ) != "glm" ) )
    {
      for ( a in 1:length(terms1) )
      {
        if ( length(terms1) == 1 )
        { 
          stats::update( model, reformulate( "1", outcome ),
                  data = data ) -> model.bis ;
        } else
        {
          stats::update( model, reformulate( terms1[-a], outcome ) ) -> model.bis ; 
        }
        
        c( f2, 
           (MuMIn::r.squaredLR( model, 
                                stats::update( model, 
                                        reformulate( "1", outcome ),
                                        data = data ) )[1] -  
              MuMIn::r.squaredLR( model.bis, stats::update( model, 
                                                     reformulate( "1" ),
                                                     data = data ) )[1]  ) / 
             (1 -  MuMIn::r.squaredLR( model, stats::update( model, reformulate( "1", outcome ), data = data ) )[1] )  ) -> 
          f2 ;
      }
    }
    
    terms1 -> names( f2 ) ;
    
    return( f2 )
  }
  
  fun.a <- function( a, data.vars,  data.group, 
                     data.identifier, 
                     group, weights )
  {
    print( "a") ; print( a ) ; print( colnames( data.vars )[a] ) ;
    
    # Prepara data
    data.vars[,a] -> data.var1 ; 
    
    data.vars[, which( !( colnames( data.vars ) %in% colnames( data.vars )[a] ) ) ] -> 
      data.vars2 ; 
    
    rbind.force( 
      lapply( 1:dim( data.vars2 )[2], 
              FUN = fun.b,
              data.vars2 = data.vars2, 
              data.var1 = data.var1,
              data.group = data.group, 
              data.identifier = data.identifier, 
              group = group,
              identifier = identifier,
              name.a = colnames(data.vars)[a],
              weights = weights
      ),
      empty = "" ) -> 
      output.a ;
    
    return( output.a )
  } 
  
  fun.b <- function( b, data.vars2, 
                     data.var1,
                     data.group,
                     data.identifier,
                     group,
                     identifier,
                     name.a,
                     weights )
  {
    print( "b") ; print( b ) ; print( colnames( data.vars2 )[b] ) ; 
    
    require(ordinal) ; 
    
    # Prepare data
    data.frame( var1 = data.var1,
                var2 = data.vars2[,b], 
                GROUP = factor( data.group ), 
                ID = as.factor( as.character( data.identifier ) ),
                weights1 = weights
    ) ->
      df1 ;
    
    # NA
    if ( na.rm )
    {
      na.omit( df1 ) -> df1 ;
      
      factor( df1$GROUP ) -> df1$GROUP ;
      factor( df1$ID ) -> df1$ID ;
      
      if ( is.factor(df1$var1) ) 
      { factor( df1$var1 ) -> df1$var1 ; }
      if ( is.factor(df1$var2) ) 
      { factor( df1$var2 ) -> df1$var2 ; }
    }
    
    # primer
    NULL -> output.b ;
    
    # job
    
    # factor 2 levels & factor
    if ( is.factor( df1$var1 ) &
         is.factor( df1$var2 ) )
    {
      if (
        nlevels( df1$var1 ) == 2 &
        nlevels( df1$var2 ) > 1 &
        all( table( df1$var1, df1$var2 ) > 5 )
      )
      {
        "var1 ~ var2" |> 
          as.formula() |>
          glm( family = "binomial", data = df1, 
               weights = df1$weights1 ) ->
          m1 ;
        
        m1 |>
          ( function(x) {
            car::Anova( x, 
                        type = "3",
                        test.statistic = c("Wald"),
                        vcov. = sandwich::vcovCL(m1,  # ATTENTION m1.bis
                                                 cluster = ~GROUP )
            ) 
          }
          )() -> 
          anova1 ;
        
        cohen.f2( m1, family = "binomial", pseudo.R2 = T,
                  data = df1 ) -> f2 ; 
        
        residuals( m1 ) -> residuals ;
        if ( length( matrix(residuals) ) < 5000 ) 
        { shapiro.test( matrix(residuals) ) -> shapiro.res ; }  else
        { list( "p.value" = NA ) -> shapiro.res ; }
        nortest::ad.test( matrix(residuals) ) -> anderson.res ;
        moments::jarque.test( residuals ) -> jarque.res ;
        
        c( "binomial", 
           name.a, 
           colnames( data.vars2 )[b], 
           group,
           nrow(df1), nrow(data.vars2) - nrow(df1),
           anova1["var2",3], 
           "Analysis of Deviance Table (Type III tests) - Cluster robust and  heteroscedasticity robust test",
           anova1["var2",1],
           nrow(df1) - anova1["var2",1],
           anova1["var2",2],
           anova1["var2",3],
           f2, 
           "",
           shapiro.res$p.value, 
           anderson.res$p.value, 
           jarque.res$p.value
        ) -> 
          output.b ;
        
        c( "class", 
           "var1", "var2", "Group", 
           "N", "Missing", "p value",
           "Method 1", 
           "M1 degree of freedon Chi square", 
           "M1 degree of freedon residuals", 
           "M1 Statistic: Chisq", 
           "M1 p",
           "Cohen f-squared of var2 on R-squared",
           "",
           "Shapiro-Wilk normality test on residuals p-value",
           "Anderson-Darling normality test on residuals p-value",
           "Jarque-Bera normality test on residuals p-value"
        ) -> 
          names( output.b ) ;
        
        if ( !is.null( pvalue.round ) ) 
        {  
          p.round( as.numeric( output.b[ which( names( output.b ) == 
                                                  "p value" ) ] ),
                   digits = pvalue.round ) ->
            output.b[ which( names( output.b ) == "p value" ) ] ;
          
          p.round( as.numeric( output.b[ which( names( output.b ) == 
                                                  "M1 p" ) ] ),
                   digits = pvalue.round ) ->
            output.b[ which( names( output.b ) == "M1 p" ) ] ;
          
          p.round( as.numeric( output.b[ which( names( output.b ) == 
                                                  "Shapiro-Wilk normality test on residuals p-value" ) ] ),
                   digits = pvalue.round ) ->
            output.b[ which( names( output.b ) == "Shapiro-Wilk normality test on residuals p-value" ) ] ;
          
          p.round( as.numeric( output.b[ which( names( output.b ) == 
                                                  "Anderson-Darling normality test on residuals p-value" ) ] ),
                   digits = pvalue.round ) ->
            output.b[ which( names( output.b ) == "Anderson-Darling normality test on residuals p-value" ) ] ;
          
          p.round( as.numeric( output.b[ which( names( output.b ) == 
                                                  "Jarque-Bera normality test on residuals p-value" ) ] ),
                   digits = pvalue.round ) ->
            output.b[ which( names( output.b ) == "Jarque-Bera normality test on residuals p-value" ) ] ;
        }
        
        if ( !is.null( round ) ) 
        { 
          round( as.numeric( output.b[ which( names( output.b ) == 
                                                "M1 Statistic: Chisq" ) ] ),
                 digits = round ) ->
            output.b[ which( names( output.b ) == "M1 Statistic: Chisq" ) ] ;
          
          round( as.numeric( output.b[ which( names( output.b ) == 
                                                "Cohen f-squared of var2 on R-squared" ) ] ),
                 digits = round ) ->
            output.b[ which( names( output.b ) == "Cohen f-squared of var2 on R-squared" ) ] ;
        } 
        
        unlist( output.b )-> output.b ;
      } 
    }
    
    # factor 2 levels & numeric
    if ( is.factor( df1$var1 ) &
         is.numeric( df1$var2 ) )
    {
      if (  nlevels( df1$var1 ) == 2 &
            all( table( df1$var1 ) > 5 ) &
            nlevels( factor( df1$var2 ) ) > 3 &
            length( df1$var2 ) > 7  )
      {
        "var1 ~ var2" |> 
          as.formula() |>
          glm( family = "binomial", data = df1, 
               weights = df1$weights1 ) ->
          m1 ;
        
        m1 |>
          ( function(x) {
            car::Anova( x, 
                        type = "3",
                        test.statistic = c("Wald"),
                        vcov. = sandwich::vcovCL(m1,  # ATTENTION m1.bis
                                                 cluster = ~GROUP )
            ) 
          }
          )() -> 
          anova1 ;
        
        cohen.f2( m1, family = "binomial", pseudo.R2 = T,
                  data = df1 ) -> f2 ; 
        
        residuals( m1 ) -> residuals ;
        if ( length( matrix(residuals) ) < 5000 ) 
        { shapiro.test( matrix(residuals) ) -> shapiro.res ; }  else
        { list( "p.value" = NA ) -> shapiro.res ; }
        nortest::ad.test( matrix(residuals) ) -> anderson.res ;
        moments::jarque.test( residuals ) -> jarque.res ;
        
        c( "binomial", 
           name.a, 
           colnames( data.vars2 )[b], 
           group,
           nrow(df1), nrow(data.vars2) - nrow(df1),
           anova1["var2",3], 
           "Analysis of Deviance Table (Type III tests) - Cluster robust and  heteroscedasticity robust test",
           anova1["var2",1],
           nrow(df1) - anova1["var2",1],
           anova1["var2",2],
           anova1["var2",3],
           f2, 
           "",
           shapiro.res$p.value, 
           anderson.res$p.value, 
           jarque.res$p.value
        ) -> 
          output.b ;
        
        c( "class", 
           "var1", "var2", "Group", 
           "N", "Missing", "p value",
           "Method 1", 
           "M1 degree of freedon Chi square", 
           "M1 degree of freedon residuals", 
           "M1 Statistic: Chisq", 
           "M1 p",
           "Cohen f-squared of var2 on R-squared",
           "",
           "Shapiro-Wilk normality test on residuals p-value",
           "Anderson-Darling normality test on residuals p-value",
           "Jarque-Bera normality test on residuals p-value"
        ) -> 
          names( output.b ) ;
        
        if ( !is.null( pvalue.round ) ) 
        {  
          p.round( as.numeric( output.b[ which( names( output.b ) == 
                                                  "p value" ) ] ),
                   digits = pvalue.round ) ->
            output.b[ which( names( output.b ) == "p value" ) ] ;
          
          p.round( as.numeric( output.b[ which( names( output.b ) == 
                                                  "M1 p" ) ] ),
                   digits = pvalue.round ) ->
            output.b[ which( names( output.b ) == "M1 p" ) ] ;
          
          p.round( as.numeric( output.b[ which( names( output.b ) == 
                                                  "Shapiro-Wilk normality test on residuals p-value" ) ] ),
                   digits = pvalue.round ) ->
            output.b[ which( names( output.b ) == "Shapiro-Wilk normality test on residuals p-value" ) ] ;
          
          p.round( as.numeric( output.b[ which( names( output.b ) == 
                                                  "Anderson-Darling normality test on residuals p-value" ) ] ),
                   digits = pvalue.round ) ->
            output.b[ which( names( output.b ) == "Anderson-Darling normality test on residuals p-value" ) ] ;
          
          p.round( as.numeric( output.b[ which( names( output.b ) == 
                                                  "Jarque-Bera normality test on residuals p-value" ) ] ),
                   digits = pvalue.round ) ->
            output.b[ which( names( output.b ) == "Jarque-Bera normality test on residuals p-value" ) ] ;
        }
        
        if ( !is.null( round ) ) 
        { 
          round( as.numeric( output.b[ which( names( output.b ) == 
                                                "M1 Statistic: Chisq" ) ] ),
                 digits = round ) ->
            output.b[ which( names( output.b ) == "M1 Statistic: Chisq" ) ] ;
          
          round( as.numeric( output.b[ which( names( output.b ) == 
                                                "Cohen f-squared of var2 on R-squared" ) ] ),
                 digits = round ) ->
            output.b[ which( names( output.b ) == "Cohen f-squared of var2 on R-squared" ) ] ;
        } 
        
        unlist( output.b )-> output.b ;
      } 
    }
    
    # factor > 2 levels & factor
    if ( is.factor( df1$var1 ) &
         is.factor( df1$var2 ) )
    {
      if ( nlevels( df1$var1 ) > 2 &
           nlevels( df1$var2 ) > 1 &
           all( table( df1$var1, df1$var2 ) > 5 ) )
      {
        "var1 ~ var2" |> 
          as.formula() |>
          nnet::multinom( data = df1, 
                          weights = df1$weights1 ) -> m1 ;
        
        m1 |>
          ( function(x) {
            car::Anova( x,
                        type = "3",
                        vcov. = sandwich::vcovCL(m1,  # ATTENTION m1.bis
                                                 cluster = df1[, "GROUP"] )
            ) 
          }
          )() -> 
          anova1 ;
        
        cohen.f2( m1, pseudo.R2 = T, data = df1  ) -> f2 ; 
        
        residuals( m1 ) -> residuals ;
        if ( length( matrix(residuals) ) < 5000 ) 
        { shapiro.test( matrix(residuals) ) -> shapiro.res ; }  else
        { list( "p.value" = NA ) -> shapiro.res ; }
        nortest::ad.test( matrix(residuals) ) -> anderson.res ;
        moments::jarque.test( as.numeric(
          matrix(residuals) ) ) -> jarque.res ;
        
        c( "multinomial", 
           name.a, 
           colnames( data.vars2 )[b], 
           group,
           nrow(df1), nrow(data.vars2) - nrow(df1),
           anova1["var2",3],
           "Analysis of Deviance Table (Type III tests) - Cluster robust and  heteroscedasticity robust test",
           anova1["var2",2],
           nrow(df1) - anova1["var2",2],
           anova1["var2",1],
           anova1["var2",3],
           f2, 
           "",
           shapiro.res$p.value, 
           anderson.res$p.value, 
           jarque.res$p.value
        ) -> 
          output.b ;
        
        c( "class", 
           "var1", "var2", "Group", 
           "N", "Missing", "p value",
           "Method 1", 
           "M1 degree of freedon Chi square", 
           "M1 degree of freedon residuals", 
           "M1 Statistic: LR Chisq", 
           "M1 p",
           "Cohen f-squared of var2 on R-squared",
           "",
           "Shapiro-Wilk normality test on residuals p-value",
           "Anderson-Darling normality test on residuals p-value",
           "Jarque-Bera normality test on residuals p-value"
        ) -> 
          names( output.b ) ;
        
        if ( !is.null( pvalue.round ) ) 
        {  
          p.round( as.numeric( output.b[ which( names( output.b ) == 
                                                  "p value" ) ] ),
                   digits = pvalue.round ) ->
            output.b[ which( names( output.b ) == "p value" ) ] ;
          
          p.round( as.numeric( output.b[ which( names( output.b ) == 
                                                  "M1 p" ) ] ),
                   digits = pvalue.round ) ->
            output.b[ which( names( output.b ) == "M1 p" ) ] ;
          
          p.round( as.numeric( output.b[ which( names( output.b ) == 
                                                  "Shapiro-Wilk normality test on residuals p-value" ) ] ),
                   digits = pvalue.round ) ->
            output.b[ which( names( output.b ) == "Shapiro-Wilk normality test on residuals p-value" ) ] ;
          
          p.round( as.numeric( output.b[ which( names( output.b ) == 
                                                  "Anderson-Darling normality test on residuals p-value" ) ] ),
                   digits = pvalue.round ) ->
            output.b[ which( names( output.b ) == "Anderson-Darling normality test on residuals p-value" ) ] ;
          
          p.round( as.numeric( output.b[ which( names( output.b ) == 
                                                  "Jarque-Bera normality test on residuals p-value" ) ] ),
                   digits = pvalue.round ) ->
            output.b[ which( names( output.b ) == "Jarque-Bera normality test on residuals p-value" ) ] ;
        }
        
        if ( !is.null( round ) ) 
        { 
          round( as.numeric( output.b[ which( names( output.b ) == 
                                                "M1 Statistic: LR Chisq" ) ] ),
                 digits = round ) ->
            output.b[ which( names( output.b ) == "M1 Statistic: LR Chisq" ) ] ;
          
          round( as.numeric( output.b[ which( names( output.b ) == 
                                                "Cohen f-squared of var2 on R-squared" ) ] ),
                 digits = round ) ->
            output.b[ which( names( output.b ) == "Cohen f-squared of var2 on R-squared" ) ] ;
        } 
        
        unlist( output.b )-> output.b ;
      } 
    }
    
    # factor > 2 levels & numeric
    if ( is.factor( df1$var1 ) &
         is.numeric( df1$var2 )  )
    {
      if (  nlevels( df1$var1 ) > 2 &
            all( table( df1$var1 ) > 5 ) &
            nlevels( factor( df1$var2 ) ) > 3 &
            length( df1$var2 ) > 7  )
      {
        "var1 ~ var2" |> 
          as.formula() |>
          nnet::multinom( data = df1, 
                          weights = df1$weights1 ) -> m1 ;
        
        m1 |>
          ( function(x) {
            car::Anova( x,
                        type = "3",
                        vcov. = sandwich::vcovCL(m1,  # ATTENTION m1.bis
                                                 cluster = df1[, "GROUP"] )
            ) 
          }
          )() -> 
          anova1 ;
        
        cohen.f2( m1, pseudo.R2 = T, data = df1  ) -> f2 ; 
        
        residuals( m1 ) -> residuals ;
        if ( length( matrix(residuals) ) < 5000 ) 
        { shapiro.test( matrix(residuals) ) -> shapiro.res ; }  else
        { list( "p.value" = NA ) -> shapiro.res ; }
        nortest::ad.test( matrix(residuals) ) -> anderson.res ;
        moments::jarque.test( as.numeric(
          matrix(residuals) ) ) -> jarque.res ;
        
        c( "multinomial", 
           name.a, 
           colnames( data.vars2 )[b], 
           group,
           nrow(df1), nrow(data.vars2) - nrow(df1),
           anova1["var2",3],
           "Analysis of Deviance Table (Type III tests) - Cluster robust and  heteroscedasticity robust test",
           anova1["var2",2],
           nrow(df1) - anova1["var2",2],
           anova1["var2",1],
           anova1["var2",3],
           f2, 
           "",
           shapiro.res$p.value, 
           anderson.res$p.value, 
           jarque.res$p.value
        ) -> 
          output.b ;
        
        c( "class", 
           "var1", "var2", "Group", 
           "N", "Missing", "p value",
           "Method 1", 
           "M1 degree of freedon Chi square", 
           "M1 degree of freedon residuals", 
           "M1 Statistic: LR Chisq", 
           "M1 p",
           "Cohen f-squared of var2 on R-squared",
           "",
           "Shapiro-Wilk normality test on residuals p-value",
           "Anderson-Darling normality test on residuals p-value",
           "Jarque-Bera normality test on residuals p-value"
        ) -> 
          names( output.b ) ;
        
        if ( !is.null( pvalue.round ) ) 
        {  
          p.round( as.numeric( output.b[ which( names( output.b ) == 
                                                  "p value" ) ] ),
                   digits = pvalue.round ) ->
            output.b[ which( names( output.b ) == "p value" ) ] ;
          
          p.round( as.numeric( output.b[ which( names( output.b ) == 
                                                  "M1 p" ) ] ),
                   digits = pvalue.round ) ->
            output.b[ which( names( output.b ) == "M1 p" ) ] ;
          
          p.round( as.numeric( output.b[ which( names( output.b ) == 
                                                  "Shapiro-Wilk normality test on residuals p-value" ) ] ),
                   digits = pvalue.round ) ->
            output.b[ which( names( output.b ) == "Shapiro-Wilk normality test on residuals p-value" ) ] ;
          
          p.round( as.numeric( output.b[ which( names( output.b ) == 
                                                  "Anderson-Darling normality test on residuals p-value" ) ] ),
                   digits = pvalue.round ) ->
            output.b[ which( names( output.b ) == "Anderson-Darling normality test on residuals p-value" ) ] ;
          
          p.round( as.numeric( output.b[ which( names( output.b ) == 
                                                  "Jarque-Bera normality test on residuals p-value" ) ] ),
                   digits = pvalue.round ) ->
            output.b[ which( names( output.b ) == "Jarque-Bera normality test on residuals p-value" ) ] ;
        }
        
        if ( !is.null( round ) ) 
        { 
          round( as.numeric( output.b[ which( names( output.b ) == 
                                                "M1 Statistic: LR Chisq" ) ] ),
                 digits = round ) ->
            output.b[ which( names( output.b ) == "M1 Statistic: LR Chisq" ) ] ;
          
          round( as.numeric( output.b[ which( names( output.b ) == 
                                                "Cohen f-squared of var2 on R-squared" ) ] ),
                 digits = round ) ->
            output.b[ which( names( output.b ) == "Cohen f-squared of var2 on R-squared" ) ] ;
        } 
        
        unlist( output.b )-> output.b ;
      } 
    }
    
    # Numeric & factor 
    if ( is.numeric( df1$var1 ) &
         is.factor( df1$var2 ) )
    {
      if (  nlevels( factor( df1$var1 ) ) > 3 &
            length( df1$var1 ) > 7 &
            nlevels( df1$var2 ) > 1 &
            all( table( df1$var2 ) > 5 ) )
      {
        "var1 ~ var2" |> 
          as.formula() |>
          lm( data = df1, weights = df1$weights1 ) ->
          m1 ;
        
        m1 |>
          ( function(x) {
            car::Anova( x,
                        type = "3",
                        vcov. = 
                          sandwich::vcovCL( x,
                                            cluster = ~GROUP ) )  
          }
          )() -> 
          anova1 ;
        
        cohen.f2( m1, data = df1 ) -> f2 ; 
        
        heplots::etasq( m1 ) -> eta2 ; 
        
        residuals( m1 ) -> residuals ;
        if ( length( residuals ) < 5000 ) 
        { shapiro.test( residuals ) -> shapiro.res ; }  else
        { list( "p.value" = NA ) -> shapiro.res ; }
        nortest::ad.test( residuals ) -> anderson.res ;
        moments::jarque.test( residuals ) -> jarque.res ;
        
        
        c( "gaussian", 
           name.a, 
           colnames( data.vars2 )[b], 
           group,
           nrow(df1), nrow(data.vars2) - nrow(df1),
           anova1["var2",3],
           "Analysis of Deviance Table (Type III tests) - Cluster robust and  heteroscedasticity robust test",
           anova1[2,1],
           anova1[3,1],
           anova1[2,2],
           anova1["var2",3],
           f2, eta2[1,1],
           shapiro.res$p.value, 
           anderson.res$p.value, 
           jarque.res$p.value
        ) -> 
          output.b ;
        
        c( "class", 
           "var1", "var2", "Group", 
           "N", "Missing", "p value",
           "Method 1", 
           "M1 degree of freedon numerator", 
           "M1 degree of freedon denominator", 
           "M1 Statistic: F", 
           "M1 p",
           "Cohen f-squared of var2 on R-squared",
           "Partial eta-squared",
           "Shapiro-Wilk normality test on residuals p-value",
           "Anderson-Darling normality test on residuals p-value",
           "Jarque-Bera normality test on residuals p-value"
        ) -> 
          names( output.b ) ;
        
        if ( !is.null( pvalue.round ) ) 
        {  
          p.round( as.numeric( output.b[ which( names( output.b ) == 
                                                  "p value" ) ] ),
                   digits = pvalue.round ) ->
            output.b[ which( names( output.b ) == "p value" ) ] ;
          
          p.round( as.numeric( output.b[ which( names( output.b ) == 
                                                  "M1 p" ) ] ),
                   digits = pvalue.round ) ->
            output.b[ which( names( output.b ) == "M1 p" ) ] ;
          
          p.round( as.numeric( output.b[ which( names( output.b ) == 
                                                  "Shapiro-Wilk normality test on residuals p-value" ) ] ),
                   digits = pvalue.round ) ->
            output.b[ which( names( output.b ) == "Shapiro-Wilk normality test on residuals p-value" ) ] ;
          
          p.round( as.numeric( output.b[ which( names( output.b ) == 
                                                  "Anderson-Darling normality test on residuals p-value" ) ] ),
                   digits = pvalue.round ) ->
            output.b[ which( names( output.b ) == "Anderson-Darling normality test on residuals p-value" ) ] ;
          
          p.round( as.numeric( output.b[ which( names( output.b ) == 
                                                  "Jarque-Bera normality test on residuals p-value" ) ] ),
                   digits = pvalue.round ) ->
            output.b[ which( names( output.b ) == "Jarque-Bera normality test on residuals p-value" ) ] ;
        }
        
        if ( !is.null( round ) ) 
        { 
          round( as.numeric( output.b[ which( names( output.b ) == 
                                                "M1 Statistic: F" ) ] ),
                 digits = round ) ->
            output.b[ which( names( output.b ) == "M1 Statistic: F" ) ] ;
          
          round( as.numeric( output.b[ which( names( output.b ) == 
                                                "Cohen f-squared of var2 on R-squared" ) ] ),
                 digits = round ) ->
            output.b[ which( names( output.b ) == "Cohen f-squared of var2 on R-squared" ) ] ;
          
          round( as.numeric( output.b[ which( names( output.b ) == 
                                                "Partial eta-squared" ) ] ),
                 digits = round ) ->
            output.b[ which( names( output.b ) == "Partial eta-squared" ) ] ;
        } 
        
        unlist( output.b )-> output.b ;
      }   
    }
    
    # Numeric & numeric 
    if ( is.numeric( df1$var1 ) &
         is.numeric( df1$var2 ) )
    {
      if (  nlevels( factor( df1$var1 ) ) > 3 &
            length( df1$var1 ) > 7 &
            nlevels( factor( df1$var2 ) ) > 3 &
            length( df1$var2 ) > 7 &
            !all( df1$var1 == df1$var2 ) )
      {
        "var1 ~ var2" |> 
          as.formula() |>
          lm( data = df1, weights = df1$weights1 ) ->
          m1 ;
        
        m1 |>
          ( function(x) {
            car::Anova( x,
                        type = "3",
                        vcov. = 
                          sandwich::vcovCL( x,
                                            cluster = ~GROUP ) )  
          }
          )() -> 
          anova1 ;
        
        cohen.f2( m1, data = df1 ) -> f2 ; 
        
        heplots::etasq( m1 ) -> eta2 ; 
        
        residuals( m1 ) -> residuals ;
        if ( length( residuals ) < 5000 ) 
        { shapiro.test( residuals ) -> shapiro.res ; }  else
        { list( "p.value" = NA ) -> shapiro.res ; }
        nortest::ad.test( residuals ) -> anderson.res ;
        moments::jarque.test( residuals ) -> jarque.res ;
        
        
        c( "gaussian", 
           name.a, 
           colnames( data.vars2 )[b], 
           group,
           nrow(df1), nrow(data.vars2) - nrow(df1),
           anova1["var2",3],
           "Analysis of Deviance Table (Type III tests) - Cluster robust and  heteroscedasticity robust test",
           anova1[2,1],
           anova1[3,1],
           anova1[2,2],
           anova1["var2",3],
           f2, eta2[1,1],
           shapiro.res$p.value, 
           anderson.res$p.value, 
           jarque.res$p.value
        ) -> 
          output.b ;
        
        c( "class", 
           "var1", "var2", "Group", 
           "N", "Missing", "p value",
           "Method 1", 
           "M1 degree of freedon numerator", 
           "M1 degree of freedon denominator", 
           "M1 Statistic: F", 
           "M1 p",
           "Cohen f-squared of var2 on R-squared",
           "Partial eta-squared",
           "Shapiro-Wilk normality test on residuals p-value",
           "Anderson-Darling normality test on residuals p-value",
           "Jarque-Bera normality test on residuals p-value"
        ) -> 
          names( output.b ) ;
        
        if ( !is.null( pvalue.round ) ) 
        {  
          p.round( as.numeric( output.b[ which( names( output.b ) == 
                                                  "p value" ) ] ),
                   digits = pvalue.round ) ->
            output.b[ which( names( output.b ) == "p value" ) ] ;
          
          p.round( as.numeric( output.b[ which( names( output.b ) == 
                                                  "M1 p" ) ] ),
                   digits = pvalue.round ) ->
            output.b[ which( names( output.b ) == "M1 p" ) ] ;
          
          p.round( as.numeric( output.b[ which( names( output.b ) == 
                                                  "Shapiro-Wilk normality test on residuals p-value" ) ] ),
                   digits = pvalue.round ) ->
            output.b[ which( names( output.b ) == "Shapiro-Wilk normality test on residuals p-value" ) ] ;
          
          p.round( as.numeric( output.b[ which( names( output.b ) == 
                                                  "Anderson-Darling normality test on residuals p-value" ) ] ),
                   digits = pvalue.round ) ->
            output.b[ which( names( output.b ) == "Anderson-Darling normality test on residuals p-value" ) ] ;
          
          p.round( as.numeric( output.b[ which( names( output.b ) == 
                                                  "Jarque-Bera normality test on residuals p-value" ) ] ),
                   digits = pvalue.round ) ->
            output.b[ which( names( output.b ) == "Jarque-Bera normality test on residuals p-value" ) ] ;
        }
        
        if ( !is.null( round ) ) 
        { 
          round( as.numeric( output.b[ which( names( output.b ) == 
                                                "M1 Statistic: F" ) ] ),
                 digits = round ) ->
            output.b[ which( names( output.b ) == "M1 Statistic: F" ) ] ;
          
          round( as.numeric( output.b[ which( names( output.b ) == 
                                                "Cohen f-squared of var2 on R-squared" ) ] ),
                 digits = round ) ->
            output.b[ which( names( output.b ) == "Cohen f-squared of var2 on R-squared" ) ] ;
          
          round( as.numeric( output.b[ which( names( output.b ) == 
                                                "Partial eta-squared" ) ] ),
                 digits = round ) ->
            output.b[ which( names( output.b ) == "Partial eta-squared" ) ] ;
        } 
        
        unlist( output.b )-> output.b ;
      } 
    }
    
    # No test possible
    if ( is.null( output.b ) )
    {
      # tests
      
      
      # fusion
      c( "other", name.a, colnames( data.vars2 )[b], identifier, "-",
         nrow(df1), nrow(data.vars2) - nrow(df1)
      ) -> output.b
      
      c( "other", 
         "var1", "var2", "identifier", "-",
         "N", "Missing"
      ) -> 
        names( output.b ) 
      
    }
    
    return( output.b )
  } 
  
  # Load packages
  download.packages( "furrr", 
                     "car", "heplots", "MuMIn",
                     "nortest", 
                     "moments", 
                     "sandwich" ) ;
  
  
  # prepare data
  #=============
  as.data.frame( data ) -> data ; 
  
  data[, which( !( colnames( data ) %in% group ) ) ] -> 
    data.vars ;
  
  data.vars[, which( !( colnames( data.vars ) %in% identifier ) ) ] -> 
    data.vars ; 
  
  data[, which( colnames( data ) %in% group ) ] -> 
    data.group ;
  
  data[, which( colnames( data ) %in% identifier ) ] -> 
    data.identifier ;
  
  # Job
  furrr::future_map( 1:length( data.vars ), 
                     fun.a,
                     data.vars = data.vars, 
                     data.group = data.group, 
                     data.identifier = data.identifier, 
                     group = group,
                     weights = weights,
                     .options = furrr::furrr_options( seed = seed ), .progress = T 
  ) |>
    rbind.force(  empty = "" ) -> 
    output
  
  # prepare output
  c("class", 
    "var1", "var2", "Group", 
    "N", "Missing", "p value",
    "Method 1", 
    "M1 degree of freedon Chi square", 
    "M1 degree of freedon residuals", 
    "M1 Statistic: Chisq", 
    "M1 p",
    "Cohen f-squared of var2 on R-squared",
    "-",
    "Shapiro-Wilk normality test on residuals p-value",
    "Anderson-Darling normality test on residuals p-value",
    "Jarque-Bera normality test on residuals p-value"
  ) -> titles.binomial ;
  
  c(  "class", 
      "var1", "var2", "Group", 
      "N", "Missing", "p value",
      "Method 1", 
      "M1 degree of freedon Chi square", 
      "M1 degree of freedon residuals", 
      "M1 Statistic: LR Chisq", 
      "M1 p",
      "Cohen f-squared of var2 on R-squared",
      "-",
      "Shapiro-Wilk normality test on residuals p-value",
      "Anderson-Darling normality test on residuals p-value",
      "Jarque-Bera normality test on residuals p-value"
  ) -> titles.multinomial ;
  
  c(  "class", 
      "var1", "var2", "Group", 
      "N", "Missing", "p value",
      "Method 1", 
      "M1 degree of freedon numerator", 
      "M1 degree of freedon denominator", 
      "M1 Statistic: F", 
      "M1 p",
      "Cohen f-squared of var2 on R-squared",
      "Partial eta-squared",
      "Shapiro-Wilk normality test on residuals p-value",
      "Anderson-Darling normality test on residuals p-value",
      "Jarque-Bera normality test on residuals p-value"
  ) -> titles.gaussian ;
  
  c( "class", 
     "var1", "var2", "identifier", "-",
     "N", "Missing"
  ) -> titles.other ; 
  
  NULL -> output.tmp
  
  for ( i in levels( factor( output[,1] ) ) )
  {
    if ( grepl( "binomial", i ) )
    {
      rbind.force( output.tmp,
                   titles.binomial,
                   output[ output[,1] == i, ],
                   empty = "" ) ->
        output.tmp ; 
    }
    
    if ( grepl( "multinomial", i ) )
    {
      rbind.force( output.tmp,
                   titles.multinomial,
                   output[ output[,1] == i, ],
                   empty = "" ) ->
        output.tmp ; 
    }
    
    if ( grepl( "gaussian", i ) )
    {
      rbind.force( output.tmp,
                   titles.gaussian,
                   output[ output[,1] == i, ],
                   empty = "" ) ->
        output.tmp ; 
    }
    
    if ( grepl( "other", i ) )
    {
      rbind.force( output.tmp,
                   titles.other,
                   output[ output[,1] == i, ],
                   empty = "" ) ->
        output.tmp ; 
    }
    
  }
  output.tmp -> output
  
  c( "Class", "var", "group", "N", "Missing",
     paste( rep( "col", length( 6:ncol( output ) ) ), 
            6:ncol( output ), sep = "" ) ) ->         
    colnames( output ) ;
  
  # end parallel
  future::plan("sequential")
  
  return( output ) ;
}

# 1.5.4 Function to perform imputations, mean and median
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Imputation_median <- function( data )
{
  data[ , sapply(data, class) == "numeric" ] |>
    sapply( function(x) {
      x[ is.na(x) ] <- median( x, na.rm = T) ;
      return(x)
    }) ->
    data[ , sapply(data, class) == "numeric" ] ;
  
  return(data)
}

Imputation_mean <- function( data )
{
  data[ , sapply(data, class) == "numeric" ] |>
    sapply( function(x) {
      x[ is.na(x) ] <- mean( x, na.rm = T) ;
      return(x)
    }) ->
    data[ , sapply(data, class) == "numeric" ] ;
  
  return(data)
}


# 1.5.5 Function to perform forecasterros plot
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

plotForecastErrors <- function(forecasterrors)
{
  # make a histogram of the forecast errors:
  mybinsize <- IQR(forecasterrors)/4
  mysd   <- sd(forecasterrors)
  mymin  <- min(forecasterrors) - mysd*5
  mymax  <- max(forecasterrors) + mysd*3
  # generate normally distributed data with mean 0 and standard deviation mysd
  mynorm <- rnorm(10000, mean=0, sd=mysd)
  mymin2 <- min(mynorm)
  mymax2 <- max(mynorm)
  if (mymin2 < mymin) { mymin <- mymin2 }
  if (mymax2 > mymax) { mymax <- mymax2 }
  # make a red histogram of the forecast errors, with the normally distributed data overlaid:
  mybins <- seq(mymin, mymax, mybinsize)
  hist(forecasterrors, col="red", freq=FALSE, breaks=mybins)
  # freq=FALSE ensures the area under the histogram = 1
  # generate normally distributed data with mean 0 and standard deviation mysd
  myhist <- hist(mynorm, plot=FALSE, breaks=mybins)
  # plot the normal curve as a blue line on top of the histogram of forecast errors:
  points(myhist$mids, myhist$density, type="l", col="blue", lwd=2)
}

# 1.6 Text mining functions -------------
#~~~~~~~~~~~~~~~~~~~~~~~~~~

# 1.6.1 Function to prepare text for wordnetwork
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

TextToWordNetwork.preparation <- function( corpus, 
                                           Sentence.fusion.proximity = 0,
                                           WordsToFusion = list( c("", "") ),
                                           remove.stopwords = TRUE,
                                           language = "english",
                                           words.to.remove = NULL )
{
  # domestic functions 
  String.Concatener <- function( vector, separator )
  {   
    # exclude NA
    na.omit( vector ) -> vector ;
    
    # selection of length for loop
    if ( length( vector ) >= 2) 
    { 
      # stock fisrt element
      tmp.val1 <- vector[1] ;
      
      # loop to concatenate the nect elements
      for ( a in 2:length( vector ) ) 
      { 
        tmp.val1 <- paste( tmp.val1, vector[a], sep = separator ) ; 
      } ;
    } 
    else
    {
      tmp.val1 <- vector ;
    } ;
    
    return( tmp.val1 ) ;
  } ;
  
  Sentence.Fusion <- function( vector, proximity = 1 )
  {
    # Domestic function
    
    
    # stocker
    vector -> output ;
    
    # job 
    for ( a in 1:length( vector ) )
    {
      for ( b in 1:proximity )
      {
        if ( (a - b) %in% 1:length( vector ) )
        {
          paste( output[a], 
                 vector[a - b], 
                 sep = " " ) ->
            output[a] ;
        }
        
        if ( (a + b) %in% 1:length( vector ) )
        {
          paste( output[a], 
                 vector[a + b], 
                 sep = " " ) ->
            output[a] ;
        }
      }
    }
    
    return( output )
  }
  
  # job 
  corpus |>
    lapply( as.character ) |> 
    unlist() |>
    String.Concatener( separator = "." ) |>
    (function(x) { gsub( ",|’|-|—|_|(|)|[|]|/", "", x ) } )() |>
    (function(x) { gsub( "\\.|\\!|\\?|\\;", " . ", x) } )() -> 
    WN ;
  
  if ( !is.null( words.to.remove ) )
  {
    for (a in words.to.remove)
    {
      WN %>%
        gsub( paste( " ", a, " ", sep = ""), 
              " ", . ) ->
        WN ;
    }
  }
  
  if ( remove.stopwords )
  {
    tm::stopwords( language ) -> sw ;
    
    for (a in sw)
    {
      WN |>
        (function(x) gsub( paste( " ", a, " ", sep = ""), 
                           " ", x ) )() ->
        WN ;
    }
  }
  
  WN |>
    (function(x)  gsub( "  ", " ", x ) )() |>
    strsplit(  "\\." ) |>
    unlist() -> 
    WN ;
  
  
  if ( WordsToFusion[[1]][1] != "" )
  {
    for (a in 1:length(WordsToFusion))
    {
      WN %>%
        gsub( WordsToFusion[[a]][1], 
              WordsToFusion[[a]][2], 
              . ) ->
        WN
    }
  }
  
  if ( Sentence.fusion.proximity != 0 )
  {
    WN |>
      Sentence.Fusion( Sentence.fusion.proximity ) -> 
      WN ;
  }
  
  WN |>
    (function(x) gsub( "  ", " ", x ) )() |>
    strsplit(  
      " " ) -> 
    WN ; 
  
  WN |>
    lapply( function(x){ x[ x != ""] } ) ->
    WN ; 
  
  NULL -> tmp ;
  for (a in 1:length(WN) )
  {
    if ( length( WN[[a]] ) != 0 )
    {
      c( tmp, WN[a] ) -> tmp ;
    }
  }
  
  return( tmp )
}

# 1.6.2 Function to perform wordnetwork
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

WordNetwork <- function( KeyWords, save.plot = FALSE, exportfile = NULL, 
                         wordfrequence.filter = 1, weight.filter = 0.1, 
                         labels.filter = 0.5, 
                         seed = 123 )
{
  # domestic functions 
  download.packages <- function( PackagesNames, ... )
  {
    # Get a vector with packages names 
    packages1 <- c( PackagesNames, ... ) ;
    
    # Install packages
    for (a in 1:length( packages1 ) )
    {
      try( find.package( packages1[a]), silent = TRUE ) -> test ;
      
      if ( class( test ) == "try-error" )
      { print( packages1[a] ) ; 
        install.packages(  packages1[a] ) ;
      } 
    }
  } ;
  
  # load packages 
  download.packages(  "dplyr", "ggplot2",
                      "network",
                      "sna", 
                      "ggnetwork",
                      "tnet" ) ;
  
  require( ggplot2 ) ; require( ggnetwork ) ; require( network )
  
  # Words frequency
  KeyWords |> 
    unlist() |> 
    table() |> 
    data.frame() |>  
    dplyr::arrange( -Freq ) -> 
    WordsFreq ;
  
  # nmax
  if ( nrow(WordsFreq) < 15 )
  { nmax <- nrow(WordsFreq) } else { nmax <- 15 }
  
  # Barplot of words Frequenc 
  ggplot( WordsFreq[1:nmax,], 
          aes( reorder( Var1, -Freq), Freq ) ) + 
    geom_bar(stat = "identity") + 
    xlab("Terms") + ylab( "Count") +
    theme(axis.text.x = element_text(angle = 45, hjust = 1) ) -> Barplot ;
  
  if (save.plot) { ggsave( paste( exportfile, 
                                  "/Barplot_WordsFreq.png", 
                                  sep = "" ), 
                           Barplot) } ;
  
  # Delete words under a certain frequence
  WordsFreq |>
    dplyr::filter(  Freq >= wordfrequence.filter ) |>
    dplyr::select( 1 ) |>
    as.matrix() |>
    as.character() -> 
    FreqWords ;
  
  if( length( FreqWords ) == 0 )
  {
    warning( "wordfrequence.filter is too high" ) ; stop() ;
  }
  
  KeyWords |>
    lapply(  function(x){ x[ x %in% FreqWords ] } ) ->
    KeyWords ;
  
  # Links between words 
  KeyWords |> 
    lapply( function(x){expand.grid(W1 = x, W2 = x, w = 1 / length(x), 
                                    stringsAsFactors = FALSE)} ) |>
    dplyr::bind_rows() -> 
    tmp1 ;
  
  tmp1 |> 
    dplyr::select( -w) |> 
    apply( MARGIN = 1, FUN = sort ) |>
    t() |> 
    data.frame( stringsAsFactors = FALSE) |>
    dplyr::mutate( w = tmp1$w) |>
    dplyr::group_by( X1, X2 ) |>
    dplyr::summarise(w = sum(w) ) |>  
    as.data.frame() |>
    dplyr::filter( X1 != X2) |> 
    dplyr::filter( w >= weight.filter) -> 
    links1 ;
  
  # Network creation
  links1 |> 
    dplyr::select( -w) |>
    network::network( directed = FALSE ) -> 
    network1 ;
  
  network::set.edge.attribute(network1, "weight", tmp1$w) ;
  
  network1 |>  network::as.edgelist( attrname = "weight") -> tmp2 ;
  
  tnet::symmetrise_w(tmp2) -> tmp2 ; 
  tnet::as.tnet(tmp2) |> tnet::degree_w() -> tmp2 ;
  network::set.vertex.attribute(network1, "degree_w", tmp2[,"output"]) ;
  
  # Labelling
  network1 %v% "degree_w" -> labels1 ;
  ifelse(labels1 >= quantile(labels1, labels.filter),  network::network.vertex.names(network1), NA) -> labels1 ;
  network::set.vertex.attribute(network1, "label", labels1) ;
  
  # Network graph
  set.seed( seed) ;
  ggplot(network1, aes(x, y, xend = xend, yend = yend)) +
    geom_edges(aes(color = weight)) +
    geom_nodes(color = "grey50") +
    geom_nodelabel(aes(size = degree_w, label = label), color = "grey20", label.size = NA) +
    scale_size_continuous(range = c(2, 8)) +
    scale_color_gradient2(low = "grey25", midpoint = 0.75, high = "black") +
    guides(size = FALSE, color = FALSE) + 
    theme_blank() -> Network ;
  print(Network) ;
  
  if (save.plot) { ggsave( paste( exportfile, 
                                  "/WordNetwork.png", 
                                  sep = "" ), 
                           Network) } ;
  
  return( list(WordsFreq = WordsFreq, 
               Links = dplyr::arrange( links1, desc( w ) ), 
               Barplot = Barplot, 
               Network = Network ) ) ;
} ;

# 1.6.3 Function to clean empty space
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

CleanEmpty <- function( x )
{
  x[ x == "" ] <- NA
  
  x
}

# 1.6.4 Function to clean text
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

TextCleaning <- function( corpus, WordsToRM = NULL, 
                          RMstopwords = TRUE,
                          language = "english", 
                          RMpunctuation = TRUE )
{
  # domestic functions 
  download.packages <- function( PackagesNames, ... )
  {
    # Get a vector with packages names 
    packages1 <- c( PackagesNames, ... ) ;
    
    # Install packages
    for (a in 1:length( packages1 ) )
    {
      try( find.package( packages1[a]), silent = TRUE ) -> test ;
      
      if ( class( test ) == "try-error" )
      { print( packages1[a] ) ; 
        install.packages(  packages1[a] ) ;
      } 
    }
  } ;
  
  toSpace <- tm::content_transformer( function(x, pattern) { return (gsub(pattern, " ", x) ) } ) 
  
  # load packages 
  download.packages( "tm" ) ;
  
  # job
  if ( RMstopwords ) 
  {
    corpus |>
      tm::tm_map( tm::removeWords, tm::stopwords(language) ) -> 
      corpus ;
  }
  
  if ( RMpunctuation ) 
  {
    corpus |>
      tm::tm_map( tm::removePunctuation) ->
      corpus ;
  }
  
  corpus |> 
    tm::tm_map( toSpace, "/") |> 
    tm::tm_map( toSpace, "@") |>  
    tm::tm_map( toSpace, "\\|") |> 
    tm::tm_map( toSpace, "#") |>  
    tm::tm_map( toSpace, "$") |>  
    tm::tm_map( toSpace, "€" ) |> 
    tm::tm_map( toSpace, ":") |> 
    tm::tm_map( toSpace, "-") |>  
    tm::tm_map( toSpace, "'") |> 
    tm::tm_map( toSpace, "’") |> 
    tm::tm_map( toSpace, "\\(") |> 
    tm::tm_map( toSpace, "\\)") |> 
    tm::tm_map( toSpace, "\\{") |> 
    tm::tm_map( toSpace, "\\}") |> 
    tm::tm_map( toSpace, "\\[") |> 
    tm::tm_map( toSpace, "\\]") |> 
    tm::tm_map( tm::removeNumbers) |>  
    tm::tm_map( tm::content_transformer(tolower) ) |> 
    tm::tm_map( tm::stripWhitespace) -> 
    corpus ;
  
  if ( !is.null(WordsToRM) ) 
  { 
    corpus |> 
      tm::tm_map( tm::removeWords, WordsToRM ) -> 
      corpus ; 
  } ;
  
  return( corpus ) ;
} ;

# 1.6.5 Function to lemmatize corpus
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

lemmatization.corpus <- function( corpus, lang = "fr",
                                  install.lang = FALSE,
                                  treetaggerfilepath = "~/Programs/Treetagger/",
                                  unknown.words = TRUE )
{
  # domestic functions 
  download.packages <- function( PackagesNames, ... )
  {
    # Get a vector with packages names 
    packages1 <- c( PackagesNames, ... ) ;
    
    # Install packages
    for (a in 1:length( packages1 ) )
    {
      try( find.package( packages1[a]), silent = TRUE ) -> test ;
      
      if ( class( test ) == "try-error" )
      { print( packages1[a] ) ; 
        install.packages(  packages1[a] ) ;
      } 
    }
  } ;
  
  # load packages 
  download.packages( "tm", "koRpus", "stringr" ) ;
  
  # install missing lang
  if ( install.lang )
  {
    koRpus::install.koRpus.lang(c("en", "de", "es", "fr", "it", "nl", "pt", "ru"))
  }
  
  # load lang
  require( paste0( "koRpus.lang.", lang ), character.only = T )
  
  # Job
  
  if ( unknown.words )
  {
    lapply( 1:length(corpus), 
            function( a, corpus) {
              koRpus::treetag(gsub("(?<=[\\s])\\s*|^\\s+|\\s+$", "", 
                                   stringr::str_squish(corpus[[a]][[1]]), 
                                   perl=TRUE), 
                              treetagger = "manual", 
                              format = "obj", TT.tknz = FALSE, 
                              lang = lang, 
                              TT.options = list(path = treetaggerfilepath, 
                                                preset = lang ) ) -> 
                lemma ;
              
              lemma@tokens -> lemma ;
              
              lemma[ !is.na( lemma$lemma ), ] ->
                lemma ;
              
              lemma[ lemma$lemma == "<unknown>", "token" ] ->
                lemma[ lemma$lemma == "<unknown>", "lemma" ]
              
              return( lemma$lemma )
            },
            corpus ) ->
      lemma ;
  } else
  {
    lapply( 1:length(corpus), 
            function( a, corpus) {
              koRpus::treetag(gsub("(?<=[\\s])\\s*|^\\s+|\\s+$", "", 
                                   stringr::str_squish(corpus[[a]][[1]]), 
                                   perl=TRUE), 
                              treetagger = "manual", 
                              format = "obj", TT.tknz = FALSE, 
                              lang = lang, 
                              TT.options = list(path = treetaggerfilepath, 
                                                preset = lang ) ) -> 
                lemma ;
              
              lemma@tokens -> lemma ;
              
              lemma[ !is.na( lemma$lemma ), ] ->
                lemma ;
              
              lemma[ lemma$lemma != "<unknown>", ] ->
                lemma ;
              
              return( lemma$lemma )
            },
            corpus ) ->
      lemma ;
  }
  
  
  
  lapply( lemma, function(x) { paste( x, collapse = " ") } ) ->
    texts ;
  
  lapply( texts, function(x) {gsub( " \\.", ".", x) } ) ->
    texts ;
  
  lapply( texts, function(x) {gsub( " ,", ",", x) } ) ->
    texts ;
  
  lapply( texts, function(x) {gsub( " '", "'", x) } ) ->
    texts ;
  tm::VCorpus( tm::VectorSource( texts ) ) ->
    output ;
  
  names( corpus ) ->
    names( output ) ;
  
  return( output )
}

# 1.6.6 Function to perform tf.idf.rank
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

tf.idf.rank <- function( tdm )
{
  tdm |> 
    as.matrix() ->
    tdm
  
  # Total count 
  tdm |> 
    (function(x) data.frame( x, total = rowSums(x) ) )() |> 
    dplyr::select( total) ->
    total ;
  
  # tf
  tdm |> 
    colSums() ->
    Total.words ;
  
  tdm -> tdm.tfprop ;
  for (a in 1:dim(tdm)[2] )
  {
    tdm[,a] / Total.words[a] ->
      tdm.tfprop[,a] ;
  }
  
  paste( colnames(tdm), 
         "tfprop", 
         sep = "." ) ->
    colnames( tdm.tfprop ) ;
  
  # idf 
  dim( tdm )[2] -> nb.doc ;
  
  NULL -> idf ;
  for (a in 1:dim(tdm)[1] )
  {
    tdm[a,] > 0 ->
      nb.doc.with.term ;
    
    sum( nb.doc.with.term ) ->
      nb.doc.with.term ;
    
    c( idf, log( nb.doc / nb.doc.with.term ) ) ->
      idf
  }
  
  # tf * idf
  tdm -> tdm.tf.x.idf ;
  for (a in 1:dim(tdm)[2] )
  {
    tdm[,a] * idf ->
      tdm.tf.x.idf[,a] ;
  }
  
  paste( colnames(tdm), 
         "tf.x.idf", 
         sep = "." ) ->
    colnames( tdm.tf.x.idf ) ;
  
  # tfprop * idf
  tdm -> tdm.tfprop.x.idf ;
  for (a in 1:dim(tdm)[2] )
  {
    tdm.tfprop[,a] * idf ->
      tdm.tfprop.x.idf[,a] ;
  }
  
  paste( colnames(tdm), 
         "tfprop.x.idf", 
         sep = "." ) ->
    colnames( tdm.tfprop.x.idf ) ;
  
  # rank
  tdm -> tdm.rank ;
  for (a in 1:dim(tdm)[2] )
  {
    rank( tdm[,a] ) ->
      tdm.rank[,a] ;
  }
  
  paste( colnames(tdm), 
         "rank", 
         sep = "." ) ->
    colnames( tdm.rank ) ;
  
  # fusion
  cbind.data.frame( total,
                    idf = idf,
                    tdm,
                    tdm.tfprop,
                    tdm.tf.x.idf,
                    tdm.tfprop.x.idf,
                    tdm.rank ) ->
    output ;
  
  rownames( tdm ) ->
    rownames( output ) ;
  
  return( output )
}

# 1.6.7 Function to perform corpus description
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Corpus.Description <- function( corpus, 
                                doc.name.extension = ".txt", 
                                round = NULL )
{
  # domestic functions 
  download.packages <- function( PackagesNames, ... )
  {
    # Get a vector with packages names 
    packages1 <- c( PackagesNames, ... ) ;
    
    # Install packages
    for (a in 1:length( packages1 ) )
    {
      try( find.package( packages1[a]), silent = TRUE ) -> test ;
      
      if ( class( test ) == "try-error" )
      { print( packages1[a] ) ; 
        install.packages(  packages1[a] ) ;
      } 
    }
  } ;
  
  as.numeric.data.frame <- function( dataframe )
  {
    for ( a in 1:dim( dataframe )[2] )
    {
      if ( sum( is.na( as.numeric( as.character( dataframe[,a] ) ) ) ) == 
           sum( is.na( dataframe[,a] ) ) )
      { 
        dataframe[,a] <- as.numeric( as.character( dataframe[,a] ) )
      } ;
    } ;
    return( dataframe ) ;
  } ;
  
  # load packages 
  download.packages( "dplyr", "tm", "quanteda", "quanteda.textstats" ) ;
  
  # job
  corpus |>
    lapply(  as.character) |>
    lapply(  length) |> 
    unlist() |> 
    (function(x) cbind( document = gsub( doc.name.extension, "", names(x) ), 
                        paragraphs = x) )() |> 
    as.data.frame() -> 
    paragraphs ;
  
  corpus |>
    lapply(  as.character ) |>
    lapply(  function(x) gsub( ",|’|-|—|_|(|)|[|]|/", "", x ) ) |>
    lapply(  function(x) unlist( strsplit( x, "\\.|\\!|\\?|\\;|:" ) ) ) |>
    lapply(  length ) |>
    unlist() |>
    (function(x) cbind( document = gsub( doc.name.extension, "", names(x) ), 
                        sentences = x) )() |> 
    as.data.frame() ->
    sentences ;
  
  corpus |>
    tm::TermDocumentMatrix() |>
    as.matrix() |> 
    colSums() |>  
    (function(x) cbind( document = gsub( doc.name.extension, "", 
                                         names(x) ), 
                        words = x) )() |> 
    as.data.frame() ->
    words ;
  
  corpus |> 
    quanteda::corpus() |> 
    quanteda::tokens() |> 
    quanteda.textstats::textstat_lexdiv() |> 
    (function(x) dplyr::mutate( x, 
                                document = gsub( doc.name.extension, 
                                                 "", x$document ) ) )() ->
    lexdiv ;
  
  words$document -> lexdiv$document ;
  
  merge( words, sentences, by = "document" ) |> 
    merge(  paragraphs, by = "document" ) |> 
    merge(  lexdiv, by = "document" ) ->
    output ;
  
  
  output |> 
    as.numeric.data.frame() ->
    output ;
  
  output$document |>
    as.character() ->
    output$document ;
  
  output[,2:4] |>
    colSums() -> 
    tmp ;
  
  corpus |>
    quanteda::corpus() |>
    quanteda::tokens()|>
    quanteda::dfm()  |>
    as.matrix() |>
    apply(  2, sum) |> 
    (function(x) matrix( x, nrow = 1, 
                         dimnames = list( c( "All documents"), 
                                          names(x) ) ) )() |> 
    quanteda::as.dfm() |>
    quanteda.textstats::textstat_lexdiv() |>
    dplyr::select( -1 ) |>
    as.numeric() |>
    (function(x) c( tmp, x ) )() ->
    tmp ;
  
  rbind( output,
         c( "Total", tmp) ) |>
    as.numeric.data.frame() ->
    output ;
  
  corpus  |>
    tm::TermDocumentMatrix()  |>
    as.matrix()  |>
    apply( 
      2,
      function(x) { length( x[ x == 0 ] ) / length( x ) } )  |>
    c( 
      quanteda::sparsity( quanteda::dfm( quanteda::tokens( quanteda::corpus( corpus ) ) ) ) )->
    sparsity ;
  
  output |>
    cbind.data.frame( 
      sparsity = sparsity ) ->
    output ;
  
  if ( !is.null( round ) ) 
  {
    output[,-1]  |>
      round( round ) ->
      output[,-1] ;
  }
  
  return( output )
}

# 1.6.8 Function to palette blue
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Scale.Blue <- function(n)
{ colorRampPalette( c("paleturquoise1", "cyan", "deepskyblue", "dodgerblue", "blue4") )(n) } ;


#>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

# END
